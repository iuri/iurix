--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.11
-- Dumped by pg_dump version 9.6.11

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: acs_permission; Type: SCHEMA; Schema: -; Owner: evex
--

CREATE SCHEMA acs_permission;


ALTER SCHEMA acs_permission OWNER TO evex;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: cr_item_storage_type_enum; Type: TYPE; Schema: public; Owner: evex
--

CREATE TYPE public.cr_item_storage_type_enum AS ENUM (
    'text',
    'file',
    'lob'
);


ALTER TYPE public.cr_item_storage_type_enum OWNER TO evex;

--
-- Name: grant_permission(integer, integer, character varying); Type: FUNCTION; Schema: acs_permission; Owner: evex
--

CREATE FUNCTION acs_permission.grant_permission(p_object_id integer, p_grantee_id integer, p_privilege character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_permissions
      (object_id, grantee_id, privilege)
    values
      (p_object_id, p_grantee_id, p_privilege);
    
    return 0;
EXCEPTION 
    when unique_violation then
      return 0;
END;
$$;


ALTER FUNCTION acs_permission.grant_permission(p_object_id integer, p_grantee_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: parties_with_object_privilege(integer, character varying); Type: FUNCTION; Schema: acs_permission; Owner: evex
--

CREATE FUNCTION acs_permission.parties_with_object_privilege(p_object_id integer, p_privilege character varying) RETURNS TABLE(party_id integer)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_security_context_root  integer;
BEGIN
    v_security_context_root := acs__magic_object_id('security_context_root');

    RETURN QUERY
    WITH RECURSIVE
       object_context(obj_id, context_id, orig_obj_id) AS (
           SELECT p_object_id, p_object_id, p_object_id
           UNION ALL
           SELECT
              ao.object_id,
              CASE WHEN (ao.security_inherit_p = 'f' OR ao.context_id IS NULL) 
              THEN v_security_context_root ELSE ao.context_id END, 
              oc.orig_obj_id
           FROM  object_context oc, acs_objects ao
           WHERE ao.object_id = oc.context_id
           AND   ao.object_id != v_security_context_root
           
       ), privilege_ancestors(privilege, child_privilege) AS (
           SELECT p_privilege, p_privilege
           UNION ALL
           SELECT aph.privilege, aph.child_privilege
           FROM privilege_ancestors pa
           JOIN acs_privilege_hierarchy aph ON aph.child_privilege = pa.privilege
       )
       SELECT pap.member_id
       FROM  acs_permissions p
       JOIN  party_approved_member_map pap ON pap.party_id =  p.grantee_id
       JOIN  privilege_ancestors pa        ON pa.privilege =  p.privilege
       JOIN  object_context oc             ON p.object_id  =  oc.context_id;
END; 
$$;


ALTER FUNCTION acs_permission.parties_with_object_privilege(p_object_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: permission_p(integer, integer, character varying); Type: FUNCTION; Schema: acs_permission; Owner: evex
--

CREATE FUNCTION acs_permission.permission_p(p_object_id integer, p_party_id integer, p_privilege character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_security_context_root   integer;
BEGIN
    v_security_context_root := acs__magic_object_id('security_context_root');

    RETURN EXISTS (WITH RECURSIVE
        object_context(object_id, context_id) AS (

            SELECT p_object_id, p_object_id 
            FROM acs_objects 
            WHERE object_id = p_object_id

            UNION ALL

            SELECT ao.object_id,
                   CASE WHEN (ao.security_inherit_p = 'f' OR ao.context_id IS NULL) 
                   THEN v_security_context_root ELSE ao.context_id END
            FROM object_context oc, acs_objects ao
            WHERE ao.object_id = oc.context_id
            AND ao.object_id != v_security_context_root

        ), privilege_ancestors(privilege, child_privilege) AS (

            SELECT p_privilege, p_privilege 
   
            UNION ALL

            SELECT aph.privilege, aph.child_privilege
            FROM privilege_ancestors pa
            JOIN acs_privilege_hierarchy aph ON aph.child_privilege = pa.privilege

        )
        SELECT 1 FROM acs_permissions p
        JOIN  party_approved_member_map pap ON pap.party_id  =  p.grantee_id
        JOIN  privilege_ancestors pa        ON  pa.privilege =  p.privilege
        JOIN  object_context oc             ON  p.object_id  =  oc.context_id      
        WHERE pap.member_id = p_party_id
    );
END;
$$;


ALTER FUNCTION acs_permission.permission_p(p_object_id integer, p_party_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: permission_p_recursive_array(integer[], integer, character varying); Type: FUNCTION; Schema: acs_permission; Owner: evex
--

CREATE FUNCTION acs_permission.permission_p_recursive_array(p_objects integer[], p_party_id integer, p_privilege character varying) RETURNS TABLE(object_id integer, orig_object_id integer)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_security_context_root  integer;
BEGIN
    v_security_context_root := acs__magic_object_id('security_context_root');

    RETURN QUERY WITH RECURSIVE
       object_context(obj_id, context_id, orig_obj_id) AS (

           SELECT unnest(p_objects), unnest(p_objects), unnest(p_objects)
           UNION ALL
           SELECT
              ao.object_id,
              CASE WHEN (ao.security_inherit_p = 'f' OR ao.context_id IS NULL) 
              THEN v_security_context_root ELSE ao.context_id END, 
              oc.orig_obj_id
           FROM  object_context oc, acs_objects ao
           WHERE ao.object_id = oc.context_id
           AND   ao.object_id != v_security_context_root

       ), privilege_ancestors(privilege, child_privilege) AS (

           SELECT p_privilege, p_privilege
           UNION ALL
           SELECT aph.privilege, aph.child_privilege
           FROM   privilege_ancestors pa
           JOIN   acs_privilege_hierarchy aph ON aph.child_privilege = pa.privilege

       )
       SELECT p.object_id, oc.orig_obj_id
       FROM  acs_permissions p
       JOIN  party_approved_member_map pap ON pap.party_id =  p.grantee_id
       JOIN  privilege_ancestors pa        ON pa.privilege =  p.privilege
       JOIN  object_context oc             ON p.object_id  =  oc.context_id
       WHERE pap.member_id = p_party_id;
END; 
$$;


ALTER FUNCTION acs_permission.permission_p_recursive_array(p_objects integer[], p_party_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: permissions_all(integer); Type: FUNCTION; Schema: acs_permission; Owner: evex
--

CREATE FUNCTION acs_permission.permissions_all(p_object_id integer) RETURNS TABLE(object_id integer, grantee_id integer, privilege character varying)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_security_context_root  integer;
BEGIN
    v_security_context_root := acs__magic_object_id('security_context_root');

    RETURN QUERY
    WITH RECURSIVE object_context(obj_id, context_id, orig_obj_id) AS (
           SELECT p_object_id, p_object_id, p_object_id
           UNION ALL
           SELECT
              ao.object_id,
              CASE WHEN (ao.security_inherit_p = 'f' OR ao.context_id IS NULL) 
              THEN v_security_context_root ELSE ao.context_id END, 
              oc.orig_obj_id
           FROM  object_context oc, acs_objects ao
           WHERE ao.object_id = oc.context_id
           AND   ao.object_id != v_security_context_root
    )
    select p_object_id, p.grantee_id, p.privilege
    from object_context oc, acs_permissions p where p.object_id = oc.context_id;
END;
$$;


ALTER FUNCTION acs_permission.permissions_all(p_object_id integer) OWNER TO evex;

--
-- Name: revoke_permission(integer, integer, character varying); Type: FUNCTION; Schema: acs_permission; Owner: evex
--

CREATE FUNCTION acs_permission.revoke_permission(p_object_id integer, p_grantee_id integer, p_privilege character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from acs_permissions
    where object_id = p_object_id
    and grantee_id = p_grantee_id
    and privilege = p_privilege;

    return 0; 
END;
$$;


ALTER FUNCTION acs_permission.revoke_permission(p_object_id integer, p_grantee_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: acs__add_user(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs__add_user(p_user_id integer, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_authority_id integer, p_username character varying, p_email character varying, p_url character varying, p_first_names character varying, p_last_name character varying, p_password character, p_salt character, p_screen_name character varying, p_email_verified_p boolean, p_member_state character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id              users.user_id%TYPE;
    v_rel_id               membership_rels.rel_id%TYPE;
BEGIN
    v_user_id := acs_user__new (
        p_user_id, 
        p_object_type, 
        p_creation_date,
        p_creation_user, 
        p_creation_ip, 
        p_authority_id,
        p_username,
        p_email,
        p_url, 
        p_first_names, 
        p_last_name, 
        p_password,
	p_salt, 
        p_screen_name, 
        p_email_verified_p,
        null                  -- context_id
    );
   
    v_rel_id := membership_rel__new (
      null,
      'membership_rel',
      acs__magic_object_id('registered_users'),      
      v_user_id,
      p_member_state,
      null,
      null);

    PERFORM acs_permission__grant_permission (
      v_user_id,
      v_user_id,
      'read'
      );

    PERFORM acs_permission__grant_permission (
      v_user_id,
      v_user_id,
      'write'
      );

    return v_user_id;
   
END;
$$;


ALTER FUNCTION public.acs__add_user(p_user_id integer, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_authority_id integer, p_username character varying, p_email character varying, p_url character varying, p_first_names character varying, p_last_name character varying, p_password character, p_salt character, p_screen_name character varying, p_email_verified_p boolean, p_member_state character varying) OWNER TO evex;

--
-- Name: acs__magic_object_id(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs__magic_object_id(magic_object_id__name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
    return object_id
    from acs_magic_objects
    where name = magic_object_id__name;
END;
$$;


ALTER FUNCTION public.acs__magic_object_id(magic_object_id__name character varying) OWNER TO evex;

--
-- Name: acs__remove_user(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs__remove_user(remove_user__user_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_rec           record;
BEGIN
    delete
    from acs_permissions
    where grantee_id = remove_user__user_id;

    for v_rec in select rel_id
                 from acs_rels
                 where object_id_two = remove_user__user_id
    loop
        perform acs_rel__delete(v_rec.rel_id);
    end loop;

    perform acs_user__delete(remove_user__user_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs__remove_user(remove_user__user_id integer) OWNER TO evex;

--
-- Name: acs_activity__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_activity__delete(delete__activity_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       -- Cascade will cause delete from acs_activities 
       -- and acs_activity_object_map

       PERFORM acs_object__delete(delete__activity_id); 

       return 0;

END;
$$;


ALTER FUNCTION public.acs_activity__delete(delete__activity_id integer) OWNER TO evex;

--
-- Name: acs_activity__edit(integer, character varying, text, boolean, text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_activity__edit(edit__activity_id integer, edit__name character varying, edit__description text, edit__html_p boolean, edit__status_summary text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       update acs_activities
       set    name        = coalesce(edit__name, name),
              description = coalesce(edit__description, description),
              html_p      = coalesce(edit__html_p, html_p),
              status_summary = coalesce(edit__status_summary, status_summary)
       where activity_id  = edit__activity_id;

       update acs_objects
       set    title = coalesce(edit__name, name)
       where activity_id  = edit__activity_id;

       return 0;

END;
$$;


ALTER FUNCTION public.acs_activity__edit(edit__activity_id integer, edit__name character varying, edit__description text, edit__html_p boolean, edit__status_summary text) OWNER TO evex;

--
-- Name: acs_activity__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_activity__name(name__activity_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE 
       v_activity_name		acs_activities.name%TYPE;
BEGIN
       select  name
       into    v_activity_name
       from    acs_activities
       where   activity_id = name__activity_id;

       return  v_activity_name;

END;
$$;


ALTER FUNCTION public.acs_activity__name(name__activity_id integer) OWNER TO evex;

--
-- Name: acs_activity__new(integer, character varying, text, boolean, text, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_activity__new(new__activity_id integer, new__name character varying, new__description text, new__html_p boolean, new__status_summary text, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE       
       v_activity_id		  acs_activities.activity_id%TYPE;
BEGIN
       v_activity_id := acs_object__new(
            new__activity_id,	   -- object_id
            new__object_type,	   -- object_type
            new__creation_date,    -- creation_date  
            new__creation_user,    -- creation_user
            new__creation_ip,	   -- creation_ip
            new__context_id,	   -- context_id
            't',		   -- security_inherit_p
            new__name,		   -- title
            null		   -- package_id
	    );

       insert into acs_activities
            (activity_id, name, description, html_p, status_summary)
       values
            (v_activity_id, new__name, new__description, new__html_p, new__status_summary);

       return v_activity_id;

END;
$$;


ALTER FUNCTION public.acs_activity__new(new__activity_id integer, new__name character varying, new__description text, new__html_p boolean, new__status_summary text, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer) OWNER TO evex;

--
-- Name: acs_activity__object_map(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_activity__object_map(object_map__activity_id integer, object_map__object_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       insert into acs_activity_object_map
            (activity_id, object_id)
       values
            (object_map__activity_id, object_map__object_id);

       return 0;

END;
$$;


ALTER FUNCTION public.acs_activity__object_map(object_map__activity_id integer, object_map__object_id integer) OWNER TO evex;

--
-- Name: acs_activity__object_unmap(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_activity__object_unmap(object_unmap__activity_id integer, object_unmap__object_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

       delete from acs_activity_object_map
       where  activity_id = object_unmap__activity_id
       and    object_id   = object_unmap__object_id;

       return 0;

END;
$$;


ALTER FUNCTION public.acs_activity__object_unmap(object_unmap__activity_id integer, object_unmap__object_id integer) OWNER TO evex;

--
-- Name: acs_attribute__add_description(character varying, character varying, character varying, text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_attribute__add_description(add_description__object_type character varying, add_description__attribute_name character varying, add_description__description_key character varying, add_description__description text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_attribute_descriptions
     (object_type, attribute_name, description_key, description)
    values
     (add_description__object_type, add_description__attribute_name,
      add_description__description_key, add_description__description);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_attribute__add_description(add_description__object_type character varying, add_description__attribute_name character varying, add_description__description_key character varying, add_description__description text) OWNER TO evex;

--
-- Name: acs_attribute__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_attribute__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, integer, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
    return acs_attribute__create_attribute ($1, $2, $3, $4, $5, $6, $7, cast ($8 as varchar), $9, $10, $11, $12, $13);
END;
$_$;


ALTER FUNCTION public.acs_attribute__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, integer, character varying, boolean) OWNER TO evex;

--
-- Name: acs_attribute__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_attribute__create_attribute(p_object_type character varying, p_attribute_name character varying, p_datatype character varying, p_pretty_name character varying, p_pretty_plural character varying, p_table_name character varying, p_column_name character varying, p_default_value character varying, p_min_n_values integer, p_max_n_values integer, p_sort_order integer, p_storage character varying, p_static_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_attribute__create_attribute/13 maybe obsolete, when we define proper defaults for /20
--
DECLARE
BEGIN
  return acs_attribute__create_attribute(p_object_type,
    p_attribute_name, p_datatype, p_pretty_name,
    p_pretty_plural, p_table_name, p_column_name,
    p_default_value, p_min_n_values,
    p_max_n_values, p_sort_order, p_storage,
    p_static_p, 'f', null, null, null, null, null, null);
END;
$$;


ALTER FUNCTION public.acs_attribute__create_attribute(p_object_type character varying, p_attribute_name character varying, p_datatype character varying, p_pretty_name character varying, p_pretty_plural character varying, p_table_name character varying, p_column_name character varying, p_default_value character varying, p_min_n_values integer, p_max_n_values integer, p_sort_order integer, p_storage character varying, p_static_p boolean) OWNER TO evex;

--
-- Name: acs_attribute__create_attribute(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, boolean, boolean, character varying, character varying, boolean, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_attribute__create_attribute(p_object_type character varying, p_attribute_name character varying, p_datatype character varying, p_pretty_name character varying, p_pretty_plural character varying, p_table_name character varying, p_column_name character varying, p_default_value character varying, p_min_n_values integer, p_max_n_values integer, p_sort_order integer, p_storage character varying, p_static_p boolean, p_create_column_p boolean, p_database_type character varying, p_size character varying, p_null_p boolean, p_references character varying, p_check_expr character varying, p_column_spec character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

  v_sort_order            acs_attributes.sort_order%TYPE;
  v_attribute_id          acs_attributes.attribute_id%TYPE;
  v_column_spec           text;
  v_table_name            text;
  v_constraint_stub       text;
  v_column_name           text;
  v_datatype              record;

BEGIN

  if not exists (select 1
                 from acs_object_types
                 where object_type = p_object_type) then
    raise exception 'Object type % does not exist', p_object_type;
  end if; 

  if p_sort_order is null then
    select coalesce(max(sort_order), 1) into v_sort_order
    from acs_attributes
    where object_type = p_object_type
    and attribute_name = p_attribute_name;
  else
    v_sort_order := p_sort_order;
  end if;

  select nextval('t_acs_attribute_id_seq') into v_attribute_id;

  insert into acs_attributes
    (attribute_id, object_type, table_name, column_name, attribute_name,
     pretty_name, pretty_plural, sort_order, datatype, default_value,
     min_n_values, max_n_values, storage, static_p)
  values
    (v_attribute_id, p_object_type, 
     p_table_name, p_column_name, 
     p_attribute_name, p_pretty_name,
     p_pretty_plural, v_sort_order, 
     p_datatype, p_default_value,
     p_min_n_values, p_max_n_values, 
     p_storage, p_static_p);

  if p_create_column_p then

    select table_name into v_table_name from acs_object_types
    where object_type = p_object_type;

    if not exists (select 1
                   from pg_class
                   where relname = lower(v_table_name)) then
      raise exception 'Table % for object type % does not exist', v_table_name, p_object_type;
    end if;

    -- Add the appropriate column to the table

    -- We can only create the table column if
    -- 1. the attribute is declared type_specific (generic storage uses an auxillary table)
    -- 2. the attribute is not declared static
    -- 3. it does not already exist in the table

    if p_storage <> 'type_specific' then
      raise exception 'Attribute % for object type % must be declared with type_specific storage',
        p_attribute_name, p_object_type;
    end if;

    if p_static_p then
      raise exception 'Attribute % for object type % can not be declared static',
        p_attribute_name, p_object_type;
    end if;

    if p_table_name is not null then
      raise exception 'Attribute % for object type % can not specify a table for storage', p_attribute_name, p_object_type;
    end if;

    if exists (select 1
               from pg_class c, pg_attribute a
               where c.relname::varchar = v_table_name
                 and c.oid = a.attrelid
                 and a.attname = lower(p_attribute_name)) then
      raise exception 'Column % for object type % already exists',
        p_attribute_name, p_object_type;
    end if;

    -- all conditions for creating this column have been met, now let's see if the type
    -- spec is OK

    if p_column_spec is not null then
      if p_database_type is not null
        or p_size is not null
        or p_null_p is not null
        or p_references is not null
        or p_check_expr is not null then
      raise exception 'Attribute % for object type % is being created with an explicit column_spec, but not all of the type modification fields are null',
        p_attribute_name, p_object_type;
      end if;
      v_column_spec := p_column_spec;
    else
      select coalesce(p_database_type, database_type) as database_type,
        coalesce(p_size, column_size) as column_size,
        coalesce(p_check_expr, column_check_expr) as check_expr
      into v_datatype
      from acs_datatypes
      where datatype = p_datatype;
  
      v_column_spec := v_datatype.database_type;

      if v_datatype.column_size is not null then
        v_column_spec := v_column_spec || '(' || v_datatype.column_size || ')';
      end if;

      v_constraint_stub := ' constraint ' || p_object_type || '_' ||
        p_attribute_name || '_';

      if v_datatype.check_expr is not null then
        v_column_spec := v_column_spec || v_constraint_stub || 'ck check(' ||
          p_attribute_name || v_datatype.check_expr || ')';
      end if;

      if not p_null_p then
        v_column_spec := v_column_spec || v_constraint_stub || 'nn not null';
      end if;

      if p_references is not null then
        v_column_spec := v_column_spec || v_constraint_stub || 'fk references ' ||
          p_references || ' on delete';
        if p_null_p then
          v_column_spec := v_column_spec || ' set null';
        else
          v_column_spec := v_column_spec || ' cascade';
        end if;
      end if;

    end if;
        
    execute 'alter table ' || v_table_name || ' add ' || p_attribute_name || ' ' ||
            v_column_spec;

  end if;

  return v_attribute_id;

END;
$$;


ALTER FUNCTION public.acs_attribute__create_attribute(p_object_type character varying, p_attribute_name character varying, p_datatype character varying, p_pretty_name character varying, p_pretty_plural character varying, p_table_name character varying, p_column_name character varying, p_default_value character varying, p_min_n_values integer, p_max_n_values integer, p_sort_order integer, p_storage character varying, p_static_p boolean, p_create_column_p boolean, p_database_type character varying, p_size character varying, p_null_p boolean, p_references character varying, p_check_expr character varying, p_column_spec character varying) OWNER TO evex;

--
-- Name: acs_attribute__drop_attribute(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_attribute__drop_attribute(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
  return acs_attribute__drop_attribute($1, $2, 'f');
END;
$_$;


ALTER FUNCTION public.acs_attribute__drop_attribute(character varying, character varying) OWNER TO evex;

--
-- Name: acs_attribute__drop_attribute(character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_attribute__drop_attribute(p_object_type character varying, p_attribute_name character varying, p_drop_column_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_table_name             acs_object_types.table_name%TYPE;
BEGIN

  -- Check that attribute exists and simultaneously grab the type's table name
  select t.table_name into v_table_name
  from acs_object_types t, acs_attributes a
  where a.object_type = p_object_type
    and a.attribute_name = p_attribute_name
    and t.object_type = p_object_type;
    
  if not found then
    raise exception 'Attribute %:% does not exist', p_object_type, p_attribute_name;
  end if;

  -- first remove possible values for the enumeration
  delete from acs_enum_values
  where attribute_id in (select a.attribute_id 
                         from acs_attributes a 
                         where a.object_type = p_object_type
                         and a.attribute_name = p_attribute_name);

  -- Drop the table if one were specified for the type and we're asked to
  if p_drop_column_p and v_table_name is not null then
      execute 'alter table ' || v_table_name || ' drop column ' ||
        p_attribute_name || ' cascade';
  end if;  

  -- Finally, get rid of the attribute
  delete from acs_attributes
  where object_type = p_object_type
  and attribute_name = p_attribute_name;

  return 0; 
END;
$$;


ALTER FUNCTION public.acs_attribute__drop_attribute(p_object_type character varying, p_attribute_name character varying, p_drop_column_p boolean) OWNER TO evex;

--
-- Name: acs_attribute__drop_description(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_attribute__drop_description(drop_description__object_type character varying, drop_description__attribute_name character varying, drop_description__description_key character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from acs_attribute_descriptions
    where object_type = drop_description__object_type
    and attribute_name = drop_description__attribute_name
    and description_key = drop_description__description_key;

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_attribute__drop_description(drop_description__object_type character varying, drop_description__attribute_name character varying, drop_description__description_key character varying) OWNER TO evex;

--
-- Name: acs_datatype__date_output_function(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_datatype__date_output_function(p_attribute_name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  return 'to_char(' || p_attribute_name || ', ''YYYY-MM-DD'')';
END;
$$;


ALTER FUNCTION public.acs_datatype__date_output_function(p_attribute_name text) OWNER TO evex;

--
-- Name: acs_datatype__timestamp_output_function(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_datatype__timestamp_output_function(p_attribute_name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  return 'to_char(' || p_attribute_name || ', ''YYYY-MM-DD HH24:MI:SS'')';
END;
$$;


ALTER FUNCTION public.acs_datatype__timestamp_output_function(p_attribute_name text) OWNER TO evex;

--
-- Name: acs_event__activity_set(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__activity_set(activity_set__event_id integer, activity_set__activity_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        update acs_events
        set    activity_id = activity_set__activity_id
        where  event_id    = activity_set__event_id;

	return 0;

END;
$$;


ALTER FUNCTION public.acs_event__activity_set(activity_set__event_id integer, activity_set__activity_id integer) OWNER TO evex;

--
-- Name: acs_event__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__delete(delete__event_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_recurrence_id		acs_events.recurrence_id%TYPE;
BEGIN
       select recurrence_id into v_recurrence_id
       from   acs_events
       where  event_id = delete__event_id;

       -- acs_events and acs_event_party_map deleted via on delete cascade
       PERFORM acs_object__delete(delete__event_id); 

       -- Check for no more instances and delete recurrence if exists
       if not acs_event__instances_exist_p(v_recurrence_id) then 
            PERFORM recurrence__delete(v_recurrence_id);
       end if;

       return 0;

END;
$$;


ALTER FUNCTION public.acs_event__delete(delete__event_id integer) OWNER TO evex;

--
-- Name: acs_event__delete_all(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__delete_all(delete_all__event_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_recurrence_id		acs_events.recurrence_id%TYPE;
BEGIN

       select recurrence_id into v_recurrence_id
       from   acs_events
       where  event_id = delete_all__event_id;

       PERFORM acs_event__delete_all_recurrences(v_recurrence_id);

       return 0;

END;
$$;


ALTER FUNCTION public.acs_event__delete_all(delete_all__event_id integer) OWNER TO evex;

--
-- Name: acs_event__delete_all_recurrences(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__delete_all_recurrences(delete_all_recurrences__recurrence_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       rec_event				record;
BEGIN
       if delete_all_recurrences__recurrence_id is not null then
            for rec_event in 
	      select event_id 
	      from acs_events 
	      where  recurrence_id = delete_all_recurrences__recurrence_id
	    loop
                PERFORM acs_event__delete(rec_event.event_id);
            end loop;
       end if;

       return 0;

END;
$$;


ALTER FUNCTION public.acs_event__delete_all_recurrences(delete_all_recurrences__recurrence_id integer) OWNER TO evex;

--
-- Name: acs_event__get_description(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__get_description(get_description__event_id integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_description		    acs_events.description%TYPE; 
BEGIN

       select coalesce(e.description, a.description) into v_description
       from   acs_events e
       left join acs_activities a
       on  (e.activity_id = a.activity_id)
       where  e.event_id = get_description__event_id;

       return v_description;

END;
$$;


ALTER FUNCTION public.acs_event__get_description(get_description__event_id integer) OWNER TO evex;

--
-- Name: acs_event__get_html_p(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__get_html_p(get_html_p__event_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_html_p		acs_events.html_p%TYPE; 
BEGIN
       select coalesce(e.html_p, a.html_p) into v_html_p
       from  acs_events e
       left join acs_activities a
       on (e.activity_id = a.activity_id)
       where e.event_id = get_html_p__event_id;

       return v_html_p;

END;
$$;


ALTER FUNCTION public.acs_event__get_html_p(get_html_p__event_id integer) OWNER TO evex;

--
-- Name: acs_event__get_name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__get_name(get_name__event_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE    
       v_name acs_events.name%TYPE; 
BEGIN

       select coalesce(e.name, a.name) into v_name
       from   acs_events e 
       left join acs_activities a
       on (e.activity_id = a.activity_id)
       where e.event_id = get_name__event_id;

       return v_name;

END;
$$;


ALTER FUNCTION public.acs_event__get_name(get_name__event_id integer) OWNER TO evex;

--
-- Name: acs_event__get_status_summary(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__get_status_summary(get_status_summary__event_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_status_summary		acs_events.status_summary%TYPE; 
BEGIN
       select coalesce(e.status_summary, a.status_summary) into v_status_summary
       from  acs_events e
       left join acs_activities a
       on (e.activity_id = a.activity_id)
       where e.event_id = get_status_summary__event_id;

       return v_status_summary;

END;
$$;


ALTER FUNCTION public.acs_event__get_status_summary(get_status_summary__event_id integer) OWNER TO evex;

--
-- Name: acs_event__get_value(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__get_value(get_value__parameter_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_package_id			apm_packages.package_id%TYPE;
BEGIN
       select package_id into v_package_id
       from   apm_packages
       where  package_key = 'acs-events';

       return apm__get_value(v_package_id, get_value__parameter_name);
END;
$$;


ALTER FUNCTION public.acs_event__get_value(get_value__parameter_name character varying) OWNER TO evex;

--
-- Name: acs_event__insert_instances(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__insert_instances(insert_instances__event_id integer, insert_instances__cutoff_date timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       event_row		       acs_events%ROWTYPE;
       recurrence_row		       recurrences%ROWTYPE;
       v_event_id		       acs_events.event_id%TYPE;
       v_interval_name		       recurrence_interval_types.interval_name%TYPE;
       v_n_intervals		       recurrences.every_nth_interval%TYPE;
       v_days_of_week		       recurrences.days_of_week%TYPE;
       v_last_date_done		       timestamptz;
       v_stop_date		       timestamptz;
       v_start_date		       timestamptz;
       v_event_date		       timestamptz;
       v_diff			       integer;
       v_current_date		       timestamptz;
       v_last_day		       timestamptz;
       v_week_date		       timestamptz;
       v_instance_count		       integer;
       v_days_length		       integer;
       v_days_index		       integer;
       v_day_num		       integer;
       rec_execute		       record;
       v_new_current_date              timestamptz;
       v_offset_notice interval;
BEGIN
	-- Get event parameters
        select * into event_row
        from   acs_events
        where  event_id = insert_instances__event_id;

	-- Get recurrence information
        select * into recurrence_row
        from   recurrences
        where  recurrence_id = event_row.recurrence_id;
        

        -- Set cutoff date to stop populating the DB with recurrences
        -- EventFutureLimit is in years. (a parameter of the service)
        if insert_instances__cutoff_date is null then
           v_stop_date := add_months(now(), 12 * to_number(acs_event__get_value('EventFutureLimit'),'99999')::INT);
        else
           v_stop_date := insert_instances__cutoff_date;
        end if;
        
        -- Events only populated until max(cutoff_date, recur_until)
        -- If recur_until null, then defaults to cutoff_date
        if recurrence_row.recur_until < v_stop_date then
           v_stop_date := recurrence_row.recur_until;
        end if;
        
        -- Figure out the date to start from.
	-- JS: I do not understand why the date must be truncated to the midnight of the event date
        select min(start_date)
        into   v_event_date
        from   acs_events_dates
        where  event_id = insert_instances__event_id;

        if recurrence_row.db_populated_until is null then
           v_start_date := v_event_date;
        else
           v_start_date := recurrence_row.db_populated_until;
        end if;
        
        v_current_date   := v_start_date;
        v_last_date_done := v_start_date;
        v_n_intervals    := recurrence_row.every_nth_interval;
        
        -- Case off of the interval_name to make code easier to read
        select interval_name into v_interval_name
        from   recurrences r, 
               recurrence_interval_types t
        where  recurrence_id   = recurrence_row.recurrence_id
        and    r.interval_type = t.interval_type;
        
        -- Week has to be handled specially.
        -- Start with the beginning of the week containing the start date.
        if v_interval_name = 'week' 
	then
            v_current_date := next_day(v_current_date - to_interval(7,'days'),'SUNDAY');
            v_days_of_week := recurrence_row.days_of_week;
            v_days_length  := char_length(v_days_of_week);
        end if;
        
        -- Check count to prevent runaway in case of error
        v_instance_count := 0;

	-- A feature: we only care about the date when populating the database for reccurrence.
        while v_instance_count < 10000 and (date_trunc('day',v_last_date_done) <= date_trunc('day',v_stop_date))
        loop
            v_instance_count := v_instance_count + 1;
        
            -- Calculate next date based on interval type

	    -- Add next day, skipping every v_n_intervals
	    if v_interval_name = 'day' 
	    then
                v_current_date := v_current_date + to_interval(v_n_intervals,'days');
	    end if;
        
	    -- Add a full month, skipping by v_n_intervals months
            if v_interval_name = 'month_by_date' 
	    then
                v_current_date := add_months(v_current_date, v_n_intervals);
	    end if;

	    -- Add days so that the next date will have the same day of the week,  and week of the month
            if v_interval_name = 'month_by_day' then
                -- Find last day of month before correct month
                v_last_day := add_months(last_day(v_current_date), v_n_intervals - 1);
                -- Find correct week and go to correct day of week
                v_current_date := next_day(v_last_day + 
				              to_interval(7 * (to_number(to_char(v_current_date,'W'),'99')::INT - 1),
							  'days'),
                                            to_char(v_current_date, 'DAY'));
	    end if;

	    -- Add days so that the next date will have the same day of the week on the last week of the month
            if v_interval_name = 'last_of_month' then
                -- Find last day of correct month
                v_last_day := last_day(add_months(v_current_date, v_n_intervals));
                -- Back up one week and find correct day of week
                v_current_date := next_day(v_last_day ::timestamp - to_interval(7,'days') :: timestamptz, to_char(v_current_date, 'DAY'));
	    end if;

	    -- Add a full year (12 months)
            If v_interval_name = 'year' then
                v_current_date := add_months(v_current_date, 12 * v_n_intervals);
	    end if;

            -- Deal with custom function
            if v_interval_name = 'custom' then

	        -- JS: Execute a dynamically created query on the fly...
	        FOR rec_execute IN
		EXECUTE 'select ' || recurrence_row.custom_func 
				    || '(' || quote_literal(v_current_date)
				    || ',' || v_n_intervals || ') as current_date'
		LOOP
		     v_current_date := rec_execute.current_date;
		END LOOP;

            end if;
        
            -- Check to make sure we are not going past Trunc because dates are not integral
            exit when date_trunc('day',v_current_date) > date_trunc('day',v_stop_date);
        
            -- Have to handle week specially
            if v_interval_name = 'week' then
                -- loop over days_of_week extracting each day number
                -- add day number and insert
                v_days_index := 1;
                v_week_date  := v_current_date;
                while v_days_index <= v_days_length loop
                    v_day_num   := SUBSTR(v_days_of_week, v_days_index, 1);
                    v_week_date := (v_current_date ::timestamp + to_interval(v_day_num,'days')) :: timestamptz;
	           if date_trunc('day',v_week_date) > date_trunc('day',v_start_date) 
		       and date_trunc('day',v_week_date) <= date_trunc('day',v_stop_date) then
                         -- This is where we add the event
                         v_event_id := acs_event__new_instance(
                              insert_instances__event_id,					   -- event_id
                              date_trunc('day',v_week_date :: timestamp) - date_trunc('day',v_event_date :: timestamp)    -- offset
                         );
                         v_last_date_done := v_week_date;

                     else if date_trunc('day',v_week_date) > date_trunc('day',v_stop_date) 
		          then
                             -- Gone too far
                             exit;
			  end if;

                     end if;

                     v_days_index := v_days_index + 2;

                 end loop;

                 -- Now move to next week with repeats.
                v_current_date := (v_current_date :: timestamp + to_interval(7 * v_n_intervals,'days')) :: timestamptz;
            else
                -- All other interval types
                -- This is where we add the event
                v_event_id := acs_event__new_instance(
                    insert_instances__event_id,						    -- event_id 
                    date_trunc('day',v_current_date ::timestamp) - date_trunc('day',v_event_date ::timestamp)   -- offset
                );
                v_last_date_done := v_current_date;
            end if;
        end loop;
        
        update recurrences
        set    db_populated_until = v_last_date_done
        where  recurrence_id      = recurrence_row.recurrence_id;

	return 0;
END;
$$;


ALTER FUNCTION public.acs_event__insert_instances(insert_instances__event_id integer, insert_instances__cutoff_date timestamp with time zone) OWNER TO evex;

--
-- Name: acs_event__instances_exist_p(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__instances_exist_p(instances_exist_p__recurrence_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	
DECLARE
        v_result				integer;
BEGIN
        -- Only need to check if any rows exist.
        select count(*) into v_result
        from   dual 
        where exists (select recurrence_id
                      from   acs_events
                      where  recurrence_id = instances_exist_p__recurrence_id);

        if v_result = 0 then
            return false;
        else
            return true;
        end if;

END;
$$;


ALTER FUNCTION public.acs_event__instances_exist_p(instances_exist_p__recurrence_id integer) OWNER TO evex;

--
-- Name: acs_event__new(integer, character varying, text, boolean, text, integer, integer, integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__new(integer, character varying, text, boolean, text, integer, integer, integer, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
       return acs_event__new($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,null);
END;
$_$;


ALTER FUNCTION public.acs_event__new(integer, character varying, text, boolean, text, integer, integer, integer, character varying, timestamp with time zone, integer, character varying, integer) OWNER TO evex;

--
-- Name: acs_event__new(integer, character varying, text, boolean, text, integer, integer, integer, character varying, timestamp with time zone, integer, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__new(new__event_id integer, new__name character varying, new__description text, new__html_p boolean, new__status_summary text, new__timespan_id integer, new__activity_id integer, new__recurrence_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	-- acs_events.event_id%TYPE
DECLARE
       v_event_id	    acs_events.event_id%TYPE;
BEGIN
       v_event_id := acs_object__new(
            new__event_id,	-- object_id
            new__object_type,	-- object_type
            new__creation_date, -- creation_date
            new__creation_user,	-- creation_user
            new__creation_ip,	-- creation_ip
            new__context_id,	-- context_id
            't',		-- security_inherit_p
            new__name,		-- title
            new__package_id	-- package_id
	    );

       insert into acs_events
            (event_id, name, description, html_p, status_summary, activity_id, timespan_id, recurrence_id)
       values
            (v_event_id, new__name, new__description, new__html_p, new__status_summary, new__activity_id, new__timespan_id,
             new__recurrence_id);

       return v_event_id;

END;
$$;


ALTER FUNCTION public.acs_event__new(new__event_id integer, new__name character varying, new__description text, new__html_p boolean, new__status_summary text, new__timespan_id integer, new__activity_id integer, new__recurrence_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__package_id integer) OWNER TO evex;

--
-- Name: acs_event__new_instance(integer, interval); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__new_instance(new_instance__event_id integer, new_instance__date_offset interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       event_row		  acs_events%ROWTYPE;
       object_row		  acs_objects%ROWTYPE;
       v_event_id		  acs_events.event_id%TYPE;
       v_timespan_id		  acs_events.timespan_id%TYPE;
BEGIN
       -- Get event parameters
       select * into event_row
       from   acs_events
       where  event_id = new_instance__event_id;

       -- Get object parameters                
       select * into object_row
       from   acs_objects
       where  object_id = new_instance__event_id;

       -- We allow non-zero offset, so we copy
       v_timespan_id := timespan__copy(event_row.timespan_id, new_instance__date_offset);

       -- Create a new instance
       v_event_id := acs_event__new(
	    null,                     -- event_id (default)
            event_row.name,           -- name
            event_row.description,    -- description
            event_row.html_p,         -- html_p
            event_row.status_summary, -- status_summary
            v_timespan_id,	      -- timespan_id
            event_row.activity_id,    -- activity_id`
            event_row.recurrence_id,  -- recurrence_id
	    'acs_event',	      -- object_type (default)
	    now(),		      -- creation_date (default)
            object_row.creation_user, -- creation_user
            object_row.creation_ip,   -- creation_ip
            object_row.context_id,     -- context_id
            object_row.package_id     -- context_id
	    );

      return v_event_id;
END;
$$;


ALTER FUNCTION public.acs_event__new_instance(new_instance__event_id integer, new_instance__date_offset interval) OWNER TO evex;

--
-- Name: acs_event__party_map(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__party_map(party_map__event_id integer, party_map__party_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       insert into acs_event_party_map
            (event_id, party_id)
       values
            (party_map__event_id, party_map__party_id);

       return 0;

END;
$$;


ALTER FUNCTION public.acs_event__party_map(party_map__event_id integer, party_map__party_id integer) OWNER TO evex;

--
-- Name: acs_event__party_unmap(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__party_unmap(party_unmap__event_id integer, party_unmap__party_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       delete from acs_event_party_map
       where  event_id = party_unmap__event_id
       and    party_id = party_unmap__party_id;

       return 0;

END;
$$;


ALTER FUNCTION public.acs_event__party_unmap(party_unmap__event_id integer, party_unmap__party_id integer) OWNER TO evex;

--
-- Name: acs_event__recurrence_timespan_edit(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__recurrence_timespan_edit(p_event_id integer, p_start_date timestamp with time zone, p_end_date timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    return acs_event__recurrence_timespan_edit (
           p_event_id,
           p_start_date,
           p_end_date,
           't');
END;
$$;


ALTER FUNCTION public.acs_event__recurrence_timespan_edit(p_event_id integer, p_start_date timestamp with time zone, p_end_date timestamp with time zone) OWNER TO evex;

--
-- Name: acs_event__recurrence_timespan_edit(integer, timestamp with time zone, timestamp with time zone, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__recurrence_timespan_edit(p_event_id integer, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_edit_past_events_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_timespan                   RECORD;
        v_one_start_date             timestamptz;
        v_one_end_date               timestamptz;
BEGIN
        -- get the initial offsets
        select start_date,
               end_date into v_one_start_date,
               v_one_end_date
        from time_intervals, 
             timespans, 
             acs_events 
        where time_intervals.interval_id = timespans.interval_id
          and timespans.timespan_id = acs_events.timespan_id
          and event_id=p_event_id;
raise notice 'v_one_start_date = %',v_one_start_date;
        FOR v_timespan in
            select *
            from time_intervals
            where interval_id in (select interval_id
                                  from timespans 
                                  where timespan_id in (select timespan_id
                                                        from acs_events 
                                                        where recurrence_id = (select recurrence_id 
                                                                               from acs_events where event_id = p_event_id)))
           and (p_edit_past_events_p = 't' or start_date >= v_one_start_date)
        LOOP
                PERFORM time_interval__edit(v_timespan.interval_id, 
                                            (to_char(v_timespan.start_date,'yyyy-mm-dd') || ' ' || to_char(p_start_date,'hh24:mi:ss')) :: timestamptz, 
                                            (to_char(v_timespan.end_date,'yyyy-mm-dd') || ' ' || to_char(p_end_date,'hh24:mi:ss')) :: timestamptz);
        END LOOP;

        return p_event_id;
END;
$$;


ALTER FUNCTION public.acs_event__recurrence_timespan_edit(p_event_id integer, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_edit_past_events_p boolean) OWNER TO evex;

--
-- Name: acs_event__recurs_p(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__recurs_p(recurs_p__event_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_result	      boolean;
BEGIN
       select (case when recurrence_id is null 
	             then false
                     else true 
                end) into v_result
       from   acs_events
       where  event_id = recurs_p__event_id;

       return v_result;

END;
$$;


ALTER FUNCTION public.acs_event__recurs_p(recurs_p__event_id integer) OWNER TO evex;

--
-- Name: acs_event__shift(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__shift(shift__event_id integer, shift__start_offset integer, shift__end_offset integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	
       return acs_event__shift (
	            shift__event_id,
	            to_interval(shift__start_offset,'days'),
	            to_interval(shift__end_offset,'days')
		    );
				    
END;
$$;


ALTER FUNCTION public.acs_event__shift(shift__event_id integer, shift__start_offset integer, shift__end_offset integer) OWNER TO evex;

--
-- Name: acs_event__shift(integer, interval, interval); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__shift(shift__event_id integer, shift__start_offset interval, shift__end_offset interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       rec_events	    record;
BEGIN

--       update acs_events_dates
--       set    start_date = start_date + shift__start_offset,
--             end_date   = end_date + shift__end_offset
--       where  event_id   = shift__event_id;

	  -- Can not update view, so we do it the hard way 
	  -- (as if we make the rule anyways)
	  for rec_events in
	      select t.*
	      from acs_events e, timespans s, time_intervals t
	      where e.event_id   = shift__event_id
	      and   e.timespan_id = s.timespan_id
	      and   s.interval_id = t.interval_id
          loop
	       update time_intervals
	       set    start_date = start_date + shift__start_offset,
		      end_date   = end_date + shift__end_offset
	       where  interval_id = rec_events.interval_id;
	  end loop;

       return 0;

END;
$$;


ALTER FUNCTION public.acs_event__shift(shift__event_id integer, shift__start_offset interval, shift__end_offset interval) OWNER TO evex;

--
-- Name: acs_event__shift_all(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__shift_all(shift_all__event_id integer, shift_all__start_offset integer, shift_all__end_offset integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	
       return acs_event__shift_all (
	            shift_all__event_id,
	            to_interval(shift_all__start_offset,'days'),
	            to_interval(shift_all__end_offset,'days')
		    );
				    
END;
$$;


ALTER FUNCTION public.acs_event__shift_all(shift_all__event_id integer, shift_all__start_offset integer, shift_all__end_offset integer) OWNER TO evex;

--
-- Name: acs_event__shift_all(integer, interval, interval); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__shift_all(shift_all__event_id integer, shift_all__start_offset interval, shift_all__end_offset interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	rec_events		   record;
BEGIN


--        update acs_events_dates
--        set    start_date    = start_date + shift_all__start_offset,
--              end_date      = end_date + shift_all__end_offset
--        where recurrence_id  = (select recurrence_id
--                                from   acs_events
--                                where  event_id = shift_all__event_id);

	-- Can not update views
	for rec_events in
	    select *
	    from acs_events_dates
	    where recurrence_id  = (select recurrence_id
				    from   acs_events
				    where  event_id = shift_all__event_id)
	loop
	
	    PERFORM acs_event__shift(
			rec_events.event_id,
			shift_all__start_offset,	       
			shift_all__end_offset
			);
	end loop;

	return 0;

END;
$$;


ALTER FUNCTION public.acs_event__shift_all(shift_all__event_id integer, shift_all__start_offset interval, shift_all__end_offset interval) OWNER TO evex;

--
-- Name: acs_event__timespan_set(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_event__timespan_set(timespan_set__event_id integer, timespan_set__timespan_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       update acs_events
       set    timespan_id = timespan_set__timespan_id
       where  event_id    = timespan_set__event_id;

       return 0;

END;
$$;


ALTER FUNCTION public.acs_event__timespan_set(timespan_set__event_id integer, timespan_set__timespan_id integer) OWNER TO evex;

--
-- Name: acs_group__check_representation(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_group__check_representation(group_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  res                    boolean; 
  comp                   record;
  memb                   record;      
BEGIN
   if group_id is null then 
        --maybe we should just return 'f' instead?
	raise exception 'acs_group__check_representation called with null group_id';
   end if;

   res := 't';
   PERFORM acs_log__notice('acs_group.check_representation',
                  'Running check_representation on group ' || group_id);

   if acs_object__check_representation(group_id) = 'f' then
     res := 'f';
   end if;

   for comp in select c.rel_id
             from acs_rels r, composition_rels c
             where r.rel_id = c.rel_id
             and r.object_id_one = group_id 
   LOOP
     if composition_rel__check_representation(comp.rel_id) = 'f' then
       res := 'f';
     end if;
   end loop;

   for memb in  select m.rel_id
             from acs_rels r, membership_rels m
             where r.rel_id = m.rel_id
             and r.object_id_one = group_id 
   LOOP
     if membership_rel__check_representation(memb.rel_id) = 'f' then
       res := 'f';
     end if;
   end loop;

   PERFORM acs_log__notice('acs_group.check_representation',
                  'Done running check_representation on group ' || group_id);

   return res;
  
END;
$$;


ALTER FUNCTION public.acs_group__check_representation(group_id integer) OWNER TO evex;

--
-- Name: acs_group__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_group__delete(delete__group_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  row                           record;
BEGIN
 
   -- Delete all the relations of any type to this group
   for row in select r.rel_id, t.package_name
                 from acs_rels r, acs_object_types t
                where r.rel_type = t.object_type
                  and (r.object_id_one = delete__group_id
                       or r.object_id_two = delete__group_id) 
   LOOP
      execute 'select ' ||  row.package_name || '__delete(' || row.rel_id || ')';
   end loop;
 
   -- Delete all segments defined for this group
   for row in  select segment_id 
                 from rel_segments 
                where group_id = delete__group_id 
   LOOP
       PERFORM rel_segment__delete(row.segment_id);
   end loop;

   PERFORM party__delete(delete__group_id);

   return 0; 
END;
$$;


ALTER FUNCTION public.acs_group__delete(delete__group_id integer) OWNER TO evex;

--
-- Name: acs_group__member_p(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_group__member_p(p_party_id integer, p_group_id integer, p_cascade_membership boolean) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN
  if p_cascade_membership then
    --
    -- Direct and indirect memberships
    --
    return count(*) > 0
      from group_member_map
      where group_id = p_group_id
        and member_id = p_party_id;
  else
    --
    -- Only direct memberships
    --
    return count(*) > 0
      from acs_rels rels
    where rels.rel_type = 'membership_rel'
      and rels.object_id_one = p_group_id
      and rels.object_id_two = p_party_id
      and acs_permission.permission_p(rels.rel_id, p_party_id, 'read');
  end if;
END;
$$;


ALTER FUNCTION public.acs_group__member_p(p_party_id integer, p_group_id integer, p_cascade_membership boolean) OWNER TO evex;

--
-- Name: acs_group__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_group__name(name__group_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  name__group_name       varchar(200);  
BEGIN
  select group_name
  into name__group_name
  from groups
  where group_id = name__group_id;

  return name__group_name;
  
END;
$$;


ALTER FUNCTION public.acs_group__name(name__group_id integer) OWNER TO evex;

--
-- Name: acs_group__new(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_group__new(gname character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_group__new/1 maybe obsolete, when we define proper defaults for /10
--
DECLARE
BEGIN
        return acs_group__new(null,
                              'group',
                              now(),
                              null,
                              null,
                              null,
                              null,
                              gname,
                              null,
                              null);
END;
$$;


ALTER FUNCTION public.acs_group__new(gname character varying) OWNER TO evex;

--
-- Name: acs_group__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_group__new(new__group_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__email character varying, new__url character varying, new__group_name character varying, new__join_policy character varying, new__context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_group_id                 groups.group_id%TYPE;
  v_group_type_exists_p      integer;
  v_join_policy              groups.join_policy%TYPE;
BEGIN
  v_group_id :=
   party__new(new__group_id, new__object_type, new__creation_date, 
              new__creation_user, new__creation_ip, new__email, 
              new__url, new__context_id);

  v_join_policy := new__join_policy;

  -- if join policy was not specified, select the default based on group type
  if v_join_policy is null or v_join_policy = '' then
      select count(*) into v_group_type_exists_p
      from group_types
      where group_type = new__object_type;

      if v_group_type_exists_p = 1 then
          select default_join_policy into v_join_policy
          from group_types
          where group_type = new__object_type;
      else
          v_join_policy := 'open';
      end if;
  end if;

  update acs_objects
  set title = new__group_name
  where object_id = v_group_id;

  insert into groups
   (group_id, group_name, join_policy)
  values
   (v_group_id, new__group_name, v_join_policy);

  -- setup the permissible relationship types for this group

  -- DRB: we have to call nextval() directly because the select may
  -- return more than one row.  The sequence hack will only compute
  -- one nextval value causing the insert to fail ("may" in PG, which
  -- is actually broken.  It should ALWAYS return exactly one value for
  -- the view.  In PG it may or may not depending on the optimizer's
  -- mood.  PG group seems uninterested in acknowledging the fact that
  -- this is a bug)

  insert into group_rels
  (group_rel_id, group_id, rel_type)
  select nextval('t_acs_object_id_seq'), v_group_id, rels.rel_type
    from
    ( select distinct g.rel_type
      from group_type_rels g,
      ( select parent.object_type as parent_type
        from acs_object_types child, acs_object_types parent
        where child.object_type <> parent.object_type
        and child.tree_sortkey between parent.tree_sortkey
        and tree_right(parent.tree_sortkey)
        and child.object_type = new__object_type
        order by parent.tree_sortkey desc) types
     where g.group_type = types.parent_type
     and not exists
     ( select 1 from group_rels
       where group_rels.group_id = v_group_id
       and group_rels.rel_type = g.rel_type)
  ) rels;
  
  return v_group_id;
  
END;
$$;


ALTER FUNCTION public.acs_group__new(new__group_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__email character varying, new__url character varying, new__group_name character varying, new__join_policy character varying, new__context_id integer) OWNER TO evex;

--
-- Name: acs_lang_get_locale_for_user(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_lang_get_locale_for_user(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	p_user_id	alias for $1;

	v_acs_lang_package_id	integer;
	v_locale		varchar(10);
begin
	-- Get the users local from preferences
	select	locale into v_locale
	from	user_preferences
	where	user_id = p_user_id;

	-- Get users locale from global default
	IF v_locale is null THEN
		select	package_id
		into	v_acs_lang_package_id
		from	apm_packages
		where	package_key = 'acs-lang';

		v_locale := apm__get_value (v_acs_lang_package_id, 'SiteWideLocale');
	END IF;

	-- Partial locale - lookup complete one
	IF length(v_locale) = 2 THEN
		select	locale into v_locale
		from	ad_locales
		where	language = v_locale
			and enabled_p = 't'
			and (default_p = 't'
			   or (select count(*) from ad_locales where language = v_locale) = 1
			);
	END IF;

	-- Default: English
	IF v_locale is null THEN
		v_locale := 'en_US';
	END IF;

	return v_locale;
end;$_$;


ALTER FUNCTION public.acs_lang_get_locale_for_user(integer) OWNER TO evex;

--
-- Name: acs_lang_lookup_message(text, text, text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_lang_lookup_message(text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	p_locale		alias for $1;
	p_package_key		alias for $2;
	p_message_key		alias for $3;
	v_message		text;
	v_locale		text;
	v_acs_lang_package_id	integer;
begin
	-- --------------------------------------------
	-- Check full locale
	select	message into v_message
	from	lang_messages
	where	(message_key = p_message_key OR message_key = replace(p_message_key, ' ', '_'))
		and package_key = p_package_key
		and locale = p_locale
	LIMIT 1;
	IF v_message is not null THEN return v_message; END IF;

	-- --------------------------------------------
	-- Partial locale - lookup complete one
	v_locale := substring(p_locale from 1 for 2);

	select	locale into v_locale
	from	ad_locales
	where	language = v_locale
		and enabled_p = 't'
		and (default_p = 't' or
		(select count(*) from ad_locales where language = v_locale) = 1);

	select	message into v_message
	from	lang_messages
	where	(message_key = p_message_key OR message_key = replace(p_message_key, ' ', '_'))
		and package_key = p_package_key
		and locale = v_locale
	LIMIT 1;
	IF v_message is not null THEN return v_message; END IF;

	-- --------------------------------------------
	-- Try System Locale
	select	package_id into	v_acs_lang_package_id
	from	apm_packages
	where	package_key = 'acs-lang';
	v_locale := apm__get_value (v_acs_lang_package_id, 'SiteWideLocale');

	select	message into v_message
	from	lang_messages
	where	(message_key = p_message_key OR message_key = replace(p_message_key, ' ', '_'))
		and package_key = p_package_key
		and locale = v_locale
	LIMIT 1;
	IF v_message is not null THEN return v_message; END IF;

	-- --------------------------------------------
	-- Try with English...
	v_locale := 'en_US';
	select	message into v_message
	from	lang_messages
	where	(message_key = p_message_key OR message_key = replace(p_message_key, ' ', '_'))
		and package_key = p_package_key
		and locale = v_locale
	LIMIT 1;
	IF v_message is not null THEN return v_message; END IF;

	-- --------------------------------------------
	-- Nothing found...
	v_message := 'MISSING ' || p_locale || ' TRANSLATION for ' || p_package_key || '.' || p_message_key;
	return v_message;	

end;$_$;


ALTER FUNCTION public.acs_lang_lookup_message(text, text, text) OWNER TO evex;

--
-- Name: acs_log__debug(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_log__debug(debug__log_key character varying, debug__message character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_logs
     (log_id, log_level, log_key, message)
    values
     (nextval('t_acs_log_id_seq'), 'debug', debug__log_key, debug__message);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_log__debug(debug__log_key character varying, debug__message character varying) OWNER TO evex;

--
-- Name: acs_log__error(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_log__error(error__log_key character varying, error__message character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_logs
     (log_id, log_level, log_key, message)
    values
     (nextval('t_acs_log_id_seq'), 'error', error__log_key, error__message);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_log__error(error__log_key character varying, error__message character varying) OWNER TO evex;

--
-- Name: acs_log__notice(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_log__notice(notice__log_key character varying, notice__message character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_logs
     (log_id, log_level, log_key, message)
    values
     (nextval('t_acs_log_id_seq'), 'notice', notice__log_key, notice__message);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_log__notice(notice__log_key character varying, notice__message character varying) OWNER TO evex;

--
-- Name: acs_log__warn(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_log__warn(warn__log_key character varying, warn__message character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_logs
     (log_id, log_level, log_key, message)
    values
     (nextval('t_acs_log_id_seq'), 'warn', warn__log_key, warn__message);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_log__warn(warn__log_key character varying, warn__message character varying) OWNER TO evex;

--
-- Name: acs_message__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__delete(p_message_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from acs_messages where message_id = p_message_id;
    perform content_item__delete(p_message_id);
    return 1;
END;
$$;


ALTER FUNCTION public.acs_message__delete(p_message_id integer) OWNER TO evex;

--
-- Name: acs_message__delete_extlink(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__delete_extlink(p_extlink_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    perform content_extlink__delete(p_extlink_id);

	return 0;
END;
$$;


ALTER FUNCTION public.acs_message__delete_extlink(p_extlink_id integer) OWNER TO evex;

--
-- Name: acs_message__delete_file(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__delete_file(p_file_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    perform content_item__delete(p_file_id);       
    return 1;
END;
$$;


ALTER FUNCTION public.acs_message__delete_file(p_file_id integer) OWNER TO evex;

--
-- Name: acs_message__delete_image(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__delete_image(p_image_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    perform image__delete(p_image_id);

    return 0;
END;
$$;


ALTER FUNCTION public.acs_message__delete_image(p_image_id integer) OWNER TO evex;

--
-- Name: acs_message__edit(integer, character varying, character varying, character varying, text, integer, timestamp with time zone, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__edit(p_message_id integer, p_title character varying, p_description character varying, p_mime_type character varying, p_text text, p_data integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_revision_id cr_revisions.revision_id%TYPE;
BEGIN
    -- create a new revision using whichever call is appropriate
    if p_data is not null then
		-- need to take care of blob?
        v_revision_id := content_revision__new (
            p_message_id,		-- item_id        
            p_title,			-- title          
            p_description,		-- description    
            p_data,			-- data           
            p_mime_type,		-- mime_type      
            p_creation_date,		-- creation_date  
            p_creation_user,		-- creation_user  
            p_creation_ip		-- creation_ip    
        );
    else if p_title is not null or p_text is not null then
        v_revision_id := content_revision__new (
            p_title,			-- title          
            p_description,		-- description    
			now(),		-- publish_date
            p_mime_type,		-- mime_type      
			null,		-- nls_language
            p_text,			-- text           
            p_message_id,		-- item_id        
			null,		-- revision_id
            p_creation_date,		-- creation_date  
            p_creation_user,		-- creation_user  
            p_creation_ip		-- creation_ip    
        );      
    end if;
	end if;

    -- test for auto approval of revision   
    if p_is_live then 
        perform content_item__set_live_revision(v_revision_id);
    end if;

    return v_revision_id;
END;
$$;


ALTER FUNCTION public.acs_message__edit(p_message_id integer, p_title character varying, p_description character varying, p_mime_type character varying, p_text text, p_data integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean) OWNER TO evex;

--
-- Name: acs_message__edit_extlink(integer, character varying, character varying, text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__edit_extlink(p_extlink_id integer, p_url character varying, p_label character varying, p_description text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_is_extlink   boolean;
BEGIN
    v_is_extlink := content_extlink__is_extlink(p_extlink_id);
    if v_is_extlink = 't' then
        update cr_extlinks
        set url = p_url,
            label = p_label,
            description = p_description
        where extlink_id = p_extlink_id;
    end if;
    return 0;
END;
$$;


ALTER FUNCTION public.acs_message__edit_extlink(p_extlink_id integer, p_url character varying, p_label character varying, p_description text) OWNER TO evex;

--
-- Name: acs_message__edit_file(integer, character varying, text, character varying, integer, timestamp with time zone, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__edit_file(p_file_id integer, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_revision_id  cr_revisions.revision_id%TYPE;
BEGIN
    v_revision_id := content_revision__new (
        p_title,			-- title         
        p_description,
        current_timestamp,
        p_mime_type,			-- mime_type     
        NULL,
        p_data,				-- data          
        p_file_id,			-- item_id       
        NULL,
        p_creation_date,		-- creation_date 
        p_creation_user,		-- creation_user 
        p_creation_ip			-- creation_ip   
    );

    -- test for auto approval of revision
    if p_is_live then 
        perform content_item__set_live_revision(v_revision_id);
    end if;

    return v_revision_id;
END;
$$;


ALTER FUNCTION public.acs_message__edit_file(p_file_id integer, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean) OWNER TO evex;

--
-- Name: acs_message__edit_image(integer, character varying, text, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__edit_image(p_image_id integer, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_width integer, p_height integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_revision_id  cr_revisions.revision_id%TYPE;
BEGIN
		-- not sure which __new to use
    v_revision_id := content_revision__new (
         p_title,             -- title         
         NULL,                -- description
         current_timestamp,   -- publish_date
         p_mime_type,         -- mime_type     
         NULL,                -- nls_language
         p_data,              -- data          
         p_image_id,          -- item_id       
         NULL,                -- revision_id
         p_creation_date,     -- creation_date 
         p_creation_user,     -- creation_user 
         p_creation_ip        -- creation_ip   
    );      

    -- insert new width and height values
    -- XXX fix after image.new exists
    insert into images
        (image_id, width, height)
    values
        (v_revision_id, p_width, p_height);

    -- test for auto approval of revision   
    if p_is_live then 
        perform content_item__set_live_revision(v_revision_id);
    end if;

    return v_revision_id;
END;
$$;


ALTER FUNCTION public.acs_message__edit_image(p_image_id integer, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_width integer, p_height integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean) OWNER TO evex;

--
-- Name: acs_message__first_ancestor(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__first_ancestor(p_message_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_message_id acs_messages.message_id%TYPE;
    v_ancestor_sk varbit;
BEGIN
    select tree_ancestor_key(tree_sortkey, 1) into v_ancestor_sk
      from acs_messages
     where message_id = p_message_id;

    select message_id into v_message_id
      from acs_messages
     where tree_sortkey = v_ancestor_sk;

    return v_message_id;
END;
$$;


ALTER FUNCTION public.acs_message__first_ancestor(p_message_id integer) OWNER TO evex;

--
-- Name: acs_message__message_p(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__message_p(p_message_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_check_message_id  integer;
BEGIN
    select count(message_id) into v_check_message_id
        from acs_messages where message_id = p_message_id;

    if v_check_message_id <> 0 then
        return 't';
    else
        return 'f';
    end if;
END;
$$;


ALTER FUNCTION public.acs_message__message_p(p_message_id integer) OWNER TO evex;

--
-- Name: acs_message__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__name(p_message_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_message_name   cr_revisions.title%TYPE;
BEGIN
    select title into v_message_name
        from acs_messages_all
        where message_id = p_message_id;
    return v_message_name;
END;
$$;


ALTER FUNCTION public.acs_message__name(p_message_id integer) OWNER TO evex;

--
-- Name: acs_message__new(integer, integer, timestamp with time zone, integer, character varying, character varying, character varying, character varying, text, integer, integer, integer, integer, character varying, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__new(p_message_id integer, p_reply_to integer, p_sent_date timestamp with time zone, p_sender integer, p_rfc822_id character varying, p_title character varying, p_description character varying, p_mime_type character varying, p_text text, p_data integer, p_parent_id integer, p_context_id integer, p_creation_user integer, p_creation_ip character varying, p_object_type character varying, p_is_live boolean, p_package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_creation_date timestamptz := current_timestamp;  -- alias for $13 --default sysdate,
        v_message_id   acs_messages.message_id%TYPE;
        v_rfc822_id    acs_messages.rfc822_id%TYPE;
        v_revision_id  cr_revisions.revision_id%TYPE;
		v_system_url   varchar;
		v_domain_name  varchar;
		v_idx		   integer;
    BEGIN
        -- generate a message id now so we can get an rfc822 message-id
        if p_message_id is null then
            select nextval('t_acs_object_id_seq') into v_message_id;
        else
            v_message_id := p_message_id;
        end if;

        -- need to make this mandatory also - jg
        -- this needs to be fixed up, but Oracle doesn't give us a way
        -- to get the FQDN

	-- vk: get SystemURL parameter and use it to extract domain name
         select apm__get_value(package_id, 'SystemURL') into v_system_url
          from apm_packages where package_key='acs-kernel';
		v_idx := position('http://' in v_system_url);
		v_domain_name := trim (substr(v_system_url, v_idx + 7));

        if p_rfc822_id is null then
           v_rfc822_id := current_date || '.' || v_message_id || '@' ||
               v_domain_name || '.hate';
        else
            v_rfc822_id := p_rfc822_id;
        end if;

        v_message_id := content_item__new (
            v_rfc822_id,			  -- 1   name           
            p_parent_id,			  -- 2   parent_id      
            p_message_id,			  -- 3   item_id        
            null,				  -- 4   locale
            p_creation_date,			  -- 5   creation_date  
            p_creation_user,			  -- 6   creation_user  
            p_context_id,			  -- 7   context_id     
            p_creation_ip,			  -- 8   creation_ip    
            p_object_type,			  -- 9   item_subtype   
            'acs_message_revision',		  -- 10  content_type   
            null,				  -- 11  title
            null,				  -- 12  description
            'text/plain',			  -- 13  mime_type
            null,				  -- 14  nls_language
            null,				  -- 15  text
            'text',				  -- 16  storage_type
            p_package_id                          -- 17  package_id
        );

        insert into acs_messages 
            (message_id, reply_to, sent_date, sender, rfc822_id)
        values 
            (v_message_id, p_reply_to, p_sent_date, p_sender, v_rfc822_id);

        -- create an initial revision for the new message
        v_revision_id := acs_message__edit (
            v_message_id,			   -- message_id     
            p_title,				   -- title          
            p_description,			   -- description    
            p_mime_type,			   -- mime_type      
            p_text,				   -- text           
            p_data,				   -- data           
            p_creation_date,			   -- creation_date  
            p_creation_user,			   -- creation_user  
            p_creation_ip,			   -- creation_ip    
            p_is_live				   -- is_live        
        );

        return v_message_id;
END;
$_$;


ALTER FUNCTION public.acs_message__new(p_message_id integer, p_reply_to integer, p_sent_date timestamp with time zone, p_sender integer, p_rfc822_id character varying, p_title character varying, p_description character varying, p_mime_type character varying, p_text text, p_data integer, p_parent_id integer, p_context_id integer, p_creation_user integer, p_creation_ip character varying, p_object_type character varying, p_is_live boolean, p_package_id integer) OWNER TO evex;

--
-- Name: acs_message__new_extlink(character varying, integer, character varying, character varying, text, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__new_extlink(p_name character varying, p_extlink_id integer, p_url character varying, p_label character varying, p_description text, p_parent_id integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    return acs_message__new_extlink (p_name,
                                     p_extlink_id,
                                     p_url,
                                     p_label,
                                     p_description,
                                     p_parent_id,
                                     p_creation_date,
                                     p_creation_user,
                                     p_creation_ip,
                                     null
   );
END;
$$;


ALTER FUNCTION public.acs_message__new_extlink(p_name character varying, p_extlink_id integer, p_url character varying, p_label character varying, p_description text, p_parent_id integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying) OWNER TO evex;

--
-- Name: acs_message__new_extlink(character varying, integer, character varying, character varying, text, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__new_extlink(p_name character varying, p_extlink_id integer, p_url character varying, p_label character varying, p_description text, p_parent_id integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_extlink_id  cr_extlinks.extlink_id%TYPE;
BEGIN
    v_extlink_id := content_extlink__new (
         p_name,			-- name          
         p_url,				-- url           
         p_label,			-- label         
         p_description,			-- description   
         p_parent_id,			-- parent_id     
         p_extlink_id,			-- extlink_id    
         p_creation_date,		-- creation_date 
         p_creation_user,		-- creation_user 
         p_creation_ip,			-- creation_ip
         p_package_id
    );

	return v_extlink_id;
END;
$$;


ALTER FUNCTION public.acs_message__new_extlink(p_name character varying, p_extlink_id integer, p_url character varying, p_label character varying, p_description text, p_parent_id integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_package_id integer) OWNER TO evex;

--
-- Name: acs_message__new_file(integer, integer, character varying, character varying, text, character varying, integer, timestamp with time zone, integer, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__new_file(p_message_id integer, p_file_id integer, p_file_name character varying, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean, p_storage_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    return acs_message__new_file (p_message_id,
                                  p_file_id,
                                  p_file_name,
                                  p_title,
                                  p_description,
                                  p_mime_type,
                                  p_data,
                                  p_creation_date,
                                  p_creation_user,
                                  p_creation_ip,
                                  p_is_live,
                                  p_storage_type,
                                  null
   );
END;
$$;


ALTER FUNCTION public.acs_message__new_file(p_message_id integer, p_file_id integer, p_file_name character varying, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean, p_storage_type character varying) OWNER TO evex;

--
-- Name: acs_message__new_file(integer, integer, character varying, character varying, text, character varying, integer, timestamp with time zone, integer, character varying, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__new_file(p_message_id integer, p_file_id integer, p_file_name character varying, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean, p_storage_type character varying, p_package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_file_id      cr_items.item_id%TYPE;
    v_revision_id  cr_revisions.revision_id%TYPE;
BEGIN
    v_file_id := content_item__new (
        p_file_name,			   -- name           
        p_message_id,			   -- parent_id      
        p_file_id,			   -- item_id        
        null,				   -- locale
        p_creation_date,		   -- creation_date  
        p_creation_user,		   -- creation_user  
        null,				   -- context_id
        p_creation_ip,			   -- creation_ip    
        'content_item',		   -- item_subtype
        'content_revision',		   -- content_type
        null,				   -- title
        null,				   -- description
        'text/plain',			   -- mime_type
        null,				   -- nls_language
        null,				   -- text
	p_storage_type,			   -- storage_type
        p_package_id			   -- package_id
    );

    -- create an initial revision for the new attachment
    v_revision_id := acs_message__edit_file (
         v_file_id,			-- file_id        
         p_title,			-- title          
         p_description,			-- description    
         p_mime_type,			-- mime_type      
         p_data,			-- data        
         p_creation_date,		-- creation_date  
         p_creation_user,		-- creation_user  
         p_creation_ip,			-- creation_ip    
         p_is_live			-- is_live        
    );

    return v_file_id;
END;
$$;


ALTER FUNCTION public.acs_message__new_file(p_message_id integer, p_file_id integer, p_file_name character varying, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean, p_storage_type character varying, p_package_id integer) OWNER TO evex;

--
-- Name: acs_message__new_image(integer, integer, character varying, character varying, text, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__new_image(p_message_id integer, p_image_id integer, p_file_name character varying, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_width integer, p_height integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean, p_storage_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    return acs_message__new_image (p_message_id,
                                   p_image_id,
                                   p_file_name,
                                   p_title,
                                   p_description,
                                   p_mime_type,
                                   p_data,
                                   p_width,
                                   p_height,
                                   p_creation_date,
                                   p_creation_user,
                                   p_creation_ip,
                                   p_is_live,
                                   p_storage_type,
                                   null
   );
END;
$$;


ALTER FUNCTION public.acs_message__new_image(p_message_id integer, p_image_id integer, p_file_name character varying, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_width integer, p_height integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean, p_storage_type character varying) OWNER TO evex;

--
-- Name: acs_message__new_image(integer, integer, character varying, character varying, text, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__new_image(p_message_id integer, p_image_id integer, p_file_name character varying, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_width integer, p_height integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean, p_storage_type character varying, p_package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_image_id     cr_items.item_id%TYPE;
    v_revision_id  cr_revisions.revision_id%TYPE;
BEGIN
    v_image_id := content_item__new (
         p_file_name,				-- name          
         p_message_id,				-- parent_id     
         p_image_id,				-- item_id       
         null,					-- locale
         p_creation_date,			-- creation_date 
         p_creation_user,			-- creation_user 
         null,					-- context_id
         p_creation_ip,				-- creation_ip
	 'content_item',			-- item_subtype
	 'content_revision',			-- content_type
	 null,					-- title
	 null,					-- description
	 'text/plain',			-- mime_type
	 null,					-- nls_language
	 null,					-- text
	 'file',				-- storage_type
         p_package_id				-- package_id
    );

    -- create an initial revision for the new attachment
    v_revision_id := acs_message__edit_image (
         v_image_id,				-- image_id      
         p_title,				-- title         
         p_description,				-- description   
         p_mime_type,				-- mime_type     
         p_data,				-- data       
         p_width,				-- width         
         p_height,				-- height        
         p_creation_date,			-- creation_date 
         p_creation_user,			-- creation_user 
         p_creation_ip,				-- creation_ip   
         p_is_live				-- is_live       
    );

    return v_image_id;
END;
$$;


ALTER FUNCTION public.acs_message__new_image(p_message_id integer, p_image_id integer, p_file_name character varying, p_title character varying, p_description text, p_mime_type character varying, p_data integer, p_width integer, p_height integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_is_live boolean, p_storage_type character varying, p_package_id integer) OWNER TO evex;

--
-- Name: acs_message__send(integer, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__send(p_message_id integer, p_recipient_id integer, p_grouping_id integer, p_wait_until timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_wait_until timestamptz;
BEGIN
    v_wait_until := coalesce (p_wait_until, current_timestamp);
    insert into acs_messages_outgoing
        (message_id, to_address, grouping_id, wait_until)
    select p_message_id, p.email, p_grouping_id, v_wait_until
        from parties p
        where p.party_id = p_recipient_id;
    return 1;
END;
$$;


ALTER FUNCTION public.acs_message__send(p_message_id integer, p_recipient_id integer, p_grouping_id integer, p_wait_until timestamp with time zone) OWNER TO evex;

--
-- Name: acs_message__send(integer, character varying, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message__send(p_message_id integer, p_to_address character varying, p_grouping_id integer, p_wait_until timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_wait_until timestamptz;
BEGIN
    v_wait_until := coalesce(p_wait_until, current_timestamp);
    insert into acs_messages_outgoing
        (message_id, to_address, grouping_id, wait_until)
    values
        (p_message_id, p_to_address, p_grouping_id, v_wait_until);
    return 1;
END;
$$;


ALTER FUNCTION public.acs_message__send(p_message_id integer, p_to_address character varying, p_grouping_id integer, p_wait_until timestamp with time zone) OWNER TO evex;

--
-- Name: acs_message_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message_get_tree_sortkey(p_message_id integer) RETURNS bit varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
  return tree_sortkey from acs_messages where message_id = p_message_id;
END;
$$;


ALTER FUNCTION public.acs_message_get_tree_sortkey(p_message_id integer) OWNER TO evex;

--
-- Name: acs_message_insert_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_sk     varbit  default null;
        v_max_value     integer;
BEGIN
	if new.reply_to is null then
	    select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
              from acs_messages
             where reply_to is null;
        else
	    select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
              from acs_messages
             where reply_to = new.reply_to;

            select tree_sortkey into v_parent_sk 
              from acs_messages
             where message_id = new.reply_to;
        end if;

        new.tree_sortkey := tree_next_key(v_parent_sk, v_max_value);

        return new;

END;
$$;


ALTER FUNCTION public.acs_message_insert_tr() OWNER TO evex;

--
-- Name: acs_message_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_message_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_sk     varbit default null;
        v_max_value     integer;
        v_rec           record;
        clr_keys_p      boolean default 't';
BEGIN
        if new.message_id = old.message_id and 
           ((new.reply_to = old.reply_to) or 
            (new.reply_to is null and old.reply_to is null)) then

           return new;

        end if;

        for v_rec in select message_id, reply_to
                     from acs_messages
                     where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey)
                     order by tree_sortkey
        LOOP
            if clr_keys_p then
               update acs_messages set tree_sortkey = null
               where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);
               clr_keys_p := 'f';
            end if;
            
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
              from acs_messages
              where reply_to = v_rec.reply_to;

            select tree_sortkey into v_parent_sk 
              from acs_messages 
             where message_id = v_rec.reply_to;

            update acs_messages
               set tree_sortkey = tree_next_key(v_parent_sk, v_max_value)
             where message_id = v_rec.message_id;

        end LOOP;

        return new;

END;
$$;


ALTER FUNCTION public.acs_message_update_tr() OWNER TO evex;

--
-- Name: acs_object__check_context_index(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__check_context_index(check_context_index__object_id integer, check_context_index__ancestor_id integer, check_context_index__n_generations integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  n_rows                                      integer;       
  n_gens                                      integer;       
BEGIN
   -- Verify that this row exists in the index.
   if check_context_index__object_id is null or check_context_index__ancestor_id is null then
	raise exception 'object_id or ancestor_id is null in acs_object__check_context_index';
   end if;	
   select case when count(*) = 0 then 0 else 1 end into n_rows
   from acs_object_context_index
   where object_id = check_context_index__object_id
   and ancestor_id = check_context_index__ancestor_id;

   if n_rows = 1 then
     -- Verify that the count is correct.
     select n_generations into n_gens
     from acs_object_context_index
     where object_id = check_context_index__object_id
     and ancestor_id = check_context_index__ancestor_id;

     if n_gens != check_context_index__n_generations then
       PERFORM acs_log__error('acs_object.check_representation', 
                              'Ancestor ' ||
                     check_context_index__ancestor_id || ' of object ' || 
                     check_context_index__object_id ||
		     ' reports being generation ' || n_gens ||
		     ' when it is actually generation ' || 
                     check_context_index__n_generations ||
		     '.');
       return 'f';
     else
       return 't';
     end if;
   else
     PERFORM acs_log__error('acs_object.check_representation', 
                            'Ancestor ' ||
                            check_context_index__ancestor_id || 
                            ' of object ' || check_context_index__object_id 
                            || ' is missing an entry in acs_object_context_index.');
     return 'f';
   end if;
  
END;
$$;


ALTER FUNCTION public.acs_object__check_context_index(check_context_index__object_id integer, check_context_index__ancestor_id integer, check_context_index__n_generations integer) OWNER TO evex;

--
-- Name: acs_object__check_object_ancestors(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__check_object_ancestors(check_object_ancestors__object_id integer, check_object_ancestors__ancestor_id integer, check_object_ancestors__n_generations integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  check_object_ancestors__context_id             acs_objects.context_id%TYPE;
  check_object_ancestors__security_inherit_p     acs_objects.security_inherit_p%TYPE;
  n_rows                                         integer;       
  n_gens                                         integer;       
  result                                         boolean;       
BEGIN
   -- OBJECT_ID is the object we are verifying
   -- ANCESTOR_ID is the current ancestor we are tracking
   -- N_GENERATIONS is how far ancestor_id is from object_id

   -- Note that this function is only supposed to verify that the
   -- index contains each ancestor for OBJECT_ID. It doesn't
   -- guarantee that there aren''t extraneous rows or that
   -- OBJECT_ID's children are contained in the index. That is
   -- verified by seperate functions.

   result := 't';

   -- Grab the context and security_inherit_p flag of the current
   -- ancestor's parent.
   select context_id, security_inherit_p 
   into check_object_ancestors__context_id, 
        check_object_ancestors__security_inherit_p
   from acs_objects
   where object_id = check_object_ancestors__ancestor_id;

   if check_object_ancestors__ancestor_id = 0 then
     if check_object_ancestors__context_id is null then
       result := 't';
     else
       -- This can be a constraint, can't it?
       PERFORM acs_log__error('acs_object.check_representation',
                     'Object 0 doesn''t have a null context_id');
       result := 'f';
     end if;
   else
     if check_object_ancestors__context_id is null or 
        check_object_ancestors__security_inherit_p = 'f' 
     THEN
       check_object_ancestors__context_id := 0;
     end if;

     if acs_object__check_context_index(check_object_ancestors__object_id, 
                                        check_object_ancestors__ancestor_id, 
                                        check_object_ancestors__n_generations) = 'f' then
       result := 'f';
     end if;

     if acs_object__check_object_ancestors(check_object_ancestors__object_id, 
                                           check_object_ancestors__context_id,
	                      check_object_ancestors__n_generations + 1) = 'f' then
       result := 'f';
     end if;
   end if;

   return result;
  
END;
$$;


ALTER FUNCTION public.acs_object__check_object_ancestors(check_object_ancestors__object_id integer, check_object_ancestors__ancestor_id integer, check_object_ancestors__n_generations integer) OWNER TO evex;

--
-- Name: acs_object__check_object_descendants(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__check_object_descendants(object_id integer, descendant_id integer, n_generations integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result                 boolean;     
  obj                    record;  
BEGIN
   -- OBJECT_ID is the object we are verifying.
   -- DESCENDANT_ID is the current descendant we are tracking.
   -- N_GENERATIONS is how far the current DESCENDANT_ID is from
   -- OBJECT_ID.

   -- This function will verfy that each actualy descendant of
   -- OBJECT_ID has a row in the index table. It does not check that
   -- there aren't extraneous rows or that the ancestors of OBJECT_ID
   -- are maintained correctly.

   result := 't';

   -- First verify that OBJECT_ID and DESCENDANT_ID are actually in
   -- the index.
   if acs_object__check_context_index(descendant_id, object_id, n_generations) = 'f' then
     result := 'f';
   end if;

   -- For every child that reports inheriting from OBJECT_ID we need to call
   -- ourselves recursively.
   for obj in  select *
	       from acs_objects
	       where context_id = descendant_id
	       and security_inherit_p = 't' loop
     if acs_object__check_object_descendants(object_id, obj.object_id,
       n_generations + 1) = 'f' then
       result := 'f';
     end if;
   end loop;

   return result;
  
END;
$$;


ALTER FUNCTION public.acs_object__check_object_descendants(object_id integer, descendant_id integer, n_generations integer) OWNER TO evex;

--
-- Name: acs_object__check_path(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__check_path(check_path__object_id integer, check_path__ancestor_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  check_path__context_id             acs_objects.context_id%TYPE;
  check_path__security_inherit_p     acs_objects.security_inherit_p%TYPE;
BEGIN
   if check_path__object_id is null or check_path__ancestor_id then
	raise exception 'acs_object__check_path called with null object_id or ancestor_id';
   end if;

   if check_path__object_id = check_path__ancestor_id then
     return 't';
   end if;

   select context_id, security_inherit_p 
   into check_path__context_id, check_path__security_inherit_p
   from acs_objects
   where object_id = check_path__object_id;

   -- we should be able to handle the case where check_path fails 
   -- should we not?

   if check_path__object_id = 0 and check_path__context_id is null then 
      return 'f';
   end if;

   if check_path__context_id is null or check_path__security_inherit_p = 'f' 
   then
     check_path__context_id := 0;
   end if;

   return acs_object__check_path(check_path__context_id, 
                                 check_path__ancestor_id);
  
END;
$$;


ALTER FUNCTION public.acs_object__check_path(check_path__object_id integer, check_path__ancestor_id integer) OWNER TO evex;

--
-- Name: acs_object__check_representation(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__check_representation(check_representation__object_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result                                       boolean;       
  check_representation__object_type            acs_objects.object_type%TYPE;
  n_rows                                       integer;    
  v_rec                                        record;  
  row                                          record; 
BEGIN
   if check_representation__object_id is null then 
	raise exception 'acs_object__check_representation called for null object_id';
   end if;

   result := 't';
   PERFORM acs_log__notice('acs_object.check_representation',
                  'Running acs_object.check_representation on object_id = ' 
                  || check_representation__object_id || '.');

   select object_type into check_representation__object_type
   from acs_objects
   where object_id = check_representation__object_id;

   PERFORM acs_log__notice('acs_object.check_representation',
                  'OBJECT STORAGE INTEGRITY TEST');

   for v_rec in  select t.object_type, t.table_name, t.id_column
             from acs_object_type_supertype_map m, acs_object_types t
	     where m.ancestor_type = t.object_type
	     and m.object_type = check_representation__object_type
	     union
	     select object_type, table_name, id_column
	     from acs_object_types
	     where object_type = check_representation__object_type 
     LOOP

        for row in execute 'select case when count(*) = 0 then 0 else 1 end as n_rows from ' || quote_ident(v_rec.table_name) || ' where ' || quote_ident(v_rec.id_column) || ' = ' || check_representation__object_id
        LOOP
            n_rows := row.n_rows;
            exit;
        end LOOP;

        if n_rows = 0 then
           result := 'f';
           PERFORM acs_log__error('acs_object.check_representation',
                     'Table ' || v_rec.table_name || 
                     ' (primary storage for ' ||
		     v_rec.object_type || 
                     ') doesn''t have a row for object ' ||
		     check_representation__object_id || ' of type ' || 
                     check_representation__object_type || '.');
        end if;

   end loop;

   PERFORM acs_log__notice('acs_object.check_representation',
                  'OBJECT CONTEXT INTEGRITY TEST');

   if acs_object__check_object_ancestors(check_representation__object_id, 
                                         check_representation__object_id, 0) = 'f' then
     result := 'f';
   end if;

   if acs_object__check_object_descendants(check_representation__object_id, 
                                           check_representation__object_id, 0) = 'f' then
     result := 'f';
   end if;
   for row in  select object_id, ancestor_id, n_generations
	       from acs_object_context_index
	       where object_id = check_representation__object_id
	       or ancestor_id = check_representation__object_id 
   LOOP
     if acs_object__check_path(row.object_id, row.ancestor_id) = 'f' then
       PERFORM acs_log__error('acs_object.check_representation',
		     'acs_object_context_index contains an extraneous row: '
                     || 'object_id = ' || row.object_id || 
                     ', ancestor_id = ' || row.ancestor_id || 
                     ', n_generations = ' || row.n_generations || '.');
       result := 'f';
     end if;
   end loop;

   PERFORM acs_log__notice('acs_object.check_representation',
		  'Done running acs_object.check_representation ' || 
		  'on object_id = ' || check_representation__object_id || '.');

   return result;
  
END;
$$;


ALTER FUNCTION public.acs_object__check_representation(check_representation__object_id integer) OWNER TO evex;

--
-- Name: acs_object__default_name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__default_name(default_name__object_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  object_type_pretty_name   acs_object_types.pretty_name%TYPE;
BEGIN
  select ot.pretty_name
  into object_type_pretty_name
  from acs_objects o, acs_object_types ot
  where o.object_id = default_name__object_id
  and o.object_type = ot.object_type;

  return object_type_pretty_name || ' ' || default_name__object_id;

END;
$$;


ALTER FUNCTION public.acs_object__default_name(default_name__object_id integer) OWNER TO evex;

--
-- Name: acs_object__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__delete(delete__object_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  obj_type record;
BEGIN
  
  -- GN: the following deletion operation iterates over the id_columns
  -- of the acs_object_types of the type tree for the obejct and
  -- performs manual deletions in these tables by trying to delete the
  -- delete__object_id from the id_column.  This deletion includes as
  -- well the deletion in acs_objects.
  --
  -- In the best of all possible worlds, this would not
  -- be necessary, when the objects would have specified "on delete
  -- cascade" for the id_columns.

  for obj_type
  in select ot2.table_name, ot2.id_column
       from acs_object_types ot1, acs_object_types ot2
       where ot1.object_type = (select object_type
                               from acs_objects o
                               where o.object_id = delete__object_id)
         and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
    order by ot2.tree_sortkey desc
  loop
    -- Delete from the table.

    -- DRB: I removed the quote_ident calls that DanW originally included
    -- because the table names appear to be stored in upper case.  Quoting
    -- causes them to not match the actual lower or potentially mixed-case
    -- table names.  We will just forbid squirrely names that include quotes.
    
    -- daveB
    -- ETP is creating a new object, but not a table, although it does specify a
    -- table name, so we need to check if the table exists. Wp-slim does this too

    if table_exists(obj_type.table_name) then
      execute 'delete from ' || obj_type.table_name ||
          ' where ' || obj_type.id_column || ' =  ' || delete__object_id;
    end if;
  end loop;

  return 0; 
END;
$$;


ALTER FUNCTION public.acs_object__delete(delete__object_id integer) OWNER TO evex;

--
-- Name: acs_object__get_attr_storage_column(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__get_attr_storage_column(v_vals text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
        v_idx   integer;
BEGIN
        v_idx := strpos(v_vals,',');
        if v_idx = 0 or v_vals is null then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_column %',v_vals;
        end if;

        return substr(v_vals,1,v_idx - 1);

END;
$$;


ALTER FUNCTION public.acs_object__get_attr_storage_column(v_vals text) OWNER TO evex;

--
-- Name: acs_object__get_attr_storage_sql(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__get_attr_storage_sql(v_vals text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
        v_idx   integer;
        v_tmp   varchar;
BEGIN
        v_idx := strpos(v_vals, ',');

        if v_idx = 0 or v_vals is null then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_sql %',v_vals;
        end if;

        v_tmp := substr(v_vals, v_idx + 1);
        v_idx := strpos(v_tmp, ',');
        if v_idx = 0 then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_sql %',v_vals;
        end if;

        return substr(v_tmp, v_idx + 1);

END;
$$;


ALTER FUNCTION public.acs_object__get_attr_storage_sql(v_vals text) OWNER TO evex;

--
-- Name: acs_object__get_attr_storage_table(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__get_attr_storage_table(v_vals text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
        v_idx   integer;
        v_tmp   varchar;
BEGIN
        v_idx := strpos(v_vals,',');

        if v_idx = 0 or v_vals is null then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_table %',v_vals;
        end if;

        v_tmp := substr(v_vals,v_idx + 1);
        v_idx := strpos(v_tmp,',');
        if v_idx = 0 then 
           raise exception 'invalid storage format: acs_object.get_attr_storage_table %',v_vals;
        end if;

        return substr(v_tmp,1,v_idx - 1);

END;
$$;


ALTER FUNCTION public.acs_object__get_attr_storage_table(v_vals text) OWNER TO evex;

--
-- Name: acs_object__get_attribute(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__get_attribute(object_id_in integer, attribute_name_in character varying) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_table_name           varchar(200);  
  v_column               varchar(200);  
  v_key_sql              text; 
  v_return               text; 
  v_storage              text;
  v_rec                  record;
BEGIN

   v_storage := acs_object__get_attribute_storage(object_id_in, attribute_name_in);

   v_column     := acs_object__get_attr_storage_column(v_storage);
   v_table_name := acs_object__get_attr_storage_table(v_storage);
   v_key_sql    := acs_object__get_attr_storage_sql(v_storage);

   for v_rec in execute 'select ' || quote_ident(v_column) || '::text as column_return from ' || quote_ident(v_table_name) || ' where ' || v_key_sql
      LOOP
        v_return := v_rec.column_return;
        exit;
   end loop;
   if not FOUND then 
       return null;
   end if;

   return v_return;

END;
$$;


ALTER FUNCTION public.acs_object__get_attribute(object_id_in integer, attribute_name_in character varying) OWNER TO evex;

--
-- Name: acs_object__get_attribute_storage(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__get_attribute_storage(object_id_in integer, attribute_name_in character varying) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE

--  these three are the out variables
  v_column               varchar;  
  v_table_name           varchar;  
  v_key_sql              text;
  
  v_object_type          acs_attributes.object_type%TYPE;
  v_static               acs_attributes.static_p%TYPE;
  v_attr_id              acs_attributes.attribute_id%TYPE;
  v_storage              acs_attributes.storage%TYPE;
  v_attr_name            acs_attributes.attribute_name%TYPE;
  v_id_column            varchar(200);   
  v_sql                  text;  
  v_return               text;  
  v_rec                  record;
BEGIN
   --   select 
   --     object_type, id_column
   --   from
   --     acs_object_types
   --   connect by
   --     object_type = prior supertype
   --   start with
   --     object_type = (select object_type from acs_objects 
   --                    where object_id = object_id_in)

   -- Determine the attribute parameters
   select
     a.attribute_id, a.static_p, a.storage, a.table_name, a.attribute_name,
     a.object_type, a.column_name, t.id_column 
   into 
     v_attr_id, v_static, v_storage, v_table_name, v_attr_name, 
     v_object_type, v_column, v_id_column
   from 
     acs_attributes a,
     (select ot2.object_type, ot2.id_column
       from acs_object_types ot1, acs_object_types ot2
      where ot1.object_type = (select object_type
                                from acs_objects o
                               where o.object_id = object_id_in)
        and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
     ) t
   where   
     a.attribute_name = attribute_name_in
   and
     a.object_type = t.object_type;

   if NOT FOUND then 
      raise EXCEPTION '-20000: No such attribute % for object % in acs_object.get_attribute_storage.', attribute_name_in, object_id_in;
   end if;

   -- This should really be done in a trigger on acs_attributes,
   -- instead of generating it each time in this function

   -- If there is no specific table name for this attribute,
   -- figure it out based on the object type
   if v_table_name is null or v_table_name = '' then

     -- Determine the appropriate table name
     if v_storage = 'generic' then
       -- Generic attribute: table name/column are hardcoded

       v_column := 'attr_value';

       if v_static = 'f' then
         v_table_name := 'acs_attribute_values';
         v_key_sql := '(object_id = ' || object_id_in || ' and ' ||
                      'attribute_id = ' || v_attr_id || ')';
       else
         v_table_name := 'acs_static_attr_values';
         v_key_sql := '(object_type = ''' || v_object_type || ''' and ' ||
                      'attribute_id = ' || v_attr_id || ')';
       end if;

     else
       -- Specific attribute: table name/column need to be retreived
 
       if v_static = 'f' then
         select 
           table_name, id_column 
         into 
           v_table_name, v_id_column
         from 
           acs_object_types 
         where 
           object_type = v_object_type;
         if NOT FOUND then 
            raise EXCEPTION '-20000: No data found for attribute %::% object_id % in acs_object.get_attribute_storage', v_object_type, attribute_name_in, object_id_in;
         end if;
       else
         raise EXCEPTION '-20000: No table name specified for storage specific static attribute %::% object_id % in acs_object.get_attribute_storage.',v_object_type, attribute_name_in, object_id_in;
       end if;
  
     end if;
   else 
     -- There is a custom table name for this attribute.
     -- Get the id column out of the acs_object_tables
     -- Raise an error if not found
     select id_column into v_id_column from acs_object_type_tables
       where object_type = v_object_type 
       and table_name = v_table_name;
       if NOT FOUND then 
          raise EXCEPTION '-20000: No data found for attribute %::% object_id % in acs_object.get_attribute_storage', v_object_type, attribute_name_in, object_id_in;
       end if;
   end if;

   if v_column is null or v_column = '' then

     if v_storage = 'generic' then
       v_column := 'attr_value';
     else
       v_column := v_attr_name;
     end if;

   end if;

   if v_key_sql is null or v_key_sql = '' then
     if v_static = 'f' then   
       v_key_sql := v_id_column || ' = ' || object_id_in ; 
     else
       v_key_sql := v_id_column || ' = ''' || v_object_type || '''';
     end if;
   end if;

   return v_column || ',' || v_table_name || ',' || v_key_sql; 

END;
$$;


ALTER FUNCTION public.acs_object__get_attribute_storage(object_id_in integer, attribute_name_in character varying) OWNER TO evex;

--
-- Name: acs_object__initialize_attributes(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__initialize_attributes(initialize_attributes__object_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_object_type                                 acs_objects.object_type%TYPE;
BEGIN
   if  initialize_attributes__object_id is null then 
	raise exception 'acs_object__initialize_attributes called with null object_id';
   end if;

   -- Initialize dynamic attributes
   insert into acs_attribute_values
    (object_id, attribute_id, attr_value)
   select
    initialize_attributes__object_id, a.attribute_id, a.default_value
   from acs_attributes a, acs_objects o
   where a.object_type = o.object_type
   and o.object_id = initialize_attributes__object_id
   and a.storage = 'generic'
   and a.static_p = 'f';

   -- Retrieve type for static attributes
   select object_type into v_object_type from acs_objects
     where object_id = initialize_attributes__object_id;

   -- Initialize static attributes
   -- begin
     insert into acs_static_attr_values
      (object_type, attribute_id, attr_value)
     select
      v_object_type, a.attribute_id, a.default_value
     from acs_attributes a, acs_objects o
     where a.object_type = o.object_type
       and o.object_id = initialize_attributes__object_id
       and a.storage = 'generic'
       and a.static_p = 't'
       and not exists (select 1 from acs_static_attr_values
                       where object_type = a.object_type);
   -- exception when no_data_found then null;

   return 0; 
END;
$$;


ALTER FUNCTION public.acs_object__initialize_attributes(initialize_attributes__object_id integer) OWNER TO evex;

--
-- Name: acs_object__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__name(name__object_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  object_name            varchar;  
  v_object_id            integer;
  obj_type               record;  
  obj                    record;      
BEGIN
  -- Find the name function for this object, which is stored in the
  -- name_method column of acs_object_types. Starting with this
  -- object's actual type, traverse the type hierarchy upwards until
  -- a non-null name_method value is found.
  --
  -- select name_method
  --  from acs_object_types
  -- start with object_type = (select object_type
  --                             from acs_objects o
  --                            where o.object_id = name__object_id)
  -- connect by object_type = prior supertype

  select title into object_name
  from acs_objects
  where object_id = name__object_id;

  if (object_name is not null) then
    return object_name;
  end if;

  for obj_type
  in select ot2.name_method
        from acs_object_types ot1, acs_object_types ot2
       where ot1.object_type = (select object_type
                                 from acs_objects o
                                where o.object_id = name__object_id)
         and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
    order by ot2.tree_sortkey desc
  loop
   if obj_type.name_method != '' and obj_type.name_method is NOT null then

    -- Execute the first name_method we find (since we're traversing
    -- up the type hierarchy from the object's exact type) using
    -- Native Dynamic SQL, to ascertain the name of this object.
    --
    --execute 'select ' || object_type.name_method || '(:1) from dual'

    for obj in execute 'select ' || obj_type.name_method || '(' || name__object_id || ')::varchar as object_name' loop
        object_name := obj.object_name;
        exit;
    end loop;

    exit;
   end if;
  end loop;

  return object_name;
  
END;
$$;


ALTER FUNCTION public.acs_object__name(name__object_id integer) OWNER TO evex;

--
-- Name: acs_object__new(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__new(object_id integer, object_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_object__new/2 maybe obsolete, when we define proper defaults for /9
--
DECLARE
BEGIN
        return acs_object__new(object_id,object_type,now(),null,null,null);
END;
$$;


ALTER FUNCTION public.acs_object__new(object_id integer, object_type character varying) OWNER TO evex;

--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_object__new/6 maybe obsolete, when we define proper defaults for /9
--
DECLARE
  v_object_id                 acs_objects.object_id%TYPE;
  v_creation_date	      timestamptz;
BEGIN
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         't', null, null);
END;
$$;


ALTER FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer) OWNER TO evex;

--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__security_inherit_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_object__new/7 maybe obsolete, when we define proper defaults for /9
--
DECLARE
BEGIN
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         new__security_inherit_p, null, null);
END;
$$;


ALTER FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__security_inherit_p boolean) OWNER TO evex;

--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__title character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_object__new/7 maybe obsolete, when we define proper defaults for /9
--
DECLARE
BEGIN
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         't', new__title, null);
END;
$$;


ALTER FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__title character varying) OWNER TO evex;

--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__security_inherit_p boolean, new__title character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_object__new/8 maybe obsolete, when we define proper defaults for /9
--
DECLARE
BEGIN
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         new__security_inherit_p, new__title, null);
END;
$$;


ALTER FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__security_inherit_p boolean, new__title character varying) OWNER TO evex;

--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__title character varying, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_object__new/8 maybe obsolete, when we define proper defaults for /9
--
DECLARE
BEGIN
  return acs_object__new(new__object_id, new__object_type, new__creation_date,
                         new__creation_user, new__creation_ip, new__context_id,
                         't', new__title, new__package_id);
END;
$$;


ALTER FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__title character varying, new__package_id integer) OWNER TO evex;

--
-- Name: acs_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__security_inherit_p boolean, new__title character varying, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_object_id                 acs_objects.object_id%TYPE;
  v_creation_date	      timestamptz;
  v_title                     acs_objects.title%TYPE;
  v_object_type_pretty_name   acs_object_types.pretty_name%TYPE;
BEGIN
  if new__object_id is null then
    select nextval('t_acs_object_id_seq') into v_object_id;
  else
    v_object_id := new__object_id;
  end if;

  if new__title is null then
   select pretty_name
   into v_object_type_pretty_name
   from acs_object_types
   where object_type = new__object_type;

    v_title := v_object_type_pretty_name || ' ' || v_object_id;
  else
    v_title := new__title;
  end if;

  if new__creation_date is null then
   v_creation_date:= now();
  else
   v_creation_date := new__creation_date;
  end if;

  insert into acs_objects
   (object_id, object_type, title, package_id, context_id,
    creation_date, creation_user, creation_ip, security_inherit_p)
  values
   (v_object_id, new__object_type, v_title, new__package_id, new__context_id,
    v_creation_date, new__creation_user, new__creation_ip, 
    new__security_inherit_p);

  PERFORM acs_object__initialize_attributes(v_object_id);

  return v_object_id;
  
END;
$$;


ALTER FUNCTION public.acs_object__new(new__object_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer, new__security_inherit_p boolean, new__title character varying, new__package_id integer) OWNER TO evex;

--
-- Name: acs_object__package_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__package_id(p_object_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_package_id acs_objects.package_id%TYPE;
BEGIN
  if p_object_id is null then
    return null;
  end if;

  select package_id into v_package_id
  from acs_objects
  where object_id = p_object_id;

  return v_package_id;
END;
$$;


ALTER FUNCTION public.acs_object__package_id(p_object_id integer) OWNER TO evex;

--
-- Name: acs_object__set_attribute(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__set_attribute(object_id_in integer, attribute_name_in character varying, value_in character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_table_name           varchar;  
  v_column               varchar;  
  v_key_sql              text; 
  v_return               text; 
  v_storage              text;
BEGIN
   if value_in is null then 
	-- this will fail more cryptically in the execute so catch now. 
	raise exception 'acs_object__set_attribute: attempt to set % to null for object_id %',attribute_name_in, object_id_in;
   end if;

   v_storage := acs_object__get_attribute_storage(object_id_in, attribute_name_in);

   v_column     := acs_object__get_attr_storage_column(v_storage);
   v_table_name := acs_object__get_attr_storage_table(v_storage);
   v_key_sql    := acs_object__get_attr_storage_sql(v_storage);

   execute 'update ' || v_table_name || ' set ' || quote_ident(v_column) || ' = ' || quote_literal(value_in) || ' where ' || v_key_sql;

   return 0; 
END;
$$;


ALTER FUNCTION public.acs_object__set_attribute(object_id_in integer, attribute_name_in character varying, value_in character varying) OWNER TO evex;

--
-- Name: acs_object__update_last_modified(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__update_last_modified(acs_object__update_last_modified__object_id integer, acs_object__update_last_modified__modifying_user integer, acs_object__update_last_modified__modifying_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    return acs_object__update_last_modified(acs_object__update_last_modified__object_id, acs_object__update_last_modified__modifying_user, acs_object__update_last_modified__modifying_ip, now());
END;
$$;


ALTER FUNCTION public.acs_object__update_last_modified(acs_object__update_last_modified__object_id integer, acs_object__update_last_modified__modifying_user integer, acs_object__update_last_modified__modifying_ip character varying) OWNER TO evex;

--
-- Name: acs_object__update_last_modified(integer, integer, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object__update_last_modified(acs_object__update_last_modified__object_id integer, acs_object__update_last_modified__modifying_user integer, acs_object__update_last_modified__modifying_ip character varying, acs_object__update_last_modified__last_modified timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_parent_id                                          integer;
    v_last_modified                                      timestamptz;
BEGIN
    if acs_object__update_last_modified__last_modified is null then
        v_last_modified := now();
    else
        v_last_modified := acs_object__update_last_modified__last_modified;
    end if;

    update acs_objects
    set last_modified = v_last_modified,
        modifying_user = acs_object__update_last_modified__modifying_user,
        modifying_ip = acs_object__update_last_modified__modifying_ip
    where object_id = acs_object__update_last_modified__object_id;

    select context_id
    into v_parent_id
    from acs_objects
    where object_id = acs_object__update_last_modified__object_id;

    if v_parent_id is not null and v_parent_id != 0 then
        perform acs_object__update_last_modified(v_parent_id, acs_object__update_last_modified__modifying_user, acs_object__update_last_modified__modifying_ip, v_last_modified);
    end if;

    return acs_object__update_last_modified__object_id;
END;
$$;


ALTER FUNCTION public.acs_object__update_last_modified(acs_object__update_last_modified__object_id integer, acs_object__update_last_modified__modifying_user integer, acs_object__update_last_modified__modifying_ip character varying, acs_object__update_last_modified__last_modified timestamp with time zone) OWNER TO evex;

--
-- Name: acs_object_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, boolean, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type__create_type(p_object_type character varying, p_pretty_name character varying, p_pretty_plural character varying, p_supertype character varying, p_table_name character varying, p_id_column character varying, p_package_name character varying, p_abstract_p boolean, p_type_extension_table character varying, p_name_method character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_object_type__create_type/10 maybe obsolete, when we define proper defaults for /12
--
DECLARE
BEGIN
    return acs_object_type__create_type(p_object_type, p_pretty_name,
      p_pretty_plural, p_supertype, p_table_name,
      p_id_column, p_package_name, p_abstract_p,
      p_type_extension_table, p_name_method,'f','f');
END;
$$;


ALTER FUNCTION public.acs_object_type__create_type(p_object_type character varying, p_pretty_name character varying, p_pretty_plural character varying, p_supertype character varying, p_table_name character varying, p_id_column character varying, p_package_name character varying, p_abstract_p boolean, p_type_extension_table character varying, p_name_method character varying) OWNER TO evex;

--
-- Name: acs_object_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, boolean, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type__create_type(p_object_type character varying, p_pretty_name character varying, p_pretty_plural character varying, p_supertype character varying, p_table_name character varying, p_id_column character varying, p_package_name character varying, p_abstract_p boolean, p_type_extension_table character varying, p_name_method character varying, p_create_table_p boolean, p_dynamic_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_package_name                      acs_object_types.package_name%TYPE;
  v_supertype                         acs_object_types.supertype%TYPE;
  v_name_method                       varchar;
  v_idx                               integer;
  v_temp_p                            boolean;
  v_supertype_table                   acs_object_types.table_name%TYPE;
  v_id_column                         acs_object_types.id_column%TYPE;
  v_table_name                        acs_object_types.table_name%TYPE;
BEGIN
    v_idx := position('.' in p_name_method);
    if v_idx <> 0 then
         v_name_method := substr(p_name_method,1,v_idx - 1) || 
                       '__' || substr(p_name_method, v_idx + 1);
    else 
         v_name_method := p_name_method;
    end if;

    -- If we are asked to create the table, provide reasonable default values for the
    -- table name and id column.  Traditionally OpenACS uses the plural form of the type
    -- name.  This code appends "_t" (for "table") because the use of english plural rules
    -- does not work well for all languages.

    if p_create_table_p and (p_table_name is null or p_table_name = '') then
      v_table_name := p_object_type || '_t';
    else
      v_table_name := p_table_name;
    end if;

    if p_create_table_p and (p_id_column is null or p_id_column = '') then
      v_id_column := p_object_type || '_id';
    else
      v_id_column := p_id_column;
    end if;

    if p_package_name is null or p_package_name = '' then
      v_package_name := p_object_type;
    else
      v_package_name := p_package_name;
    end if;

    if p_object_type <> 'acs_object' then
      if p_supertype is null or p_supertype = '' then
        v_supertype := 'acs_object';
      else
        v_supertype := p_supertype;
        if not acs_object_type__is_subtype_p('acs_object', p_supertype) then
          raise exception '%s is not a valid type', p_supertype;
        end if;
      end if;
    end if;

    insert into acs_object_types
      (object_type, pretty_name, pretty_plural, supertype, table_name,
       id_column, abstract_p, type_extension_table, package_name,
       name_method, dynamic_p)
    values
      (p_object_type, p_pretty_name, 
       p_pretty_plural, v_supertype, 
       v_table_name, v_id_column, 
       p_abstract_p, p_type_extension_table, 
       v_package_name, v_name_method, p_dynamic_p);

    if p_create_table_p then

      if exists (select 1
                 from pg_class
                 where relname = lower(v_table_name)) then
        raise exception 'Table "%" already exists', v_table_name;
      end if;

      loop
        select table_name,object_type into v_supertype_table,v_supertype
        from acs_object_types
        where object_type = v_supertype;
        exit when v_supertype_table is not null;
      end loop;
  
      execute 'create table ' || v_table_name || ' (' ||
        v_id_column || ' integer constraint ' || v_table_name ||
        '_pk primary key ' || ' constraint ' || v_table_name ||
        '_fk references ' || v_supertype_table || ' on delete cascade)';
    end if;

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_object_type__create_type(p_object_type character varying, p_pretty_name character varying, p_pretty_plural character varying, p_supertype character varying, p_table_name character varying, p_id_column character varying, p_package_name character varying, p_abstract_p boolean, p_type_extension_table character varying, p_name_method character varying, p_create_table_p boolean, p_dynamic_p boolean) OWNER TO evex;

--
-- Name: acs_object_type__drop_type(character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type__drop_type(character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
  return acs_object_type__drop_type($1,$2,'f');
END;
$_$;


ALTER FUNCTION public.acs_object_type__drop_type(character varying, boolean) OWNER TO evex;

--
-- Name: acs_object_type__drop_type(character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type__drop_type(p_object_type character varying, p_drop_children_p boolean, p_drop_table_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  row                               record;
  object_row                        record;
  v_table_name                      acs_object_types.table_name%TYPE;
BEGIN

  -- drop children recursively
  if p_drop_children_p then
    for row in select object_type
               from acs_object_types
               where supertype = p_object_type 
    loop
      perform acs_object_type__drop_type(row.object_type, 't', p_drop_table_p);
    end loop;
  end if;

  -- drop all the attributes associated with this type
  for row in select attribute_name 
             from acs_attributes 
             where object_type = p_object_type 
  loop
    perform acs_attribute__drop_attribute (p_object_type, row.attribute_name);
  end loop;

  -- Remove the associated table if it exists and p_drop_table_p is true

  if p_drop_table_p then

    select table_name into v_table_name 
    from acs_object_types 
    where object_type = p_object_type;

    if found then
      if not exists (select 1
                     from pg_class
                     where relname = lower(v_table_name)) then
        raise exception 'Table "%" does not exist', v_table_name;
      end if;

      execute 'drop table ' || v_table_name || ' cascade';
    end if;

  end if;

  delete from acs_object_types
  where object_type = p_object_type;

  return 0; 
END;
$$;


ALTER FUNCTION public.acs_object_type__drop_type(p_object_type character varying, p_drop_children_p boolean, p_drop_table_p boolean) OWNER TO evex;

--
-- Name: acs_object_type__is_subtype_p(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type__is_subtype_p(is_subtype_p__object_type_1 character varying, is_subtype_p__object_type_2 character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_result                             integer;       
BEGIN
    select count(*) into v_result
     where exists (select 1
                     from acs_object_types t, acs_object_types t2
                    where t.object_type = is_subtype_p__object_type_2
                      and t2.object_type = is_subtype_p__object_type_1
                      and t.tree_sortkey between t2.tree_sortkey and tree_right(t2.tree_sortkey));

    if v_result > 0 then
       return 't';
    end if;

    return 'f';

END;
$$;


ALTER FUNCTION public.acs_object_type__is_subtype_p(is_subtype_p__object_type_1 character varying, is_subtype_p__object_type_2 character varying) OWNER TO evex;

--
-- Name: acs_object_type__pretty_name(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type__pretty_name(pretty_name__object_type character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_pretty_name                       acs_object_types.pretty_name%TYPE;
BEGIN
    select t.pretty_name into v_pretty_name
      from acs_object_types t
     where t.object_type = pretty_name__object_type;

    return v_pretty_name;
   
END;
$$;


ALTER FUNCTION public.acs_object_type__pretty_name(pretty_name__object_type character varying) OWNER TO evex;

--
-- Name: acs_object_type_get_tree_sortkey(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type_get_tree_sortkey(p_object_type character varying) RETURNS bit varying
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  return tree_sortkey from acs_object_types where object_type = p_object_type;
END;
$$;


ALTER FUNCTION public.acs_object_type_get_tree_sortkey(p_object_type character varying) OWNER TO evex;

--
-- Name: acs_object_type_insert_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type_insert_tr() RETURNS trigger
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
        v_parent_sk     varbit default null;
        v_max_value     integer;
BEGIN
        select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
          from acs_object_types 
         where supertype = new.supertype;

        select tree_sortkey into v_parent_sk 
          from acs_object_types 
         where object_type = new.supertype;

        new.tree_sortkey := tree_next_key(v_parent_sk ,v_max_value);

        return new;

END;
$$;


ALTER FUNCTION public.acs_object_type_insert_tr() OWNER TO evex;

--
-- Name: acs_object_type_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_type_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_sk     varbit default null;
        v_max_value     integer;
        v_rec           record;
        clr_keys_p      boolean default 't';
BEGIN
        if new.object_type = old.object_type and 
           ((new.supertype = old.supertype) or 
            (new.supertype is null and old.supertype is null)) then

           return new;

        end if;

        for v_rec in select object_type, supertype
                       from acs_object_types 
                      where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey)
                   order by tree_sortkey
        LOOP
            if clr_keys_p then
               update acs_object_types set tree_sortkey = null
               where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);
               clr_keys_p := 'f';
            end if;
            
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
              from acs_object_types 
              where supertype = v_rec.supertype;

            select tree_sortkey into v_parent_sk 
              from acs_object_types 
             where object_type = v_rec.supertype;

            update acs_object_types 
               set tree_sortkey = tree_next_key(v_parent_sk, v_max_value)
             where object_type = v_rec.object_type;

        end LOOP;

        return new;

END;
$$;


ALTER FUNCTION public.acs_object_type_update_tr() OWNER TO evex;

--
-- Name: acs_object_util__get_object_type(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_util__get_object_type(p_object_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_object_type       varchar(100);
BEGIN
    select object_type into v_object_type
    from acs_objects
    where object_id = p_object_id;

    if not found then
        raise exception 'acs_object_util__get_object_type: Invalid Object id: % ', p_object_id;
    end if;

    return v_object_type;

END;
$$;


ALTER FUNCTION public.acs_object_util__get_object_type(p_object_id integer) OWNER TO evex;

--
-- Name: acs_object_util__object_ancestor_type_p(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_util__object_ancestor_type_p(p_object_id integer, p_object_type character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_exist_p           boolean := 'f';
    v_object_type       varchar(100);
BEGIN
    v_object_type := acs_object_util__get_object_type (p_object_id);

    v_exist_p := acs_object_util__type_ancestor_type_p (v_object_type, p_object_type);
    return v_exist_p;
END;
$$;


ALTER FUNCTION public.acs_object_util__object_ancestor_type_p(p_object_id integer, p_object_type character varying) OWNER TO evex;

--
-- Name: acs_object_util__object_type_exist_p(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_util__object_type_exist_p(p_object_type character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_exist_p           boolean := 't';
BEGIN


    select (case when count(*)=1 then 't' else 'f' end) into v_exist_p
    from   acs_object_types 
    where  object_type = p_object_type;
 
    return v_exist_p;
END;
$$;


ALTER FUNCTION public.acs_object_util__object_type_exist_p(p_object_type character varying) OWNER TO evex;

--
-- Name: acs_object_util__object_type_p(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_util__object_type_p(p_object_id integer, p_object_type character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_exist_p           boolean := 'f';
BEGIN
    v_exist_p := acs_object_util__object_ancestor_type_p(p_object_id, p_object_type);
    return v_exist_p;
END;
$$;


ALTER FUNCTION public.acs_object_util__object_type_p(p_object_id integer, p_object_type character varying) OWNER TO evex;

--
-- Name: acs_object_util__type_ancestor_type_p(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_object_util__type_ancestor_type_p(p_object_type1 character varying, p_object_type2 character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN

    if not acs_object_util__object_type_exist_p(p_object_type1) then
        raise exception 'Object type % does not exist', p_object_type1;
    end if;

    if not acs_object_util__object_type_exist_p(p_object_type2) then
        raise exception 'Object type % does not exist', p_object_type2;
    end if;
        
    return exists (select 1
                   from acs_object_types o1, acs_object_types o2
                   where p_object_type2 = o2.object_type
                     and o1.object_type = p_object_type1
                     and o1.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey));
END;
$$;


ALTER FUNCTION public.acs_object_util__type_ancestor_type_p(p_object_type1 character varying, p_object_type2 character varying) OWNER TO evex;

--
-- Name: acs_objects_context_id_in_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_objects_context_id_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        security_context_root integer;
BEGIN
  insert into acs_object_context_index
   (object_id, ancestor_id, n_generations)
  values
   (new.object_id, new.object_id, 0);

  if new.context_id is not null and new.security_inherit_p = 't' then
    insert into acs_object_context_index
     (object_id, ancestor_id, n_generations)
    select
     new.object_id as object_id, ancestor_id,
     n_generations + 1 as n_generations
    from acs_object_context_index
    where object_id = new.context_id;
  else
    security_context_root = acs__magic_object_id('security_context_root');
    if new.object_id != security_context_root then
      insert into acs_object_context_index
        (object_id, ancestor_id, n_generations)
      values
        (new.object_id, security_context_root, 1);
    end if;
  end if;

  return new;

END;
$$;


ALTER FUNCTION public.acs_objects_context_id_in_tr() OWNER TO evex;

--
-- Name: acs_objects_context_id_up_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_objects_context_id_up_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        pair    record;
        outer_record record;
        inner_record record;
        security_context_root integer;
BEGIN
  if new.object_id = old.object_id
     and ((new.context_id = old.context_id)
	  or (new.context_id is null and old.context_id is null))
     and new.security_inherit_p = old.security_inherit_p then
    return new;
  end if;

  -- Remove my old ancestors from my descendants.
  for outer_record in select object_id from acs_object_context_index where 
               ancestor_id = old.object_id and object_id <> old.object_id loop
    for inner_record in select ancestor_id from acs_object_context_index where
                 object_id = old.object_id and ancestor_id <> old.object_id loop
      delete from acs_object_context_index
      where object_id = outer_record.object_id
        and ancestor_id = inner_record.ancestor_id;
    end loop;
  end loop;

  -- Kill all my old ancestors.
  delete from acs_object_context_index
  where object_id = old.object_id;

  insert into acs_object_context_index
   (object_id, ancestor_id, n_generations)
  values
   (new.object_id, new.object_id, 0);

  if new.context_id is not null and new.security_inherit_p = 't' then
     -- Now insert my new ancestors for my descendants.
    for pair in select *
		 from acs_object_context_index
		 where ancestor_id = new.object_id 
    LOOP
      insert into acs_object_context_index
       (object_id, ancestor_id, n_generations)
      select
       pair.object_id, ancestor_id,
       n_generations + pair.n_generations + 1 as n_generations
      from acs_object_context_index
      where object_id = new.context_id;
    end loop;
  else
    security_context_root = acs__magic_object_id('security_context_root');
    if new.object_id != security_context_root then
    -- We need to make sure that new.OBJECT_ID and all of its
    -- children have security_context_root as an ancestor.
    for pair in  select *
		 from acs_object_context_index
		 where ancestor_id = new.object_id 
      LOOP
        insert into acs_object_context_index
         (object_id, ancestor_id, n_generations)
        values
         (pair.object_id, security_context_root, pair.n_generations + 1);
      end loop;
    end if;
  end if;

  return new;

END;
$$;


ALTER FUNCTION public.acs_objects_context_id_up_tr() OWNER TO evex;

--
-- Name: acs_objects_last_mod_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_objects_last_mod_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  if new.last_modified is null then
     new.last_modified := old.last_modified;
  elsif new.last_modified = old.last_modified then
     new.last_modified := now();
  end if;
  return new;
END;
$$;


ALTER FUNCTION public.acs_objects_last_mod_update_tr() OWNER TO evex;

--
-- Name: acs_objects_mod_ip_insert_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_objects_mod_ip_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  new.modifying_ip := new.creation_ip;

  return new;

END;
$$;


ALTER FUNCTION public.acs_objects_mod_ip_insert_tr() OWNER TO evex;

--
-- Name: acs_permission__grant_permission(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_permission__grant_permission(p_object_id integer, p_grantee_id integer, p_privilege character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  RETURN acs_permission.grant_permission(p_object_id, p_grantee_id, p_privilege);
END; 
$$;


ALTER FUNCTION public.acs_permission__grant_permission(p_object_id integer, p_grantee_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: acs_permission__permission_p(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_permission__permission_p(p_object_id integer, p_party_id integer, p_privilege character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN acs_permission.permission_p(p_object_id, p_party_id, p_privilege);
END; 
$$;


ALTER FUNCTION public.acs_permission__permission_p(p_object_id integer, p_party_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: acs_permission__permission_p_recursive_array(integer[], integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_permission__permission_p_recursive_array(p_objects integer[], p_party_id integer, p_privilege character varying) RETURNS TABLE(object_id integer, orig_object_id integer)
    LANGUAGE sql STABLE
    AS $_$
  SELECT acs_permission.permission_p_recursive_array($1, $2, $3);
$_$;


ALTER FUNCTION public.acs_permission__permission_p_recursive_array(p_objects integer[], p_party_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: acs_permission__revoke_permission(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_permission__revoke_permission(p_object_id integer, p_grantee_id integer, p_privilege character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    RETURN acs_permission.revoke_permission(p_object_id, p_grantee_id, p_privilege);
END;
$$;


ALTER FUNCTION public.acs_permission__revoke_permission(p_object_id integer, p_grantee_id integer, p_privilege character varying) OWNER TO evex;

--
-- Name: acs_permissions_lock_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_permissions_lock_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
        raise EXCEPTION 'FOR LOCKING ONLY, NO DML STATEMENTS ALLOWED';
        return null;
END;
$$;


ALTER FUNCTION public.acs_permissions_lock_tr() OWNER TO evex;

--
-- Name: acs_priv_del_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_priv_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

  delete from acs_privilege_descendant_map
  where privilege = old.privilege;

  return old;

END;
$$;


ALTER FUNCTION public.acs_priv_del_tr() OWNER TO evex;

--
-- Name: acs_priv_hier_ins_del_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_priv_hier_ins_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        new_value       integer;
        new_key         varbit default null;
        v_rec           record;
        deleted_p       boolean;
BEGIN

        -- if more than one node was deleted the second trigger call
        -- will error out.  This check avoids that problem.

        if TG_OP = 'DELETE' then 
            select count(*) = 0 into deleted_p
              from acs_privilege_hierarchy_index 
             where old.privilege = privilege
               and old.child_privilege = child_privilege;     
       
            if deleted_p then

                return new;

            end if;
        end if;

        -- recalculate the table from scratch.

        delete from acs_privilege_hierarchy_index;

        -- first find the top nodes of the tree

        for v_rec in select privilege, child_privilege
                       from acs_privilege_hierarchy
                      where privilege 
                            NOT in (select distinct child_privilege
                                      from acs_privilege_hierarchy)
                                           
        LOOP

            -- top level node, so find the next key at this level.

            select max(tree_leaf_key_to_int(tree_sortkey)) into new_value 
              from acs_privilege_hierarchy_index
             where tree_level(tree_sortkey) = 1;

             -- insert the new node

            insert into acs_privilege_hierarchy_index 
                        (privilege, child_privilege, tree_sortkey)
                        values
                        (v_rec.privilege, v_rec.child_privilege, tree_next_key(null, new_value));

            -- now recurse down from this node

            PERFORM priv_recurse_subtree(tree_next_key(null, new_value), v_rec.child_privilege);

        end LOOP;

        -- materialize the map view to speed up queries
        -- DanW (dcwickstrom@earthlink.net) 30 Jan, 2003
        delete from acs_privilege_descendant_map;

        insert into acs_privilege_descendant_map (privilege, descendant) 
        select privilege, descendant from acs_privilege_descendant_map_view;

        return new;

END;
$$;


ALTER FUNCTION public.acs_priv_hier_ins_del_tr() OWNER TO evex;

--
-- Name: acs_privilege__add_child(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_privilege__add_child(add_child__privilege character varying, add_child__child_privilege character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_privilege_hierarchy
     (privilege, child_privilege)
    values
     (add_child__privilege, add_child__child_privilege);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_privilege__add_child(add_child__privilege character varying, add_child__child_privilege character varying) OWNER TO evex;

--
-- Name: acs_privilege__create_privilege(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_privilege__create_privilege(create_privilege__privilege character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    return acs_privilege__create_privilege(create_privilege__privilege, null, null);
END;
$$;


ALTER FUNCTION public.acs_privilege__create_privilege(create_privilege__privilege character varying) OWNER TO evex;

--
-- Name: acs_privilege__create_privilege(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_privilege__create_privilege(create_privilege__privilege character varying, create_privilege__pretty_name character varying, create_privilege__pretty_plural character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_privileges
     (privilege, pretty_name, pretty_plural)
    values
     (create_privilege__privilege, 
      create_privilege__pretty_name, 
      create_privilege__pretty_plural);
      
    return 0; 
END;
$$;


ALTER FUNCTION public.acs_privilege__create_privilege(create_privilege__privilege character varying, create_privilege__pretty_name character varying, create_privilege__pretty_plural character varying) OWNER TO evex;

--
-- Name: acs_privilege__drop_privilege(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_privilege__drop_privilege(drop_privilege__privilege character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from acs_privileges
    where privilege = drop_privilege__privilege;

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_privilege__drop_privilege(drop_privilege__privilege character varying) OWNER TO evex;

--
-- Name: acs_privilege__remove_child(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_privilege__remove_child(remove_child__privilege character varying, remove_child__child_privilege character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from acs_privilege_hierarchy
    where privilege = remove_child__privilege
    and child_privilege = remove_child__child_privilege;

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_privilege__remove_child(remove_child__privilege character varying, remove_child__child_privilege character varying) OWNER TO evex;

--
-- Name: acs_reference__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_reference__delete(p_repository_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_maintainer_id		acs_objects.object_id%TYPE;
BEGIN
    select maintainer_id into v_maintainer_id
    from   acs_reference_repositories
    where  repository_id = p_repository_id;

    delete from acs_reference_repositories
    where repository_id = p_repository_id;

    perform acs_object__delete(p_repository_id);
    return 0;
END;

$$;


ALTER FUNCTION public.acs_reference__delete(p_repository_id integer) OWNER TO evex;

--
-- Name: acs_reference__is_expired_p(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_reference__is_expired_p(repository_id integer) RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_expiry_date acs_reference_repositories.expiry_date%TYPE;
BEGIN
    select expiry_date into v_expiry_date
    from   acs_reference_repositories
    where  repository_id = is_expired_p.repository_id;

    if coalesce(v_expiry_date,now()+1) < now() then
        return 't';
    else
        return 'f';
    end if;
END;

$$;


ALTER FUNCTION public.acs_reference__is_expired_p(repository_id integer) OWNER TO evex;

--
-- Name: acs_reference__new(character varying, timestamp with time zone, character varying, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_reference__new(p_table_name character varying, p_last_update timestamp with time zone, p_source character varying, p_source_url character varying, p_effective_date timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_repository_id acs_reference_repositories.repository_id%TYPE;
BEGIN
    return acs_reference__new(null, p_table_name, 'f', null, null, p_source, p_source_url,
                              p_effective_date, null, null, null, null, null, null,
                              'acs_reference_repository', null);
END;

$$;


ALTER FUNCTION public.acs_reference__new(p_table_name character varying, p_last_update timestamp with time zone, p_source character varying, p_source_url character varying, p_effective_date timestamp with time zone) OWNER TO evex;

--
-- Name: acs_reference__new(integer, character varying, boolean, character varying, timestamp with time zone, character varying, character varying, timestamp with time zone, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_reference__new(p_repository_id integer, p_table_name character varying, p_internal_data_p boolean, p_package_name character varying, p_last_update timestamp with time zone, p_source character varying, p_source_url character varying, p_effective_date timestamp with time zone, p_expiry_date timestamp with time zone, p_maintainer_id integer, p_notes integer, p_first_names character varying, p_last_name character varying, p_creation_ip character varying, p_object_type character varying, p_creation_user integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_repository_id acs_reference_repositories.repository_id%TYPE;
    v_object_type   acs_objects.object_type%TYPE;
    v_maintainer_id persons.person_id%TYPE;
BEGIN
    if p_object_type is null then
        v_object_type := 'acs_reference_repository';
    else
        v_object_type := p_object_type;
    end if;

    v_repository_id := acs_object__new (
         p_repository_id,    
         v_object_type,
         now(),
         p_creation_user,
         p_creation_ip,
         null,
         't',
         p_source,
         null
    );

    -- This logic is not correct as the maintainer could already exist
    -- The way around this is a little clunky as you can search persons
    -- then pick an existing person or add a new one, to many screens!
    -- I really doubt the need for person anyway.
    --
    -- It probably needs to just be a UI function and pass
    -- in the value for maintainer.
    --
    -- IN OTHER WORDS
    -- Guaranteed to probably break in the future if you depend on
    -- first_names and last_name to still exist as a param
    -- This needs to be updated in the Oracle version also
    -- NEEDS TO BE FIXED - jag

    if p_first_names is not null and p_last_name is not null and p_maintainer_id is null then
        v_maintainer_id := person__new (null, 'person', now(), null, null, null, null,
	                                p_first_names, p_last_name, null);
	else if p_maintainer_id is not null then
           v_maintainer_id := p_maintainer_id;
        else 
	    v_maintainer_id := null;
	end if;
    end if;

    insert into acs_reference_repositories
        (repository_id,table_name,internal_data_p,
         last_update,package_name,source, 
         source_url,effective_date,expiry_date,
         maintainer_id,lob)
    values 
        (v_repository_id, p_table_name, p_internal_data_p,
         p_last_update, p_package_name, p_source, p_source_url,
         p_effective_date, p_expiry_date, v_maintainer_id, p_notes);

    return v_repository_id;    
END;

$$;


ALTER FUNCTION public.acs_reference__new(p_repository_id integer, p_table_name character varying, p_internal_data_p boolean, p_package_name character varying, p_last_update timestamp with time zone, p_source character varying, p_source_url character varying, p_effective_date timestamp with time zone, p_expiry_date timestamp with time zone, p_maintainer_id integer, p_notes integer, p_first_names character varying, p_last_name character varying, p_creation_ip character varying, p_object_type character varying, p_creation_user integer) OWNER TO evex;

--
-- Name: acs_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel__delete(rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    PERFORM acs_object__delete(rel_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_rel__delete(rel_id integer) OWNER TO evex;

--
-- Name: acs_rel__new(integer, character varying, integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel__new(new__rel_id integer, new__rel_type character varying, new__object_id_one integer, new__object_id_two integer, context_id integer, creation_user integer, creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_rel_id               acs_rels.rel_id%TYPE;
BEGIN
    v_rel_id := acs_object__new (
      new__rel_id,
      new__rel_type,
      now(),
      creation_user,
      creation_ip,
      context_id,
      't',
      new__rel_type || ': ' || new__object_id_one || ' - ' || new__object_id_two,
      null
    );

    insert into acs_rels
     (rel_id, rel_type, object_id_one, object_id_two)
    values
     (v_rel_id, new__rel_type, new__object_id_one, new__object_id_two);

    return v_rel_id;
   
END;
$$;


ALTER FUNCTION public.acs_rel__new(new__rel_id integer, new__rel_type character varying, new__object_id_one integer, new__object_id_two integer, context_id integer, creation_user integer, creation_ip character varying) OWNER TO evex;

--
-- Name: acs_rel_type__create_role(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel_type__create_role(create_role__role character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    perform acs_rel_type__create_role(create_role__role, NULL, NULL);
    return 0; 
END;
$$;


ALTER FUNCTION public.acs_rel_type__create_role(create_role__role character varying) OWNER TO evex;

--
-- Name: acs_rel_type__create_role(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel_type__create_role(create_role__role character varying, create_role__pretty_name character varying, create_role__pretty_plural character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into acs_rel_roles
     (role, pretty_name, pretty_plural)
    values
     (create_role__role, coalesce(create_role__pretty_name,create_role__role), coalesce(create_role__pretty_plural,create_role__role));

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_rel_type__create_role(create_role__role character varying, create_role__pretty_name character varying, create_role__pretty_plural character varying) OWNER TO evex;

--
-- Name: acs_rel_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, character varying, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel_type__create_type(create_type__rel_type character varying, create_type__pretty_name character varying, create_type__pretty_plural character varying, create_type__supertype character varying, create_type__table_name character varying, create_type__id_column character varying, create_type__package_name character varying, create_type__type_extension_table character varying, create_type__object_type_one character varying, create_type__min_n_rels_one integer, create_type__max_n_rels_one integer, create_type__object_type_two character varying, create_type__min_n_rels_two integer, create_type__max_n_rels_two integer, create_type__composable_p boolean DEFAULT true) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

  abstract_p   acs_object_types.abstract_p%TYPE      default 'f';
  name_method  acs_object_types.name_method%TYPE     default null;     
  create_type__role_one  acs_rel_types.role_one%TYPE default null;           
  create_type__role_two  acs_rel_types.role_two%TYPE default null;
BEGIN

    PERFORM acs_object_type__create_type(
      create_type__rel_type,
      create_type__pretty_name,
      create_type__pretty_plural,
      create_type__supertype,
      create_type__table_name,
      create_type__id_column,
      create_type__package_name,
      abstract_p,
      create_type__type_extension_table,
      name_method
    );

    insert into acs_rel_types
     (rel_type,
      object_type_one, role_one,
      min_n_rels_one, max_n_rels_one,
      object_type_two, role_two,
      min_n_rels_two, max_n_rels_two,
      composable_p)
    values
     (create_type__rel_type,
      create_type__object_type_one, create_type__role_one,
      create_type__min_n_rels_one, create_type__max_n_rels_one,
      create_type__object_type_two, create_type__role_two,
      create_type__min_n_rels_two, create_type__max_n_rels_two,
      create_type__composable_p);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_rel_type__create_type(create_type__rel_type character varying, create_type__pretty_name character varying, create_type__pretty_plural character varying, create_type__supertype character varying, create_type__table_name character varying, create_type__id_column character varying, create_type__package_name character varying, create_type__type_extension_table character varying, create_type__object_type_one character varying, create_type__min_n_rels_one integer, create_type__max_n_rels_one integer, create_type__object_type_two character varying, create_type__min_n_rels_two integer, create_type__max_n_rels_two integer, create_type__composable_p boolean) OWNER TO evex;

--
-- Name: acs_rel_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, character varying, character varying, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel_type__create_type(create_type__rel_type character varying, create_type__pretty_name character varying, create_type__pretty_plural character varying, create_type__supertype character varying, create_type__table_name character varying, create_type__id_column character varying, create_type__package_name character varying, create_type__object_type_one character varying, create_type__role_one character varying, create_type__min_n_rels_one integer, create_type__max_n_rels_one integer, create_type__object_type_two character varying, create_type__role_two character varying, create_type__min_n_rels_two integer, create_type__max_n_rels_two integer, create_type__composable_p boolean DEFAULT true) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

  type_extension_table acs_object_types.type_extension_table%TYPE default null;
  abstract_p   acs_object_types.abstract_p%TYPE      default 'f';
  name_method  acs_object_types.name_method%TYPE     default null;     
BEGIN
    PERFORM acs_object_type__create_type(
      create_type__rel_type,
      create_type__pretty_name,
      create_type__pretty_plural,
      create_type__supertype,
      create_type__table_name,
      create_type__id_column,
      create_type__package_name,
      abstract_p,
      type_extension_table,
      name_method
    );

    insert into acs_rel_types
     (rel_type,
      object_type_one, role_one,
      min_n_rels_one, max_n_rels_one,
      object_type_two, role_two,
      min_n_rels_two, max_n_rels_two,
      composable_p)
    values
     (create_type__rel_type,
      create_type__object_type_one, create_type__role_one,
      create_type__min_n_rels_one, create_type__max_n_rels_one,
      create_type__object_type_two, create_type__role_two,
      create_type__min_n_rels_two, create_type__max_n_rels_two,
      create_type__composable_p);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_rel_type__create_type(create_type__rel_type character varying, create_type__pretty_name character varying, create_type__pretty_plural character varying, create_type__supertype character varying, create_type__table_name character varying, create_type__id_column character varying, create_type__package_name character varying, create_type__object_type_one character varying, create_type__role_one character varying, create_type__min_n_rels_one integer, create_type__max_n_rels_one integer, create_type__object_type_two character varying, create_type__role_two character varying, create_type__min_n_rels_two integer, create_type__max_n_rels_two integer, create_type__composable_p boolean) OWNER TO evex;

--
-- Name: acs_rel_type__drop_role(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel_type__drop_role(drop_role__role character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from acs_rel_roles
    where role = drop_role__role;

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_rel_type__drop_role(drop_role__role character varying) OWNER TO evex;

--
-- Name: acs_rel_type__drop_type(character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel_type__drop_type(drop_type__rel_type character varying, drop_type__cascade_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_cascade_p                       boolean;
BEGIN
    -- XXX do cascade_p.
    -- JCD: cascade_p seems to be ignored in acs_o_type__drop_type anyway...

    if drop_type__cascade_p is null then 
	v_cascade_p := 'f';
    else 
	v_cascade_p := drop_type__cascade_p;
    end if;

    delete from acs_rel_types
	  where rel_type = drop_type__rel_type;

    PERFORM acs_object_type__drop_type(drop_type__rel_type, 
                                       v_cascade_p);

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_rel_type__drop_type(drop_type__rel_type character varying, drop_type__cascade_p boolean) OWNER TO evex;

--
-- Name: acs_rel_type__role_pretty_name(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel_type__role_pretty_name(role_pretty_name__role character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_pretty_name                 acs_rel_roles.pretty_name%TYPE;
BEGIN
    select r.pretty_name into v_pretty_name
      from acs_rel_roles r
     where r.role = role_pretty_name__role;

    return v_pretty_name;
   
END;
$$;


ALTER FUNCTION public.acs_rel_type__role_pretty_name(role_pretty_name__role character varying) OWNER TO evex;

--
-- Name: acs_rel_type__role_pretty_plural(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rel_type__role_pretty_plural(role_pretty_plural__role character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_pretty_plural               acs_rel_roles.pretty_plural%TYPE;
BEGIN
    select r.pretty_plural into v_pretty_plural
      from acs_rel_roles r
     where r.role = role_pretty_plural__role;

    return v_pretty_plural;
   
END;
$$;


ALTER FUNCTION public.acs_rel_type__role_pretty_plural(role_pretty_plural__role character varying) OWNER TO evex;

--
-- Name: acs_rels_in_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_rels_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  dummy integer;
  target_object_type_one acs_object_types.object_type%TYPE;
  target_object_type_two acs_object_types.object_type%TYPE;
  actual_object_type_one acs_object_types.object_type%TYPE;
  actual_object_type_two acs_object_types.object_type%TYPE;
BEGIN

    -- DRB: The obvious rewrite to use Dan's port of this to use tree_ancestor_keys kills
    -- Postgres!!!  Argh!!!  This is fast, to, so there ...

    -- Get all the object type info from the relationship.

    select rt.object_type_one, rt.object_type_two,
           o1.object_type, o2.object_type
    into target_object_type_one, target_object_type_two,
         actual_object_type_one, actual_object_type_two
    from acs_rel_types rt, acs_objects o1, acs_objects o2
    where rt.rel_type = new.rel_type
      and o1.object_id = new.object_id_one
      and o2.object_id = new.object_id_two;

    if not exists (select 1
                    from 
                    (select tree_ancestor_keys(acs_object_type_get_tree_sortkey(actual_object_type_one))
                      as tree_sortkey) parents1,
                    (select tree_ancestor_keys(acs_object_type_get_tree_sortkey(actual_object_type_two))
                      as tree_sortkey) parents2,
                    (select tree_sortkey from acs_object_types where object_type = target_object_type_one)
                      root1,
                    (select tree_sortkey from acs_object_types where object_type = target_object_type_two)
                      root2
                   where root1.tree_sortkey = parents1.tree_sortkey
                     and root2.tree_sortkey = parents2.tree_sortkey) then

      raise EXCEPTION '-20001: %  violation: Invalid object types. Object % (%) must be of type % Object % (%) must be of type %', new.rel_type, 
                                         new.object_id_one,
                                         actual_object_type_one,
                                         target_object_type_one,
                                         new.object_id_two,
                                         actual_object_type_two,
                                         target_object_type_two;

    end if;

    return new;

END;
$$;


ALTER FUNCTION public.acs_rels_in_tr() OWNER TO evex;

--
-- Name: acs_sc_binding__delete(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_binding__delete(p_contract_id integer, p_impl_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

    delete from acs_sc_bindings
    where contract_id = p_contract_id
    and impl_id = p_impl_id;

    return 0;
END;
$$;


ALTER FUNCTION public.acs_sc_binding__delete(p_contract_id integer, p_impl_id integer) OWNER TO evex;

--
-- Name: acs_sc_binding__delete(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_binding__delete(p_contract_name character varying, p_impl_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_contract_id               integer;
    v_impl_id                   integer;
BEGIN

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    v_impl_id := acs_sc_impl__get_id(p_contract_name,p_impl_name);

    perform acs_sc_binding__delete(v_contract_id,v_impl_id);

    return 0;

END;
$$;


ALTER FUNCTION public.acs_sc_binding__delete(p_contract_name character varying, p_impl_name character varying) OWNER TO evex;

--
-- Name: acs_sc_binding__exists_p(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_binding__exists_p(p_contract_name character varying, p_impl_name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_contract_id               integer;
    v_impl_id                   integer;
    v_exists_p                  integer;
BEGIN

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    v_impl_id := acs_sc_impl__get_id(p_contract_name,p_impl_name);

    select case when count(*)=0 then 0 else 1 end into v_exists_p
    from acs_sc_bindings
    where contract_id = v_contract_id
    and impl_id = v_impl_id;

    return v_exists_p;

END;
$$;


ALTER FUNCTION public.acs_sc_binding__exists_p(p_contract_name character varying, p_impl_name character varying) OWNER TO evex;

--
-- Name: acs_sc_binding__new(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_binding__new(p_contract_id integer, p_impl_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_contract_name             varchar;
    v_impl_name                 varchar;
    v_count                     integer;
    v_missing_op                varchar;
BEGIN

    v_contract_name := acs_sc_contract__get_name(p_contract_id);
    v_impl_name := acs_sc_impl__get_name(p_impl_id);

    select count(*),min(operation_name) into v_count, v_missing_op
    from acs_sc_operations
    where contract_id = p_contract_id
    and operation_name not in (select impl_operation_name
                               from acs_sc_impl_aliases
                               where impl_contract_name = v_contract_name
                               and impl_id = p_impl_id);

    if v_count > 0 then
        raise exception 'Binding of % to % failed since certain operations are not implemented like: %.', v_contract_name, v_impl_name, v_missing_op;
    end if;

    insert into acs_sc_bindings (
        contract_id,
        impl_id
    ) values (
        p_contract_id,
        p_impl_id
    );

    return 0;

END;
$$;


ALTER FUNCTION public.acs_sc_binding__new(p_contract_id integer, p_impl_id integer) OWNER TO evex;

--
-- Name: acs_sc_binding__new(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_binding__new(p_contract_name character varying, p_impl_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_contract_id               integer;
    v_impl_id                   integer;
    v_count                     integer;
BEGIN

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    v_impl_id := acs_sc_impl__get_id(p_contract_name,p_impl_name);

    if v_contract_id is null or v_impl_id is null then
        raise exception 'Binding of % to % failed.', p_contract_name, p_impl_name;
    else
        perform acs_sc_binding__new(v_contract_id,v_impl_id);
    end if;

    return 0;

END;
$$;


ALTER FUNCTION public.acs_sc_binding__new(p_contract_name character varying, p_impl_name character varying) OWNER TO evex;

--
-- Name: acs_sc_contract__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_contract__delete(p_contract_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

    delete from acs_sc_contracts
    where contract_id = p_contract_id;

    return 0;

END;
$$;


ALTER FUNCTION public.acs_sc_contract__delete(p_contract_id integer) OWNER TO evex;

--
-- Name: acs_sc_contract__delete(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_contract__delete(p_contract_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_contract_id               integer;
BEGIN

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    perform acs_sc_contract__delete(v_contract_id);

    return 0;

END;
$$;


ALTER FUNCTION public.acs_sc_contract__delete(p_contract_name character varying) OWNER TO evex;

--
-- Name: acs_sc_contract__get_id(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_contract__get_id(p_contract_name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_contract_id               integer;
BEGIN

    select contract_id into v_contract_id
    from acs_sc_contracts
    where contract_name = p_contract_name;

    return v_contract_id;

END;
$$;


ALTER FUNCTION public.acs_sc_contract__get_id(p_contract_name character varying) OWNER TO evex;

--
-- Name: acs_sc_contract__get_name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_contract__get_name(p_contract_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_contract_name             varchar;
BEGIN

    select contract_name into v_contract_name
    from acs_sc_contracts
    where contract_id = p_contract_id;

    return v_contract_name;

END;
$$;


ALTER FUNCTION public.acs_sc_contract__get_name(p_contract_id integer) OWNER TO evex;

--
-- Name: acs_sc_contract__new(character varying, text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_contract__new(p_contract_name character varying, p_contract_desc text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_contract_id               integer;
BEGIN

    v_contract_id := acs_object__new(
                null,
                'acs_sc_contract',
                now(),
                null,
                null,
                null,
                't',
                p_contract_name,
                null
            );

    insert into acs_sc_contracts (
        contract_id,
        contract_name,
        contract_desc
    ) values (
        v_contract_id,
        p_contract_name,
        p_contract_desc
    );

    return v_contract_id;

END;
$$;


ALTER FUNCTION public.acs_sc_contract__new(p_contract_name character varying, p_contract_desc text) OWNER TO evex;

--
-- Name: acs_sc_impl__delete(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_impl__delete(p_impl_contract_name character varying, p_impl_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

    delete from acs_sc_impls
    where impl_contract_name = p_impl_contract_name
    and impl_name = p_impl_name;

    return 0;

END;
$$;


ALTER FUNCTION public.acs_sc_impl__delete(p_impl_contract_name character varying, p_impl_name character varying) OWNER TO evex;

--
-- Name: acs_sc_impl__get_id(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_impl__get_id(p_impl_contract_name character varying, p_impl_name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_impl_id                   integer;
BEGIN

    select impl_id into v_impl_id
    from acs_sc_impls
    where impl_name = p_impl_name
    and impl_contract_name = p_impl_contract_name;

    return v_impl_id;

END;
$$;


ALTER FUNCTION public.acs_sc_impl__get_id(p_impl_contract_name character varying, p_impl_name character varying) OWNER TO evex;

--
-- Name: acs_sc_impl__get_name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_impl__get_name(p_impl_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_impl_name                 varchar;
BEGIN

    select impl_name into v_impl_name
    from acs_sc_impls
    where impl_id = p_impl_id;

    return v_impl_name;

END;
$$;


ALTER FUNCTION public.acs_sc_impl__get_name(p_impl_id integer) OWNER TO evex;

--
-- Name: acs_sc_impl__new(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_impl__new(p_impl_contract_name character varying, p_impl_name character varying, p_impl_owner_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- acs_sc_impl__new/3 maybe obsolete, when we define proper defaults for /4
--
DECLARE
    v_impl_id                   integer;
BEGIN
    -- Using an empty pretty name
    v_impl_id := acs_sc_impl__new(
        p_impl_contract_name,
        p_impl_name,
        p_impl_name,
        p_impl_owner_name
    );

    return v_impl_id;

END;
$$;


ALTER FUNCTION public.acs_sc_impl__new(p_impl_contract_name character varying, p_impl_name character varying, p_impl_owner_name character varying) OWNER TO evex;

--
-- Name: acs_sc_impl__new(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_impl__new(p_impl_contract_name character varying, p_impl_name character varying, p_impl_pretty_name character varying, p_impl_owner_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_impl_id                   integer;
BEGIN

    v_impl_id := acs_object__new(
                null,
                'acs_sc_implementation',
                now(),
                null,
                null,
                null,
                't',
                p_impl_pretty_name,
                null
            );

    insert into acs_sc_impls (
        impl_id,
        impl_name,
        impl_pretty_name,
        impl_owner_name,
        impl_contract_name
    ) values (
        v_impl_id,
        p_impl_name,
        p_impl_pretty_name,
        p_impl_owner_name,
        p_impl_contract_name
    );

    return v_impl_id;

END;
$$;


ALTER FUNCTION public.acs_sc_impl__new(p_impl_contract_name character varying, p_impl_name character varying, p_impl_pretty_name character varying, p_impl_owner_name character varying) OWNER TO evex;

--
-- Name: acs_sc_impl_alias__delete(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_impl_alias__delete(p_impl_contract_name character varying, p_impl_name character varying, p_impl_operation_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_impl_id                   integer;
BEGIN

    v_impl_id := acs_sc_impl__get_id(p_impl_contract_name, p_impl_name);

    delete from acs_sc_impl_aliases 
    where impl_contract_name = p_impl_contract_name 
    and impl_name = p_impl_name
    and impl_operation_name = p_impl_operation_name;

    return v_impl_id;

END;
$$;


ALTER FUNCTION public.acs_sc_impl_alias__delete(p_impl_contract_name character varying, p_impl_name character varying, p_impl_operation_name character varying) OWNER TO evex;

--
-- Name: acs_sc_impl_alias__new(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_impl_alias__new(p_impl_contract_name character varying, p_impl_name character varying, p_impl_operation_name character varying, p_impl_alias character varying, p_impl_pl character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_impl_id                   integer;
BEGIN

    v_impl_id := acs_sc_impl__get_id(p_impl_contract_name,p_impl_name);

    insert into acs_sc_impl_aliases (
        impl_id,
        impl_name,
        impl_contract_name,
        impl_operation_name,
        impl_alias,
        impl_pl
    ) values (
        v_impl_id,
        p_impl_name,
        p_impl_contract_name,
        p_impl_operation_name,
        p_impl_alias,
        p_impl_pl
    );

    return v_impl_id;

END;
$$;


ALTER FUNCTION public.acs_sc_impl_alias__new(p_impl_contract_name character varying, p_impl_name character varying, p_impl_operation_name character varying, p_impl_alias character varying, p_impl_pl character varying) OWNER TO evex;

--
-- Name: acs_sc_msg_type__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_msg_type__delete(p_msg_type_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

    delete from acs_sc_msg_types
    where msg_type_id = p_msg_type_id;

    return 0;

END;
$$;


ALTER FUNCTION public.acs_sc_msg_type__delete(p_msg_type_id integer) OWNER TO evex;

--
-- Name: acs_sc_msg_type__delete(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_msg_type__delete(p_msg_type_name character varying) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    v_msg_type_id		integer;
BEGIN

    v_msg_type_id := acs_sc_msg_type__get_id(p_msg_type_name);

    perform acs_sc_msg_type__delete(v_msg_type_id);

    return v_msg_type_id;

END;
$$;


ALTER FUNCTION public.acs_sc_msg_type__delete(p_msg_type_name character varying) OWNER TO evex;

--
-- Name: acs_sc_msg_type__get_id(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_msg_type__get_id(p_msg_type_name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_msg_type_id		integer;
BEGIN

    select msg_type_id into v_msg_type_id
    from acs_sc_msg_types
    where msg_type_name = p_msg_type_name;
   
    return v_msg_type_id;

END;
$$;


ALTER FUNCTION public.acs_sc_msg_type__get_id(p_msg_type_name character varying) OWNER TO evex;

--
-- Name: acs_sc_msg_type__get_name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_msg_type__get_name(p_msg_type_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_msg_type_name		varchar;
BEGIN

    select msg_type_name into v_msg_type_name
    from acs_sc_msg_types
    where msg_type_id = p_msg_type_id;
   
    return v_msg_type_name;

END;
$$;


ALTER FUNCTION public.acs_sc_msg_type__get_name(p_msg_type_id integer) OWNER TO evex;

--
-- Name: acs_sc_msg_type__new(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_msg_type__new(p_msg_type_name character varying, p_msg_type_spec character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_msg_type_id               integer;
BEGIN

    v_msg_type_id := acs_object__new(
                null,
                'acs_sc_msg_type',
                now(),
                null,
                null,
                null,
                't',
                p_msg_type_name,
                null
            );

    insert into acs_sc_msg_types (
        msg_type_id,
        msg_type_name
   ) values (
        v_msg_type_id,
        p_msg_type_name
    );

    perform acs_sc_msg_type__parse_spec(p_msg_type_name,p_msg_type_spec);

    return v_msg_type_id;

END;
$$;


ALTER FUNCTION public.acs_sc_msg_type__new(p_msg_type_name character varying, p_msg_type_spec character varying) OWNER TO evex;

--
-- Name: acs_sc_msg_type__new_element(character varying, character varying, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_msg_type__new_element(p_msg_type_name character varying, p_element_name character varying, p_element_msg_type_name character varying, p_element_msg_type_isset_p boolean, p_element_pos integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_msg_type_id		integer;
    v_element_msg_type_id	integer;
BEGIN

    v_msg_type_id := acs_sc_msg_type__get_id(p_msg_type_name);

    if v_msg_type_id is null then
        raise exception 'Unknown Message Type: %', p_msg_type_name;
    end if;

    v_element_msg_type_id := acs_sc_msg_type__get_id(p_element_msg_type_name);

    if v_element_msg_type_id is null then
        raise exception 'Unknown Message Type: %', p_element_msg_type_name;
    end if;

    insert into acs_sc_msg_type_elements (
        msg_type_id,
	element_name,
	element_msg_type_id,
	element_msg_type_isset_p,
	element_pos
    ) values (
        v_msg_type_id,
	p_element_name,
	v_element_msg_type_id,
	p_element_msg_type_isset_p,
	p_element_pos
    );

    return v_msg_type_id;

END;
$$;


ALTER FUNCTION public.acs_sc_msg_type__new_element(p_msg_type_name character varying, p_element_name character varying, p_element_msg_type_name character varying, p_element_msg_type_isset_p boolean, p_element_pos integer) OWNER TO evex;

--
-- Name: acs_sc_msg_type__parse_spec(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_msg_type__parse_spec(p_msg_type_name character varying, p_msg_type_spec character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_element			varchar;
    v_element_type		varchar;
    v_str_pos			integer;
    v_element_name		varchar;
    v_element_msg_type_name	varchar;
    v_element_msg_type_isset_p	boolean;
    v_element_pos		integer;
BEGIN

    v_element_pos := 1;
    v_element := split(p_msg_type_spec, ',', v_element_pos);

    while v_element is not null loop

        v_str_pos = instr(v_element, ':', 1, 1);

	if v_str_pos > 0 then
	    v_element_name := trim(substr(v_element, 1, v_str_pos-1));
	    v_element_type := trim(substr(v_element, v_str_pos+1, length(v_element) - v_str_pos));
	    if (instr(v_element_type, '[',1,1) = length(v_element_type)-1) and 
	       (instr(v_element_type, ']',1,1) = length(v_element_type)) then
	        v_element_msg_type_isset_p := 't';
	        v_element_msg_type_name := trim(substr(v_element_type,1,length(v_element_type)-2));
		if v_element_msg_type_name = '' then
		    raise exception 'Wrong Format: Message Type Specification';
		end if;
	    else
	        v_element_msg_type_isset_p := 'f';
	        v_element_msg_type_name := v_element_type;
	    end if;
        else
	    raise exception 'Wrong Format: Message Type Specification';
        end if;

        perform acs_sc_msg_type__new_element(
                   p_msg_type_name,				-- msg_type_id
		   v_element_name,				-- element_name
		   v_element_msg_type_name,			-- element_msg_type_id
		   v_element_msg_type_isset_p,			-- element_msg_type_isset_p
		   v_element_pos				-- element_pos
        );

        v_element_pos := v_element_pos + 1;
	v_element := split(p_msg_type_spec, ',', v_element_pos);

    end loop;

    return v_element_pos-1;

END;
$$;


ALTER FUNCTION public.acs_sc_msg_type__parse_spec(p_msg_type_name character varying, p_msg_type_spec character varying) OWNER TO evex;

--
-- Name: acs_sc_operation__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_operation__delete(p_operation_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

    delete from acs_sc_operations
    where operation_id = p_operation_id;

    return 0;

END;
$$;


ALTER FUNCTION public.acs_sc_operation__delete(p_operation_id integer) OWNER TO evex;

--
-- Name: acs_sc_operation__delete(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_operation__delete(p_contract_name character varying, p_operation_name character varying) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    v_operation_id              integer;
BEGIN

    v_operation_id := acs_sc_operation__get_id(
                          p_contract_name,
                          p_operation_name
                      );

    perform acs_sc_operation__delete(v_operation_id);

    return v_operation_id;

END;
$$;


ALTER FUNCTION public.acs_sc_operation__delete(p_contract_name character varying, p_operation_name character varying) OWNER TO evex;

--
-- Name: acs_sc_operation__get_id(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_operation__get_id(p_contract_name character varying, p_operation_name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_operation_id               integer;
BEGIN

    select operation_id into v_operation_id
    from acs_sc_operations
    where contract_name = p_contract_name 
    and operation_name = p_operation_name;

    return v_operation_id;

END;
$$;


ALTER FUNCTION public.acs_sc_operation__get_id(p_contract_name character varying, p_operation_name character varying) OWNER TO evex;

--
-- Name: acs_sc_operation__new(character varying, character varying, text, boolean, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_sc_operation__new(p_contract_name character varying, p_operation_name character varying, p_operation_desc text, p_operation_iscachable_p boolean, p_operation_nargs integer, p_operation_inputtype character varying, p_operation_outputtype character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_contract_id               integer;
    v_operation_id              integer;
    v_operation_inputtype_id    integer;
    v_operation_outputtype_id   integer;
BEGIN

    v_contract_id := acs_sc_contract__get_id(p_contract_name);

    v_operation_id := acs_object__new(
                         null,
                         'acs_sc_operation',
                         now(),
                         null,
                         null,
                         null,
                         't',
                         p_operation_name,
                         null
                     );

     v_operation_inputtype_id := acs_sc_msg_type__get_id(p_operation_inputtype);

     v_operation_outputtype_id := acs_sc_msg_type__get_id(p_operation_outputtype);

    insert into acs_sc_operations (
        contract_id,
        operation_id,
        contract_name,
        operation_name,
        operation_desc,
        operation_iscachable_p,
        operation_nargs,
        operation_inputtype_id,
        operation_outputtype_id
    ) values (
        v_contract_id,
        v_operation_id,
        p_contract_name,
        p_operation_name,
        p_operation_desc,
        p_operation_iscachable_p,
        p_operation_nargs,
        v_operation_inputtype_id,
        v_operation_outputtype_id
    );

    return v_operation_id;

END;
$$;


ALTER FUNCTION public.acs_sc_operation__new(p_contract_name character varying, p_operation_name character varying, p_operation_desc text, p_operation_iscachable_p boolean, p_operation_nargs integer, p_operation_inputtype character varying, p_operation_outputtype character varying) OWNER TO evex;

--
-- Name: acs_user__approve_email(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_user__approve_email(approve_email__user_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update users
    set email_verified_p = 't'
    where user_id = approve_email__user_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_user__approve_email(approve_email__user_id integer) OWNER TO evex;

--
-- Name: acs_user__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_user__delete(delete__user_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  delete from user_preferences
  where user_id = delete__user_id;

  delete from users
  where user_id = delete__user_id;

  PERFORM person__delete(delete__user_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.acs_user__delete(delete__user_id integer) OWNER TO evex;

--
-- Name: acs_user__new(character varying, character varying, character varying, character, character); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_user__new(email character varying, fname character varying, lname character varying, pword character, salt character) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return acs_user__new(null,
                             'user',
                             now(),
                             null,
                             null,                
                             email,
                             null,
                             fname,
                             lname,
                             pword,
                             salt,
                             null,
                             null,
                             null,
                             't',
                             null
                             );

END;
$$;


ALTER FUNCTION public.acs_user__new(email character varying, fname character varying, lname character varying, pword character, salt character) OWNER TO evex;

--
-- Name: acs_user__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_user__new(p_user_id integer, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_authority_id integer, p_username character varying, p_email character varying, p_url character varying, p_first_names character varying, p_last_name character varying, p_password character, p_salt character, p_screen_name character varying, p_email_verified_p boolean, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user_id                  users.user_id%TYPE;
    v_authority_id             auth_authorities.authority_id%TYPE;
    v_person_exists            varchar;			
BEGIN
    v_user_id := p_user_id;

    select case when count(*) = 0 then 'f' else 't' end into v_person_exists
    from persons where person_id = v_user_id;

    if v_person_exists = 'f' then
        v_user_id := person__new(
            v_user_id, 
            p_object_type,
            p_creation_date, 
            p_creation_user, 
            p_creation_ip,
            p_email, 
            p_url, 
            p_first_names, 
            p_last_name, 
            p_context_id
        );
    else
     update acs_objects set object_type = 'user' where object_id = v_user_id;
    end if;

    -- default to local authority
    if p_authority_id is null then
        select authority_id
        into   v_authority_id
        from   auth_authorities
        where  short_name = 'local';
    else
        v_authority_id := p_authority_id;
    end if;

    insert into users
       (user_id, authority_id, username, password, salt, screen_name, email_verified_p)
    values
       (v_user_id, v_authority_id, p_username, p_password, p_salt, p_screen_name, p_email_verified_p);

    insert into user_preferences
      (user_id)
      values
      (v_user_id);

    return v_user_id;
  
END;
$$;


ALTER FUNCTION public.acs_user__new(p_user_id integer, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_authority_id integer, p_username character varying, p_email character varying, p_url character varying, p_first_names character varying, p_last_name character varying, p_password character, p_salt character, p_screen_name character varying, p_email_verified_p boolean, p_context_id integer) OWNER TO evex;

--
-- Name: acs_user__receives_alerts_p(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_user__receives_alerts_p(receives_alerts_p__user_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  counter                                   boolean;       
BEGIN
  select case when count(*) = 0 then 'f' else 't' end into counter
   from users
   where no_alerts_until >= now()
   and user_id = receives_alerts_p__user_id;

  return counter;
  
END;
$$;


ALTER FUNCTION public.acs_user__receives_alerts_p(receives_alerts_p__user_id integer) OWNER TO evex;

--
-- Name: acs_user__unapprove_email(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.acs_user__unapprove_email(unapprove_email__user_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update users
    set email_verified_p = 'f'
    where user_id = unapprove_email__user_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.acs_user__unapprove_email(unapprove_email__user_id integer) OWNER TO evex;

--
-- Name: ad_group_member_admin_role_p(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ad_group_member_admin_role_p(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_user_id	alias for $1;
	p_group_id	alias for $2;

	ad_group_member_count	integer;
BEGIN
	select count(*) into ad_group_member_count 
	from acs_rels r, im_biz_object_members m, im_categories c
	where
		r.object_id_one = p_group_id
		and r.object_id_two = p_user_id
		and r.rel_id = m.rel_id
		and m.object_role_id = c.category_id
		and (c.category = 'Project Manager' or c.category = 'Key Account');

	if ad_group_member_count = 0 then
		return 'f';
	else
		return 't';
	end if;
end;$_$;


ALTER FUNCTION public.ad_group_member_admin_role_p(integer, integer) OWNER TO evex;

--
-- Name: ad_group_member_p(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ad_group_member_p(integer, integer) RETURNS character
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_user_id	alias for $1;
	p_group_id	alias for $2;

	ad_group_member_count	integer;
BEGIN
	select count(*) into ad_group_member_count from acs_rels
	where object_id_one = p_group_id and object_id_two = p_user_id;

	if ad_group_member_count = 0 then
		return 'f';
	else
		return 't';
	end if;
end;$_$;


ALTER FUNCTION public.ad_group_member_p(integer, integer) OWNER TO evex;

--
-- Name: add_months(date, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.add_months(date, integer) RETURNS date
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	p_date_in alias for $1;		-- date_id
	p_months alias for $2;		-- months to add

	v_date_out	date;
begin
	select p_date_in + "interval"(p_months || ' months') into v_date_out;
	return v_date_out;
end;$_$;


ALTER FUNCTION public.add_months(date, integer) OWNER TO evex;

--
-- Name: add_months(timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.add_months(add_months__somedate timestamp with time zone, add_months__n_months integer) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	-- Date math magic
	return add_months__somedate + to_interval(add_months__n_months,'months');

END;
$$;


ALTER FUNCTION public.add_months(add_months__somedate timestamp with time zone, add_months__n_months integer) OWNER TO evex;

--
-- Name: admin_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.admin_rel__delete(rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    PERFORM membership_rel__delete(rel_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.admin_rel__delete(rel_id integer) OWNER TO evex;

--
-- Name: admin_rel__new(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.admin_rel__new(object_id_one integer, object_id_two integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- admin_rel__new/2 maybe obsolete, when we define proper defaults for /7
--
DECLARE
BEGIN
    return membership_rel__new(
        null,                  -- rel_id
        'admin_rel',         -- rel_type
        object_id_one,         -- object_id_one
        object_id_two,         -- object_id_two
        'approved',          -- member_state
        null,                  -- creation_user
        null                   -- creation_ip
    );
END;
$$;


ALTER FUNCTION public.admin_rel__new(object_id_one integer, object_id_two integer) OWNER TO evex;

--
-- Name: admin_rel__new(integer, character varying, integer, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.admin_rel__new(p_rel_id integer, p_rel_type character varying, p_object_id_one integer, p_object_id_two integer, p_member_state character varying, p_creation_user integer, p_creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_rel_id               integer;       
BEGIN
    v_rel_id := membership_rel__new (
      p_rel_id,           -- rel_id
      p_rel_type,         -- rel_type
      p_object_id_one,    -- object_id_one
      p_object_id_two,    -- object_id_two
      p_member_state,     -- member_state
      p_creation_user,    -- creation_usre
      p_creation_ip       -- creation_ip
    );

    insert into admin_rels
     (rel_id)
    values
     (v_rel_id);

    return v_rel_id;
   
END;
$$;


ALTER FUNCTION public.admin_rel__new(p_rel_id integer, p_rel_type character varying, p_object_id_one integer, p_object_id_two integer, p_member_state character varying, p_creation_user integer, p_creation_ip character varying) OWNER TO evex;

--
-- Name: ams_attribute__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_attribute__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_ams_attribute_id      alias for $1;
        v_attribute_id          integer;
        v_object_type           varchar;
        v_attribute_name        varchar;
        v_dynamic_p             boolean;
begin
        select attribute_id, attribute_name, object_type, dynamic_p
          into v_attribute_id, v_object_type, v_attribute_name, v_dynamic_p
          from ams_attributes
         where ams_attribute_id = p_ams_attribute_id;

        delete from ams_attribute_values where attribute_id = v_attribute_id;

        PERFORM acs_object__delete (
                        p_ams_attribute_id
                );

        if v_dynamic_p then

        PERFORM acs_attribute__drop_attribute (
                        v_object_type,
                        v_attribute_name
                );

        end if;

        return 0;
end;$_$;


ALTER FUNCTION public.ams_attribute__delete(integer) OWNER TO evex;

--
-- Name: ams_attribute__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_attribute__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
        p_ams_attribute_id  alias for $1;
        v_name              varchar;
begin
        v_name := attribute_name 
             from ams_attributes
            where ams_attribute_id = p_ams_attribute_id;

        return v_name;
end;$_$;


ALTER FUNCTION public.ams_attribute__name(integer) OWNER TO evex;

--
-- Name: ams_attribute__new(integer, integer, character varying, boolean, boolean, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_attribute__new(integer, integer, character varying, boolean, boolean, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_attribute_id       alias for $1;
        p_ams_attribute_id   alias for $2; -- the Permissable AMS Attribute ID
        p_widget             alias for $3;
        p_dynamic_p          alias for $4;
        p_deprecated_p       alias for $5;
        p_creation_date      alias for $6;
        p_creation_user      alias for $7;
        p_creation_ip        alias for $8;
        p_context_id         alias for $9;
        v_ams_attribute_id   integer;
begin

        v_ams_attribute_id := acs_object__new (
                p_ams_attribute_id,
                'ams_attribute',
                p_creation_date,
                p_creation_user,
                P_creation_ip,
                p_context_id
        );

        insert into ams_attribute_items
                (attribute_id,ams_attribute_id,widget,dynamic_p,deprecated_p)
        values
                (p_attribute_id,v_ams_attribute_id,p_widget,p_dynamic_p,p_deprecated_p);

        return v_ams_attribute_id;
end;$_$;


ALTER FUNCTION public.ams_attribute__new(integer, integer, character varying, boolean, boolean, timestamp with time zone, integer, character varying, integer) OWNER TO evex;

--
-- Name: ams_attribute_value__save(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_attribute_value__save(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_object_id                  alias for $1;
        p_attribute_id               alias for $2;
        p_value_id                   alias for $3;
        v_count                      integer;
begin

        delete from ams_attribute_values
         where object_id = p_object_id
           and attribute_id = p_attribute_id; 

	if p_value_id is not null then
                insert into ams_attribute_values
                (object_id,attribute_id,value_id)
                values
                (p_object_id,p_attribute_id,p_value_id);
	end if;

        return 0;
end;$_$;


ALTER FUNCTION public.ams_attribute_value__save(integer, integer, integer) OWNER TO evex;

--
-- Name: ams_attribute_value__value(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_attribute_value__value(integer, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  p_attribute_id           alias for $1;
  p_value_id               alias for $2;  
  v_value_method           varchar; 
  v_value                  text;
  val                      record;
begin

  v_value_method := value_method
       from ams_widgets
      where widget = ( select widget
                         from ams_attributes
                        where attribute_id = p_attribute_id );

  if v_value_method != '' and v_value_method is NOT null then
    for val in execute 'select ' || v_value_method || '(' || p_value_id || ')::text as value' loop
        v_value := val.value;
        exit;
    end loop;
  end if;

  return v_value;
  
end;$_$;


ALTER FUNCTION public.ams_attribute_value__value(integer, integer) OWNER TO evex;

--
-- Name: ams_attribute_value__value_by_object_id(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_attribute_value__value_by_object_id(integer, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
  p_attribute_id           alias for $1;
  p_object_id              alias for $2;  
  v_value                  text;
begin
  v_value := ams_attribute_value__value(p_attribute_id,( select aav.value_id from ams_attribute_values aav where aav.object_id = p_object_id and aav.attribute_id = p_attribute_id));

  return v_value;
end;$_$;


ALTER FUNCTION public.ams_attribute_value__value_by_object_id(integer, integer) OWNER TO evex;

--
-- Name: ams_list__attribute_map(integer, integer, integer, boolean, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_list__attribute_map(integer, integer, integer, boolean, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_list_id            alias for $1;
        p_attribute_id       alias for $2;
        p_sort_order         alias for $3;
        p_required_p         alias for $4;
        p_section_heading    alias for $5;
        v_sort_order         integer;
begin

        if p_sort_order is null then
           v_sort_order := nextval from acs_object_id_seq;
        else
           v_sort_order := p_sort_order;
        end if;

        delete from ams_list_attribute_map
         where attribute_id = p_attribute_id
           and list_id = p_list_id;

        insert into ams_list_attribute_map
                (list_id,attribute_id,sort_order,required_p,section_heading)
        values
                (p_list_id,p_attribute_id,v_sort_order,p_required_p,p_section_heading);

        return '1';
end;$_$;


ALTER FUNCTION public.ams_list__attribute_map(integer, integer, integer, boolean, character varying) OWNER TO evex;

--
-- Name: ams_list__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_list__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
        p_list_id               alias for $1;
        v_name                  varchar;
begin
       v_name := pretty_name from ams_lists where list_id = p_list_id;

       return v_name;
end;$_$;


ALTER FUNCTION public.ams_list__name(integer) OWNER TO evex;

--
-- Name: ams_list__new(integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_list__new(integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_list_id               alias for $1;
        p_package_key           alias for $2;
        p_object_type           alias for $3;
        p_list_name             alias for $4;
        p_pretty_name           alias for $5;
        p_description           alias for $6;
        p_description_mime_type alias for $7;
        p_creation_date         alias for $8;
        p_creation_user         alias for $9;
        p_creation_ip           alias for $10;
        p_context_id            alias for $11;
        v_list_id               integer;
begin

        v_list_id := acs_object__new (
                p_list_id,
                'ams_list',
                p_creation_date,
                p_creation_user,
                P_creation_ip,
                p_context_id
        );

        insert into ams_lists
        (list_id,package_key,object_type,list_name,pretty_name,description,description_mime_type)
        values
        (v_list_id,p_package_key,p_object_type,p_list_name,p_pretty_name,p_description,p_description_mime_type);

        return v_list_id;
end;$_$;


ALTER FUNCTION public.ams_list__new(integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer) OWNER TO evex;

--
-- Name: ams_option__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_option__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_option_id             alias for $1;
begin
        delete from ams_options where object_id = p_option_id;
        PERFORM acs_object__delete (
                        p_option_id
                );

        return 0;
end;$_$;


ALTER FUNCTION public.ams_option__delete(integer) OWNER TO evex;

--
-- Name: ams_option__map(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_option__map(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_value_id              alias for $1;
        p_option_id             alias for $2;
        v_value_id              integer;
        v_count                 integer;
begin
        v_count := count(*) from ams_options where value_id = p_value_id;

        if v_count = '0' or p_value_id is null then
                v_value_id := nextval from acs_object_id_seq;
                insert into ams_option_ids(value_id) values (v_value_id);
        else 
                v_value_id := p_value_id;
        end if;

        insert into ams_options
        (value_id,option_id)
        values
        (v_value_id,p_option_id);

        return v_value_id;
end;$_$;


ALTER FUNCTION public.ams_option__map(integer, integer) OWNER TO evex;

--
-- Name: ams_option__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_option__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
        p_option_id         alias for $1;
        v_name              varchar;
begin
        v_name := option
             from ams_option_types
            where option_id = p_option_id;

        return v_name;
end;$_$;


ALTER FUNCTION public.ams_option__name(integer) OWNER TO evex;

--
-- Name: ams_option__new(integer, integer, character varying, integer, boolean, timestamp with time zone, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_option__new(integer, integer, character varying, integer, boolean, timestamp with time zone, integer, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_option_id             alias for $1;
        p_attribute_id          alias for $2;
        p_option                alias for $3;
        p_sort_order            alias for $4;
        p_deprecated_p          alias for $5;
        p_creation_date         alias for $6;
        p_creation_user         alias for $7;
        p_creation_ip           alias for $8;
        p_context_id            alias for $9;
        p_pretty_name           alias for $10;
        v_option_id             integer;
        v_sort_order            integer;
begin

        v_option_id := acs_object__new (
                p_option_id,
                'ams_option',
                p_creation_date,
                p_creation_user,
                P_creation_ip,
                p_context_id,
		't',
		p_pretty_name
        );

        if p_sort_order is null then
                v_sort_order := v_option_id;
        else
                v_sort_order := p_sort_order;
        end if;

        insert into ams_option_types
        (option_id,attribute_id,option,sort_order,deprecated_p)
        values
        (v_option_id,p_attribute_id,p_option,v_sort_order,p_deprecated_p);

        return v_option_id;
end;$_$;


ALTER FUNCTION public.ams_option__new(integer, integer, character varying, integer, boolean, timestamp with time zone, integer, character varying, integer, character varying) OWNER TO evex;

--
-- Name: ams_util__next_instance_of_date(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_util__next_instance_of_date(timestamp with time zone) RETURNS date
    LANGUAGE plpgsql
    AS $_$
declare
        p_date          alias for $1;
        v_years         integer;
        v_next_instance date;
begin

    v_years := extract(year from now()) - extract(year from p_date);

    v_next_instance := p_date + (v_years::varchar || ' years')::interval;

    -- if this already happend we and one more year
    if v_next_instance::date < now()::date then
        v_next_instance := v_next_instance + '1 year'::interval;
    end if;

    return v_next_instance;
end;$_$;


ALTER FUNCTION public.ams_util__next_instance_of_date(timestamp with time zone) OWNER TO evex;

--
-- Name: ams_value__asses(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__asses(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_ams_value__options    alias for $1;
        v_value_id              integer;
begin

        v_value_id := value_id
          from ams_options_ids
         where ams_value__options(value_id) = p_ams_value__options;

        return v_value_id;
end;$_$;


ALTER FUNCTION public.ams_value__asses(text) OWNER TO evex;

--
-- Name: ams_value__number(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__number(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        p_value_id    alias for $1;
        v_value       text;
begin
        v_value := number::text from ams_numbers where value_id = p_value_id;
        return v_value;
end;$_$;


ALTER FUNCTION public.ams_value__number(integer) OWNER TO evex;

--
-- Name: ams_value__number_save(numeric); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__number_save(numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_number        alias for $1;
        v_value_id      integer;
begin

	v_value_id :=  value_id
                        from ams_numbers
                       where number = p_number;

        if v_value_id is null then
                v_value_id := nextval from acs_object_id_seq;
                insert into ams_numbers
                (value_id,number) 
                values
                (v_value_id,p_number);
        end if;

        return v_value_id;
end;$_$;


ALTER FUNCTION public.ams_value__number_save(numeric) OWNER TO evex;

--
-- Name: ams_value__options(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__options(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        p_value_id    alias for $1;
        v_name             text;
        rec                RECORD;
begin

        v_name := NULL;
        if p_value_id is not null then
                FOR rec IN 
                        select option_id 
                          from ams_options
                         where value_id = p_value_id
                         order by option_id
                LOOP
                        IF v_name is null THEN
                                v_name := rec.option_id;
                        ELSE
                                v_name := v_name || ' ' || rec.option_id;
                        END IF;
                END LOOP;
        end if;

        return v_name;
end;$_$;


ALTER FUNCTION public.ams_value__options(integer) OWNER TO evex;

--
-- Name: ams_value__postal_address(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__postal_address(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        p_address_id    alias for $1;
        v_name          text;
begin

        if p_address_id is not null then
                v_name :=  '{' || 
                           CASE WHEN delivery_address is not null THEN delivery_address ELSE '' END || '} {' || 
                           CASE WHEN municipality is not null THEN municipality ELSE '' END || '} {' || 
                           CASE WHEN region is not null THEN region ELSE '' END  || '} {' || 
                           CASE WHEN postal_code is not null THEN postal_code ELSE '' END  || '} {' ||
                           CASE WHEN country_code::varchar is not null THEN country_code::varchar ELSE '' END  || '} {' ||
                           CASE WHEN additional_text is not null THEN additional_text ELSE '' END || '} {' ||
                           CASE WHEN postal_type::text is not null THEN postal_type::text ELSE '' END || '}'
                      from postal_addresses
                     where address_id = p_address_id;
        else
                v_name := NULL;
        end if;

        return v_name;
end;$_$;


ALTER FUNCTION public.ams_value__postal_address(integer) OWNER TO evex;

--
-- Name: ams_value__postal_address_save(character varying, character varying, character varying, character varying, character, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__postal_address_save(character varying, character varying, character varying, character varying, character, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
        p_delivery_address     alias for $1;
        p_municipality         alias for $2;
        p_region               alias for $3;
        p_postal_code          alias for $4;
        p_country_code         alias for $5;
        p_additional_text      alias for $6;
        p_postal_type          alias for $7;
        v_address_id           integer;
begin 

        if p_additional_text is null and p_postal_type is null then

	v_address_id := address_id
                        from postal_addresses
                       where delivery_address = p_delivery_address
                         and municipality = p_municipality
                         and region = p_region
                         and postal_code = p_postal_code
                         and country_code = p_country_code
                         and additional_text is NULL
                         and postal_type is NULL
                       limit 1;

        else 

	v_address_id := address_id
                        from postal_addresses
                       where delivery_address = p_delivery_address
                         and municipality = p_municipality
                         and region = p_region
                         and postal_code = p_postal_code
                         and country_code = p_country_code
                         and additional_text = p_additional_text
                         and postal_type = p_postal_type
                       limit 1;
        
        end if;

        if v_address_id is null then

                v_address_id := acs_object__new (  
	                null,  
	                'postal_address',
	                now(), 
	                NULL, 
	                NULL,
	                NULL
	        );
	
	        insert into postal_addresses 
	        ( address_id, delivery_address, municipality, region, postal_code, country_code, additional_text, postal_type )  
	        values
	        ( v_address_id, p_delivery_address, p_municipality, p_region, p_postal_code, p_country_code, p_additional_text, p_postal_type );
	
	end if;

        return v_address_id;
end;$_$;


ALTER FUNCTION public.ams_value__postal_address_save(character varying, character varying, character varying, character varying, character, character varying, integer) OWNER TO evex;

--
-- Name: ams_value__telecom_number(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__telecom_number(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        p_number_id     alias for $1;
        v_name          text;
begin

        if p_number_id is not null then
                v_name :=  '{' || 
                  CASE WHEN itu_id::text is not null THEN itu_id::text ELSE '' END || '} {' || 
                  CASE WHEN national_number is not null THEN national_number ELSE '' END || '} {' || 
                  CASE WHEN area_city_code is not null THEN area_city_code ELSE '' END  || '} {' || 
                  CASE WHEN subscriber_number is not null THEN subscriber_number ELSE '' END  || '} {' ||
                  CASE WHEN extension is not null THEN extension ELSE '' END  || '} {' ||
                  CASE WHEN sms_enabled_p is not null THEN CASE WHEN sms_enabled_p THEN '1' ELSE '0' END ELSE '' END || '} {' ||
                  CASE WHEN best_contact_time is not null THEN best_contact_time ELSE '' END || '} {' ||
                  CASE WHEN location is not null THEN location ELSE '' END || '} {' ||
                  CASE WHEN phone_type_id::text is not null THEN phone_type_id::text ELSE '' END || '}'
             from telecom_numbers
             where number_id = p_number_id;
        else
                v_name := NULL;
        end if;

        return v_name;
end;$_$;


ALTER FUNCTION public.ams_value__telecom_number(integer) OWNER TO evex;

--
-- Name: ams_value__telecom_number_save(integer, character varying, character varying, character varying, character varying, boolean, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__telecom_number_save(integer, character varying, character varying, character varying, character varying, boolean, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare 
        p_itu_id               alias for $1;
        p_national_number      alias for $2;
        p_area_city_code       alias for $3;
        p_subscriber_number    alias for $4;
        p_extension            alias for $5;
        p_sms_enabled_p        alias for $6;
        p_best_contact_time    alias for $7;
        p_location             alias for $8;
        p_phone_type_id        alias for $9;
        v_number_id            integer;
begin 

	v_number_id := number_id
                        from telecom_numbers
                       where itu_id = p_itu_id
                         and national_number = p_national_number
                         and area_city_code = p_area_city_code
                         and subscriber_number = p_subscriber_number
                         and extension = p_extension
                         and sms_enabled_p = p_sms_enabled_p
                         and best_contact_time = p_best_contact_time
                         and location = p_location
                         and p_phone_type_id = p_phone_type_id;

        if v_number_id is null then

                v_number_id := acs_object__new (  
	                null,  
	                'telecom_number',
	                now(), 
	                NULL, 
	                NULL,
	                NULL
	        );
	
	        insert into telecom_numbers 
	        ( number_id, itu_id, national_number, area_city_code, subscriber_number, extension, sms_enabled_p, best_contact_time, location, phone_type_id )
	        values
                ( v_number_id, p_itu_id, p_national_number, p_area_city_code, p_subscriber_number, p_extension, p_sms_enabled_p, p_best_contact_time, p_location, p_phone_type_id);

	end if;

        return v_number_id;
end;$_$;


ALTER FUNCTION public.ams_value__telecom_number_save(integer, character varying, character varying, character varying, character varying, boolean, character varying, character varying, integer) OWNER TO evex;

--
-- Name: ams_value__text(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__text(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
        p_value_id    alias for $1;
        v_value       text;
begin
        v_value := '{' || text_format::text || '} ' || text from ams_texts where value_id = p_value_id;
        return v_value;
end;$_$;


ALTER FUNCTION public.ams_value__text(integer) OWNER TO evex;

--
-- Name: ams_value__text_save(text, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__text_save(text, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_text          alias for $1;
        p_text_format   alias for $2;
        v_value_id      integer;
begin

	v_value_id := value_id
                        from ams_texts
                       where text = p_text
                         and text_format = p_text_format;

        if v_value_id is null then
                v_value_id := nextval from acs_object_id_seq;
                insert into ams_texts
                (value_id,text,text_format) 
                values
                (v_value_id,p_text,p_text_format);
        end if;

        return v_value_id;
end;$_$;


ALTER FUNCTION public.ams_value__text_save(text, character varying) OWNER TO evex;

--
-- Name: ams_value__time(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__time(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
        p_value_id    alias for $1;
        v_value       text;
begin
        v_value := to_char(time,'YYYY-MM-DD HH24:MI:SS TZ')::text from ams_times where value_id = p_value_id;
        return v_value;
end;$_$;


ALTER FUNCTION public.ams_value__time(integer) OWNER TO evex;

--
-- Name: ams_value__time_save(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_value__time_save(timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_time          alias for $1;
        v_value_id      integer;
begin

	v_value_id := value_id
                        from ams_times
                       where time = p_time;

        if v_value_id is null then
                v_value_id := nextval from acs_object_id_seq;
                insert into ams_times
                (value_id,time) 
                values
                (v_value_id,p_time);
        end if;

        return v_value_id;
end;$_$;


ALTER FUNCTION public.ams_value__time_save(timestamp with time zone) OWNER TO evex;

--
-- Name: ams_widget__save(character varying, character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ams_widget__save(character varying, character varying, character varying, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_widget             alias for $1;
        p_pretty_name        alias for $2;
        p_value_method       alias for $3;
        p_active_p           alias for $4;
        v_exists_p           boolean;
begin
	v_exists_p := '1' from ams_widgets where widget = p_widget;

        if v_exists_p then

         	update ams_widgets
                   set pretty_name = p_pretty_name,
                       value_method = p_value_method,
                       active_p = p_active_p
                 where widget = p_widget;        

        else
                insert into ams_widgets 
                (widget,pretty_name,value_method,active_p)
                values
                (p_widget,p_pretty_name,p_value_method,p_active_p);
	end if;

        return '1';
end;$_$;


ALTER FUNCTION public.ams_widget__save(character varying, character varying, character varying, boolean) OWNER TO evex;

--
-- Name: apm__get_value(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__get_value(get_value__package_id integer, get_value__parameter_name character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_parameter_id                    apm_parameter_values.parameter_id%TYPE;
  value                             apm_parameter_values.attr_value%TYPE;
BEGIN
    v_parameter_id := apm__id_for_name (get_value__package_id, get_value__parameter_name);

    select attr_value into value from apm_parameter_values v
    where v.package_id = get_value__package_id
    and parameter_id = v_parameter_id;

    return value;
   
END;
$$;


ALTER FUNCTION public.apm__get_value(get_value__package_id integer, get_value__parameter_name character varying) OWNER TO evex;

--
-- Name: apm__get_value(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__get_value(get_value__package_key character varying, get_value__parameter_name character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_parameter_id                    apm_parameter_values.parameter_id%TYPE;
  value                             apm_parameter_values.attr_value%TYPE;
BEGIN
    v_parameter_id := apm__id_for_name (get_value__package_key, get_value__parameter_name);

    select attr_value into value from apm_parameter_values v
    where v.package_id is null
    and parameter_id = v_parameter_id;

    return value;
   
END;
$$;


ALTER FUNCTION public.apm__get_value(get_value__package_key character varying, get_value__parameter_name character varying) OWNER TO evex;

--
-- Name: apm__id_for_name(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__id_for_name(id_for_name__package_id integer, id_for_name__parameter_name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  a_parameter_id                      apm_parameters.parameter_id%TYPE;
BEGIN
    select parameter_id into a_parameter_id 
    from apm_parameters 
    where parameter_name = id_for_name__parameter_name
      and package_key = (select package_key from apm_packages
                         where package_id = id_for_name__package_id);

    if NOT FOUND
      then
      	raise EXCEPTION '-20000: The specified package % AND/OR parameter % do not exist in the system', id_for_name__package_id, id_for_name__parameter_name;
    end if;

    return a_parameter_id;
   
END;
$$;


ALTER FUNCTION public.apm__id_for_name(id_for_name__package_id integer, id_for_name__parameter_name character varying) OWNER TO evex;

--
-- Name: apm__id_for_name(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__id_for_name(id_for_name__package_key character varying, id_for_name__parameter_name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  a_parameter_id                      apm_parameters.parameter_id%TYPE;
BEGIN
    select parameter_id into a_parameter_id
    from apm_parameters p
    where p.parameter_name = id_for_name__parameter_name and
          p.package_key = id_for_name__package_key;

    if NOT FOUND
      then
      	raise EXCEPTION '-20000: The specified package % AND/OR parameter % do not exist in the system', id_for_name__package_key, id_for_name__parameter_name;
    end if;

    return a_parameter_id;
   
END;
$$;


ALTER FUNCTION public.apm__id_for_name(id_for_name__package_key character varying, id_for_name__parameter_name character varying) OWNER TO evex;

--
-- Name: apm__parameter_p(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__parameter_p(parameter_p__package_key character varying, parameter_p__parameter_name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_parameter_p                       integer;       
BEGIN
    select case when count(*) = 0 then 0 else 1 end into v_parameter_p 
    from apm_parameters
    where package_key = parameter_p__package_key
    and parameter_name = parameter_p__parameter_name;

    return v_parameter_p;
   
END;
$$;


ALTER FUNCTION public.apm__parameter_p(parameter_p__package_key character varying, parameter_p__parameter_name character varying) OWNER TO evex;

--
-- Name: apm__register_application(character varying, character varying, character varying, character varying, boolean, boolean, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__register_application(package_key character varying, pretty_name character varying, pretty_plural character varying, package_uri character varying, initial_install_p boolean, singleton_p boolean, implements_subsite_p boolean, inherit_templates_p boolean, spec_file_path character varying, spec_file_mtime integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
   PERFORM apm__register_package(
	package_key,
	pretty_name,
	pretty_plural,
	package_uri,
	'apm_application',
	initial_install_p,
	singleton_p,
        implements_subsite_p,
        inherit_templates_p,
	spec_file_path,
	spec_file_mtime
   ); 

   return 0; 
END;
$$;


ALTER FUNCTION public.apm__register_application(package_key character varying, pretty_name character varying, pretty_plural character varying, package_uri character varying, initial_install_p boolean, singleton_p boolean, implements_subsite_p boolean, inherit_templates_p boolean, spec_file_path character varying, spec_file_mtime integer) OWNER TO evex;

--
-- Name: apm__register_p(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__register_p(register_p__package_key character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_register_p                       integer;       
BEGIN
    select case when count(*) = 0 then 0 else 1 end into v_register_p 
    from apm_package_types 
    where package_key = register_p__package_key;

    return v_register_p;
   
END;
$$;


ALTER FUNCTION public.apm__register_p(register_p__package_key character varying) OWNER TO evex;

--
-- Name: apm__register_package(character varying, character varying, character varying, character varying, character varying, boolean, boolean, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__register_package(package_key character varying, pretty_name character varying, pretty_plural character varying, package_uri character varying, package_type character varying, initial_install_p boolean, singleton_p boolean, implements_subsite_p boolean, inherit_templates_p boolean, spec_file_path character varying, spec_file_mtime integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    PERFORM apm_package_type__create_type(
    	package_key,
	pretty_name,
	pretty_plural,
	package_uri,
	package_type,
	initial_install_p,
	singleton_p,
        implements_subsite_p,
        inherit_templates_p,
	spec_file_path,
	spec_file_mtime
    );

    return 0; 
END;
$$;


ALTER FUNCTION public.apm__register_package(package_key character varying, pretty_name character varying, pretty_plural character varying, package_uri character varying, package_type character varying, initial_install_p boolean, singleton_p boolean, implements_subsite_p boolean, inherit_templates_p boolean, spec_file_path character varying, spec_file_mtime integer) OWNER TO evex;

--
-- Name: apm__register_parameter(integer, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__register_parameter(register_parameter__parameter_id integer, register_parameter__package_key character varying, register_parameter__parameter_name character varying, register_parameter__description character varying, register_parameter__datatype character varying, register_parameter__default_value character varying, register_parameter__section_name character varying, register_parameter__min_n_values integer, register_parameter__max_n_values integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
  return
    apm__register_parameter(register_parameter__parameter_id, register_parameter__package_key,
                           register_parameter__parameter_name, register_parameter__description,
                           'instance',  register_parameter__datatype,
                           register_parameter__default_value, register_parameter__section_name,
                           register_parameter__min_n_values, register_parameter__max_n_values);
END;
$$;


ALTER FUNCTION public.apm__register_parameter(register_parameter__parameter_id integer, register_parameter__package_key character varying, register_parameter__parameter_name character varying, register_parameter__description character varying, register_parameter__datatype character varying, register_parameter__default_value character varying, register_parameter__section_name character varying, register_parameter__min_n_values integer, register_parameter__max_n_values integer) OWNER TO evex;

--
-- Name: apm__register_parameter(integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__register_parameter(register_parameter__parameter_id integer, register_parameter__package_key character varying, register_parameter__parameter_name character varying, register_parameter__description character varying, register_parameter__scope character varying, register_parameter__datatype character varying, register_parameter__default_value character varying, register_parameter__section_name character varying, register_parameter__min_n_values integer, register_parameter__max_n_values integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

  v_parameter_id         apm_parameters.parameter_id%TYPE;
  v_value_id             apm_parameter_values.value_id%TYPE;
  v_pkg                  record;

BEGIN
    -- Create the new parameter.    
    v_parameter_id := acs_object__new(
       register_parameter__parameter_id,
       'apm_parameter',
       now(),
       null,
       null,
       null,
       't',
       register_parameter__package_key || ' - ' || register_parameter__parameter_name,
       null
    );
    
    insert into apm_parameters 
    (parameter_id, parameter_name, scope, description, package_key, datatype, 
    default_value, section_name, min_n_values, max_n_values)
    values
    (v_parameter_id, register_parameter__parameter_name, register_parameter__scope,
     register_parameter__description, register_parameter__package_key, 
     register_parameter__datatype, register_parameter__default_value, 
     register_parameter__section_name, register_parameter__min_n_values, 
     register_parameter__max_n_values);

    -- Propagate parameter to new instances.	
    if register_parameter__scope = 'instance' then
      for v_pkg in
          select package_id
  	from apm_packages
  	where package_key = register_parameter__package_key
        loop
          v_value_id := apm_parameter_value__new(
  	    null,
  	    v_pkg.package_id,
  	    v_parameter_id, 
  	    register_parameter__default_value); 	
        end loop;		
     else
       v_value_id := apm_parameter_value__new(
  	 null,
  	 null,
  	 v_parameter_id, 
  	 register_parameter__default_value); 	
     end if;
	
    return v_parameter_id;
   
END;
$$;


ALTER FUNCTION public.apm__register_parameter(register_parameter__parameter_id integer, register_parameter__package_key character varying, register_parameter__parameter_name character varying, register_parameter__description character varying, register_parameter__scope character varying, register_parameter__datatype character varying, register_parameter__default_value character varying, register_parameter__section_name character varying, register_parameter__min_n_values integer, register_parameter__max_n_values integer) OWNER TO evex;

--
-- Name: apm__register_service(character varying, character varying, character varying, character varying, boolean, boolean, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__register_service(package_key character varying, pretty_name character varying, pretty_plural character varying, package_uri character varying, initial_install_p boolean, singleton_p boolean, implements_subsite_p boolean, inherit_templates_p boolean, spec_file_path character varying, spec_file_mtime integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
   PERFORM apm__register_package(
	package_key,
	pretty_name,
	pretty_plural,
	package_uri,
	'apm_service',
	initial_install_p,
	singleton_p,
        implements_subsite_p,
        inherit_templates_p,
	spec_file_path,
	spec_file_mtime
   );  
 
   return 0; 
END;
$$;


ALTER FUNCTION public.apm__register_service(package_key character varying, pretty_name character varying, pretty_plural character varying, package_uri character varying, initial_install_p boolean, singleton_p boolean, implements_subsite_p boolean, inherit_templates_p boolean, spec_file_path character varying, spec_file_mtime integer) OWNER TO evex;

--
-- Name: apm__set_value(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__set_value(set_value__package_id integer, set_value__parameter_name character varying, set_value__attr_value character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_parameter_id                    apm_parameter_values.parameter_id%TYPE;
  v_value_id                        apm_parameter_values.value_id%TYPE;
BEGIN
    v_parameter_id := apm__id_for_name (set_value__package_id, set_value__parameter_name);

    -- Determine if the value exists
    select value_id into v_value_id from apm_parameter_values 
     where parameter_id = v_parameter_id 
     and package_id = set_value__package_id;
    update apm_parameter_values set attr_value = set_value__attr_value
     where value_id = v_value_id;
    update acs_objects set last_modified = now() 
     where object_id = v_value_id;
   --  exception 
     if NOT FOUND
       then
         v_value_id := apm_parameter_value__new(
            null,
            set_value__package_id,
            v_parameter_id,
            set_value__attr_value
         );
     end if;

    return 0; 
END;
$$;


ALTER FUNCTION public.apm__set_value(set_value__package_id integer, set_value__parameter_name character varying, set_value__attr_value character varying) OWNER TO evex;

--
-- Name: apm__set_value(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__set_value(set_value__package_key character varying, set_value__parameter_name character varying, set_value__attr_value character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_parameter_id                    apm_parameter_values.parameter_id%TYPE;
  v_value_id                        apm_parameter_values.value_id%TYPE;
BEGIN
    v_parameter_id := apm__id_for_name (set_value__package_key, set_value__parameter_name);

    -- Determine if the value exists
    select value_id into v_value_id from apm_parameter_values 
     where parameter_id = v_parameter_id 
     and package_id is null;
    update apm_parameter_values set attr_value = set_value__attr_value
     where value_id = v_value_id;
    update acs_objects set last_modified = now() 
     where object_id = v_value_id;
   --  exception 
     if NOT FOUND
       then
         v_value_id := apm_parameter_value__new(
            null,
            null,
            v_parameter_id,
            set_value__attr_value
         );
     end if;

    return 0; 
END;
$$;


ALTER FUNCTION public.apm__set_value(set_value__package_key character varying, set_value__parameter_name character varying, set_value__attr_value character varying) OWNER TO evex;

--
-- Name: apm__unregister_application(character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__unregister_application(package_key character varying, p_cascade_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_cascade_p            boolean;
BEGIN
   if p_cascade_p is null then 
	v_cascade_p := 'f';
   else 
       v_cascade_p := p_cascade_p;
   end if;

   PERFORM apm__unregister_package (
        package_key,
        v_cascade_p
   );

   return 0; 
END;
$$;


ALTER FUNCTION public.apm__unregister_application(package_key character varying, p_cascade_p boolean) OWNER TO evex;

--
-- Name: apm__unregister_package(character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__unregister_package(package_key character varying, p_cascade_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_cascade_p            boolean;
BEGIN
   if cascade_p is null then 
	v_cascade_p := 't';
   else 
       v_cascade_p := p_cascade_p;
   end if;

   PERFORM apm_package_type__drop_type(
	package_key,
	v_cascade_p
   );

   return 0; 
END;
$$;


ALTER FUNCTION public.apm__unregister_package(package_key character varying, p_cascade_p boolean) OWNER TO evex;

--
-- Name: apm__unregister_parameter(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__unregister_parameter(unregister_parameter__parameter_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from apm_parameter_values 
    where parameter_id = unregister_parameter__parameter_id;
    delete from apm_parameters 
    where parameter_id = unregister_parameter__parameter_id;
    PERFORM acs_object__delete(unregister_parameter__parameter_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.apm__unregister_parameter(unregister_parameter__parameter_id integer) OWNER TO evex;

--
-- Name: apm__unregister_service(character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__unregister_service(package_key character varying, p_cascade_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_cascade_p           boolean;
BEGIN
   if p_cascade_p is null then 
	v_cascade_p := 'f';
   else 
	v_cascade_p := p_cascade_p;
   end if;

   PERFORM apm__unregister_package (
	package_key,
	v_cascade_p
   );

   return 0; 
END;
$$;


ALTER FUNCTION public.apm__unregister_service(package_key character varying, p_cascade_p boolean) OWNER TO evex;

--
-- Name: apm__update_package(character varying, character varying, character varying, character varying, character varying, boolean, boolean, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__update_package(package_key character varying, pretty_name character varying, pretty_plural character varying, package_uri character varying, package_type character varying, initial_install_p boolean, singleton_p boolean, implements_subsite_p boolean, inherit_templates_p boolean, spec_file_path character varying, spec_file_mtime integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
 
    return apm_package_type__update_type(
    	package_key,
	pretty_name,
	pretty_plural,
	package_uri,
	package_type,
	initial_install_p,
	singleton_p,
        implements_subsite_p,
        inherit_templates_p,
	spec_file_path,
	spec_file_mtime
    );
END;
$$;


ALTER FUNCTION public.apm__update_package(package_key character varying, pretty_name character varying, pretty_plural character varying, package_uri character varying, package_type character varying, initial_install_p boolean, singleton_p boolean, implements_subsite_p boolean, inherit_templates_p boolean, spec_file_path character varying, spec_file_mtime integer) OWNER TO evex;

--
-- Name: apm__update_parameter(integer, character varying, character varying, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm__update_parameter(update_parameter__parameter_id integer, update_parameter__parameter_name character varying, update_parameter__description character varying, update_parameter__datatype character varying, update_parameter__default_value character varying, update_parameter__section_name character varying, update_parameter__min_n_values integer, update_parameter__max_n_values integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update apm_parameters 
	set parameter_name = coalesce(update_parameter__parameter_name, parameter_name),
            default_value  = coalesce(update_parameter__default_value, default_value),
            datatype       = coalesce(update_parameter__datatype, datatype), 
	    description	   = coalesce(update_parameter__description, description),
	    section_name   = coalesce(update_parameter__section_name, section_name),
            min_n_values   = coalesce(update_parameter__min_n_values, min_n_values),
            max_n_values   = coalesce(update_parameter__max_n_values, max_n_values)
      where parameter_id = update_parameter__parameter_id;

    update acs_objects
       set title = (select package_key || ': Parameter ' || parameter_name
                    from apm_parameters
                    where parameter_id = update_parameter__parameter_id)
     where object_id = update_parameter__parameter_id;

    return parameter_id;
     
END;
$$;


ALTER FUNCTION public.apm__update_parameter(update_parameter__parameter_id integer, update_parameter__parameter_name character varying, update_parameter__description character varying, update_parameter__datatype character varying, update_parameter__default_value character varying, update_parameter__section_name character varying, update_parameter__min_n_values integer, update_parameter__max_n_values integer) OWNER TO evex;

--
-- Name: apm_application__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_application__delete(delete__application_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from apm_applications
    where application_id = delete__application_id;
    PERFORM apm_package__delete(
        delete__application_id
    );

    return 0; 
END;
$$;


ALTER FUNCTION public.apm_application__delete(delete__application_id integer) OWNER TO evex;

--
-- Name: apm_application__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_application__new(application_id integer, instance_name character varying, package_key character varying, object_type character varying, creation_date timestamp with time zone, creation_user integer, creation_ip character varying, context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_application_id       integer;       
BEGIN
    v_application_id := apm_package__new (
      application_id,
      instance_name,
      package_key,
      object_type,
      creation_date,
      creation_user,
      creation_ip,
      context_id
    );

    return v_application_id;
   
END;
$$;


ALTER FUNCTION public.apm_application__new(application_id integer, instance_name character varying, package_key character varying, object_type character varying, creation_date timestamp with time zone, creation_user integer, creation_ip character varying, context_id integer) OWNER TO evex;

--
-- Name: apm_package__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__delete(delete__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
   cur_val              record;
   v_folder_row         record;
BEGIN
    -- Delete all parameters.
    for cur_val in select value_id from apm_parameter_values
	where package_id = delete__package_id loop
    	PERFORM apm_parameter_value__delete(cur_val.value_id);
    end loop;    

   -- Delete the folders
    for v_folder_row in select
        folder_id
        from cr_folders
        where package_id = delete__package_id
    loop
        perform content_folder__del(v_folder_row.folder_id,'t');
    end loop;

    delete from apm_applications where application_id = delete__package_id;
    delete from apm_services where service_id = delete__package_id;
    delete from apm_packages where package_id = delete__package_id;
    -- Delete the site nodes for the objects.
    for cur_val in select node_id from site_nodes
	where object_id = delete__package_id loop
    	PERFORM site_node__delete(cur_val.node_id);
    end loop;

    -- Delete the object.
    PERFORM acs_object__delete (
       delete__package_id
    );   

    return 0;
END;
$$;


ALTER FUNCTION public.apm_package__delete(delete__package_id integer) OWNER TO evex;

--
-- Name: apm_package__highest_version(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__highest_version(highest_version__package_key character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
     v_version_id                    apm_package_versions.version_id%TYPE;
     v_max_version                   varchar;
BEGIN
     select max(apm_package_version__sortable_version_name(v.version_name)) into v_max_version 
       from apm_package_version_info v where v.package_key = highest_version__package_key;

     select version_id into v_version_id from apm_package_version_info i 
	where apm_package_version__sortable_version_name(version_name) = v_max_version and i.package_key = highest_version__package_key;

      if NOT FOUND then 
         return 0;
      else
         return v_version_id;
      end if;
END;
$$;


ALTER FUNCTION public.apm_package__highest_version(highest_version__package_key character varying) OWNER TO evex;

--
-- Name: apm_package__initial_install_p(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__initial_install_p(initial_install_p__package_key character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
        v_initial_install_p             integer;
BEGIN
        select 1 into v_initial_install_p
	from apm_package_types
	where package_key = initial_install_p__package_key
        and initial_install_p = 't';
	
        if NOT FOUND then 
           return 0;
        else
           return v_initial_install_p;
        end if;
END;
$$;


ALTER FUNCTION public.apm_package__initial_install_p(initial_install_p__package_key character varying) OWNER TO evex;

--
-- Name: apm_package__initialize_parameters(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__initialize_parameters(ip__package_id integer, ip__package_key character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_value_id                 apm_parameter_values.value_id%TYPE;
  cur_val                    record;
BEGIN
    -- need to initialize all params for this type
    for cur_val in select parameter_id, default_value
       from apm_parameters
       where package_key = ip__package_key
         and scope = 'instance'
      loop
        v_value_id := apm_parameter_value__new(
          null,
          ip__package_id,
          cur_val.parameter_id,
          cur_val.default_value
        ); 
      end loop;   

      return 0; 
END;
$$;


ALTER FUNCTION public.apm_package__initialize_parameters(ip__package_id integer, ip__package_key character varying) OWNER TO evex;

--
-- Name: apm_package__is_child(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__is_child(parent_package_key character varying, child_package_key character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  dependency               record;
BEGIN

  if parent_package_key = child_package_key then
    return 't';
  end if;

  for dependency in 
    select apd.service_uri
    from apm_package_versions apv, apm_package_dependencies apd
    where apd.version_id = apv.version_id
      and apv.enabled_p
      and apd.dependency_type in ('embeds', 'extends')
      and apv.package_key = child_package_key
  loop
    if dependency.service_uri = parent_package_key or
      apm_package__is_child(parent_package_key, dependency.service_uri) then
      return 't';
    end if;
  end loop;
      
  return 'f';
END;
$$;


ALTER FUNCTION public.apm_package__is_child(parent_package_key character varying, child_package_key character varying) OWNER TO evex;

--
-- Name: apm_package__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__name(name__package_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_result               apm_packages.instance_name%TYPE;
BEGIN
    select instance_name into v_result
    from apm_packages
    where package_id = name__package_id;

    return v_result;

END;
$$;


ALTER FUNCTION public.apm_package__name(name__package_id integer) OWNER TO evex;

--
-- Name: apm_package__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__new(new__package_id integer, new__instance_name character varying, new__package_key character varying, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_singleton_p               integer;       
  v_package_type              apm_package_types.package_type%TYPE;
  v_num_instances             integer;       
  v_package_id                apm_packages.package_id%TYPE;
  v_instance_name             apm_packages.instance_name%TYPE;
BEGIN
   v_singleton_p := apm_package__singleton_p(
			new__package_key
		    );
   v_num_instances := apm_package__num_instances(
			new__package_key
		    );
  
   if v_singleton_p = 1 and v_num_instances >= 1 then
       select package_id into v_package_id 
       from apm_packages
       where package_key = new__package_key;

       return v_package_id;
   else
       v_package_id := acs_object__new(
          new__package_id,
          new__object_type,
          new__creation_date,
          new__creation_user,
	  new__creation_ip,
	  new__context_id
	 );
       if new__instance_name is null or new__instance_name = '' then 
	 v_instance_name := new__package_key || ' ' || v_package_id;
       else
	 v_instance_name := new__instance_name;
       end if;

       select package_type into v_package_type
       from apm_package_types
       where package_key = new__package_key;

       insert into apm_packages
       (package_id, package_key, instance_name)
       values
       (v_package_id, new__package_key, v_instance_name);

       update acs_objects
       set title = v_instance_name,
           package_id = v_package_id
       where object_id = v_package_id;

       if v_package_type = 'apm_application' then
	   insert into apm_applications
	   (application_id)
	   values
	   (v_package_id);
       else
	   insert into apm_services
	   (service_id)
	   values
	   (v_package_id);
       end if;

       PERFORM apm_package__initialize_parameters(
	   v_package_id,
	   new__package_key
       );

       return v_package_id;

  end if;
END;
$$;


ALTER FUNCTION public.apm_package__new(new__package_id integer, new__instance_name character varying, new__package_key character varying, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__context_id integer) OWNER TO evex;

--
-- Name: apm_package__num_instances(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__num_instances(num_instances__package_key character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
        v_num_instances                integer;
BEGIN
        select count(*) into v_num_instances
	from apm_packages
	where package_key = num_instances__package_key;

        return v_num_instances;

END;
$$;


ALTER FUNCTION public.apm_package__num_instances(num_instances__package_key character varying) OWNER TO evex;

--
-- Name: apm_package__parent_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__parent_id(apm_package__parent_id__package_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    v_package_id apm_packages.package_id%TYPE;
BEGIN
    select sn1.object_id
    into v_package_id
    from site_nodes sn1
    where sn1.node_id = (select sn2.parent_id
                         from site_nodes sn2
                         where sn2.object_id = apm_package__parent_id__package_id);

    return v_package_id;

END;
$$;


ALTER FUNCTION public.apm_package__parent_id(apm_package__parent_id__package_id integer) OWNER TO evex;

--
-- Name: apm_package__singleton_p(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package__singleton_p(singleton_p__package_key character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
        v_singleton_p                   integer;
BEGIN
        select count(*) into v_singleton_p
	from apm_package_types
	where package_key = singleton_p__package_key
        and singleton_p = 't';

        return v_singleton_p;
END;
$$;


ALTER FUNCTION public.apm_package__singleton_p(singleton_p__package_key character varying) OWNER TO evex;

--
-- Name: apm_package_type__create_type(character varying, character varying, character varying, character varying, character varying, boolean, boolean, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_type__create_type(create_type__package_key character varying, create_type__pretty_name character varying, create_type__pretty_plural character varying, create_type__package_uri character varying, create_type__package_type character varying, create_type__initial_install_p boolean, create_type__singleton_p boolean, create_type__implements_subsite_p boolean, create_type__inherit_templates_p boolean, create_type__spec_file_path character varying, create_type__spec_file_mtime integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
   insert into apm_package_types
    (package_key, pretty_name, pretty_plural, package_uri, package_type,
    spec_file_path, spec_file_mtime, initial_install_p, singleton_p,
    implements_subsite_p, inherit_templates_p)
   values
    (create_type__package_key, create_type__pretty_name, create_type__pretty_plural,
     create_type__package_uri, create_type__package_type, create_type__spec_file_path, 
     create_type__spec_file_mtime, create_type__initial_install_p, create_type__singleton_p,
     create_type__implements_subsite_p, create_type__inherit_templates_p);

   return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_type__create_type(create_type__package_key character varying, create_type__pretty_name character varying, create_type__pretty_plural character varying, create_type__package_uri character varying, create_type__package_type character varying, create_type__initial_install_p boolean, create_type__singleton_p boolean, create_type__implements_subsite_p boolean, create_type__inherit_templates_p boolean, create_type__spec_file_path character varying, create_type__spec_file_mtime integer) OWNER TO evex;

--
-- Name: apm_package_type__drop_type(character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_type__drop_type(drop_type__package_key character varying, drop_type__cascade_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  cur_val                           record; 
BEGIN
    if drop_type__cascade_p = 't' then
        for cur_val in select package_id
       from apm_packages
       where package_key = drop_type__package_key
        loop
            PERFORM apm_package__delete(
	        cur_val.package_id
	    );
        end loop;
	-- Unregister all parameters.
        for cur_val in select parameter_id from apm_parameters
       where package_key = drop_type__package_key
	loop
	    PERFORM apm__unregister_parameter(cur_val.parameter_id);
	end loop;
  
        -- Unregister all versions
	for cur_val in select version_id from apm_package_versions
       where package_key = drop_type__package_key
	loop
	    PERFORM apm_package_version__delete(cur_val.version_id);
        end loop;
    end if;
    delete from apm_package_types
    where package_key = drop_type__package_key;

    return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_type__drop_type(drop_type__package_key character varying, drop_type__cascade_p boolean) OWNER TO evex;

--
-- Name: apm_package_type__num_parameters(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_type__num_parameters(num_parameters__package_key character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_count                                integer;       
BEGIN
    select count(*) into v_count
    from apm_parameters
    where package_key = num_parameters__package_key;

    return v_count;
   
END;
$$;


ALTER FUNCTION public.apm_package_type__num_parameters(num_parameters__package_key character varying) OWNER TO evex;

--
-- Name: apm_package_type__update_type(character varying, character varying, character varying, character varying, character varying, boolean, boolean, boolean, boolean, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_type__update_type(update_type__package_key character varying, update_type__pretty_name character varying, update_type__pretty_plural character varying, update_type__package_uri character varying, update_type__package_type character varying, update_type__initial_install_p boolean, update_type__singleton_p boolean, update_type__implements_subsite_p boolean, update_type__inherit_templates_p boolean, update_type__spec_file_path character varying, update_type__spec_file_mtime integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      UPDATE apm_package_types SET
      	pretty_name = coalesce(update_type__pretty_name, pretty_name),
    	pretty_plural = coalesce(update_type__pretty_plural, pretty_plural),
    	package_uri = coalesce(update_type__package_uri, package_uri),
    	package_type = coalesce(update_type__package_type, package_type),
    	spec_file_path = coalesce(update_type__spec_file_path, spec_file_path),
    	spec_file_mtime = coalesce(update_type__spec_file_mtime, spec_file_mtime),
    	singleton_p = coalesce(update_type__singleton_p, singleton_p),
    	initial_install_p = coalesce(update_type__initial_install_p, initial_install_p),
    	implements_subsite_p = coalesce(update_type__implements_subsite_p, implements_subsite_p),
    	inherit_templates_p = coalesce(update_type__inherit_templates_p, inherit_templates_p)
      where package_key = update_type__package_key;

      return update_type__package_key;
   
END;
$$;


ALTER FUNCTION public.apm_package_type__update_type(update_type__package_key character varying, update_type__pretty_name character varying, update_type__pretty_plural character varying, update_type__package_uri character varying, update_type__package_type character varying, update_type__initial_install_p boolean, update_type__singleton_p boolean, update_type__implements_subsite_p boolean, update_type__inherit_templates_p boolean, update_type__spec_file_path character varying, update_type__spec_file_mtime integer) OWNER TO evex;

--
-- Name: apm_package_version__add_dependency(character varying, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__add_dependency(add_dependency__dependency_type character varying, add_dependency__dependency_id integer, add_dependency__version_id integer, add_dependency__dependency_uri character varying, add_dependency__dependency_version character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_dep_id                            apm_package_dependencies.dependency_id%TYPE;
BEGIN
      if add_dependency__dependency_id is null then
          select nextval('t_acs_object_id_seq') into v_dep_id from dual;
      else
          v_dep_id := add_dependency__dependency_id;
      end if;
  
      insert into apm_package_dependencies
      (dependency_id, version_id, dependency_type, service_uri, service_version)
      values
      (v_dep_id, add_dependency__version_id, add_dependency__dependency_type,
        add_dependency__dependency_uri, add_dependency__dependency_version);

      return v_dep_id;
   
END;
$$;


ALTER FUNCTION public.apm_package_version__add_dependency(add_dependency__dependency_type character varying, add_dependency__dependency_id integer, add_dependency__version_id integer, add_dependency__dependency_uri character varying, add_dependency__dependency_version character varying) OWNER TO evex;

--
-- Name: apm_package_version__add_interface(integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__add_interface(add_interface__interface_id integer, add_interface__version_id integer, add_interface__interface_uri character varying, add_interface__interface_version character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_dep_id                            apm_package_dependencies.dependency_id%TYPE;
BEGIN
      if add_interface__interface_id is null then
          select nextval('t_acs_object_id_seq') into v_dep_id from dual;
      else
          v_dep_id := add_interface__interface_id;
      end if;
  
      insert into apm_package_dependencies
      (dependency_id, version_id, dependency_type, service_uri, service_version)
      values
      (v_dep_id, add_interface__version_id, 'provides', add_interface__interface_uri,
	add_interface__interface_version);

      return v_dep_id;
   
END;
$$;


ALTER FUNCTION public.apm_package_version__add_interface(add_interface__interface_id integer, add_interface__version_id integer, add_interface__interface_uri character varying, add_interface__interface_version character varying) OWNER TO evex;

--
-- Name: apm_package_version__copy(integer, integer, character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__copy(copy__version_id integer, copy__new_version_id integer, copy__new_version_name character varying, copy__new_version_uri character varying, copy__copy_owners_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_version_id                 integer;       
BEGIN
	v_version_id := acs_object__new(
		copy__new_version_id,
		'apm_package_version',
                now(),
                null,
                null,
                null
        );    

	insert into apm_package_versions(version_id, package_key, version_name,
					version_uri, summary, description_format, description,
					release_date, vendor, vendor_uri, auto_mount)
	    select v_version_id, package_key, copy__new_version_name,
		   copy__new_version_uri, summary, description_format, description,
		   release_date, vendor, vendor_uri, auto_mount
	    from apm_package_versions
	    where version_id = copy__version_id;
    
        update acs_objects
        set title = (select v.package_key || ', Version ' || v.version_name
                     from apm_package_versions v
                     where v.version_id = copy__version_id)
        where object_id = copy__version_id;

	insert into apm_package_dependencies(dependency_id, version_id, dependency_type, service_uri, service_version)
	    select nextval('t_acs_object_id_seq'), v_version_id, dependency_type, service_uri, service_version
	    from apm_package_dependencies
	    where version_id = copy__version_id;
    
        insert into apm_package_callbacks (version_id, type, proc)
                select v_version_id, type, proc
                from apm_package_callbacks
                where version_id = copy__version_id;
    
        if copy__copy_owners_p then
            insert into apm_package_owners(version_id, owner_uri, owner_name, sort_key)
                select v_version_id, owner_uri, owner_name, sort_key
                from apm_package_owners
                where version_id = copy__version_id;
        end if;
    
	return v_version_id;
   
END;
$$;


ALTER FUNCTION public.apm_package_version__copy(copy__version_id integer, copy__new_version_id integer, copy__new_version_name character varying, copy__new_version_uri character varying, copy__copy_owners_p boolean) OWNER TO evex;

--
-- Name: apm_package_version__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__delete(delete__version_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      delete from apm_package_owners 
      where version_id = delete__version_id; 

      delete from apm_package_dependencies
      where version_id = delete__version_id;

      delete from apm_package_versions 
	where version_id = delete__version_id;

      PERFORM acs_object__delete(delete__version_id);

      return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_version__delete(delete__version_id integer) OWNER TO evex;

--
-- Name: apm_package_version__disable(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__disable(disable__version_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      update apm_package_versions 
      set enabled_p = 'f'
      where version_id = disable__version_id;	

      return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_version__disable(disable__version_id integer) OWNER TO evex;

--
-- Name: apm_package_version__edit(integer, integer, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__edit(edit__new_version_id integer, edit__version_id integer, edit__version_name character varying, edit__version_uri character varying, edit__summary character varying, edit__description_format character varying, edit__description character varying, edit__release_date timestamp with time zone, edit__vendor character varying, edit__vendor_uri character varying, edit__auto_mount character varying, edit__installed_p boolean, edit__data_model_loaded_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_version_id                 apm_package_versions.version_id%TYPE;
  version_unchanged_p          integer;       
BEGIN
       -- Determine if version has changed.
       select case when count(*) = 0 then 0 else 1 end into version_unchanged_p
       from apm_package_versions
       where version_id = edit__version_id
       and version_name = edit__version_name;
       if version_unchanged_p <> 1 then
         v_version_id := apm_package_version__copy(
			 edit__version_id,
			 edit__new_version_id,
			 edit__version_name,
			 edit__version_uri,
                         'f'
			);
         else 
	   v_version_id := edit__version_id;			
       end if;
       
       update apm_package_versions 
		set version_uri = edit__version_uri,
		summary = edit__summary,
		description_format = edit__description_format,
		description = edit__description,
		release_date = date_trunc('days',now()),
		vendor = edit__vendor,
		vendor_uri = edit__vendor_uri,
                auto_mount = edit__auto_mount,
		installed_p = edit__installed_p,
		data_model_loaded_p = edit__data_model_loaded_p
	    where version_id = v_version_id;

	return v_version_id;
     
END;
$$;


ALTER FUNCTION public.apm_package_version__edit(edit__new_version_id integer, edit__version_id integer, edit__version_name character varying, edit__version_uri character varying, edit__summary character varying, edit__description_format character varying, edit__description character varying, edit__release_date timestamp with time zone, edit__vendor character varying, edit__vendor_uri character varying, edit__auto_mount character varying, edit__installed_p boolean, edit__data_model_loaded_p boolean) OWNER TO evex;

--
-- Name: apm_package_version__enable(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__enable(enable__version_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      update apm_package_versions set enabled_p = 't'
      where version_id = enable__version_id;	

      return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_version__enable(enable__version_id integer) OWNER TO evex;

--
-- Name: apm_package_version__new(integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__new(apm_pkg_ver__version_id integer, apm_pkg_ver__package_key character varying, apm_pkg_ver__version_name character varying, apm_pkg_ver__version_uri character varying, apm_pkg_ver__summary character varying, apm_pkg_ver__description_format character varying, apm_pkg_ver__description character varying, apm_pkg_ver__release_date timestamp with time zone, apm_pkg_ver__vendor character varying, apm_pkg_ver__vendor_uri character varying, apm_pkg_ver__auto_mount character varying, apm_pkg_ver__installed_p boolean, apm_pkg_ver__data_model_loaded_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
      v_version_id                      apm_package_versions.version_id%TYPE;
BEGIN
      if apm_pkg_ver__version_id is null then
         select nextval('t_acs_object_id_seq')
	 into v_version_id
	 from dual;
      else
         v_version_id := apm_pkg_ver__version_id;
      end if;

      v_version_id := acs_object__new(
		v_version_id,
		'apm_package_version',
                now(),
                null,
                null,
                null,
                't',
                apm_pkg_ver__package_key || ', Version ' || apm_pkg_ver__version_name,
                null
        );

      insert into apm_package_versions
      (version_id, package_key, version_name, version_uri, summary, description_format, description,
      release_date, vendor, vendor_uri, auto_mount, installed_p, data_model_loaded_p)
      values
      (v_version_id, apm_pkg_ver__package_key, apm_pkg_ver__version_name, 
       apm_pkg_ver__version_uri, apm_pkg_ver__summary, 
       apm_pkg_ver__description_format, apm_pkg_ver__description,
       apm_pkg_ver__release_date, apm_pkg_ver__vendor, apm_pkg_ver__vendor_uri, apm_pkg_ver__auto_mount,
       apm_pkg_ver__installed_p, apm_pkg_ver__data_model_loaded_p);

      return v_version_id;		
  
END;
$$;


ALTER FUNCTION public.apm_package_version__new(apm_pkg_ver__version_id integer, apm_pkg_ver__package_key character varying, apm_pkg_ver__version_name character varying, apm_pkg_ver__version_uri character varying, apm_pkg_ver__summary character varying, apm_pkg_ver__description_format character varying, apm_pkg_ver__description character varying, apm_pkg_ver__release_date timestamp with time zone, apm_pkg_ver__vendor character varying, apm_pkg_ver__vendor_uri character varying, apm_pkg_ver__auto_mount character varying, apm_pkg_ver__installed_p boolean, apm_pkg_ver__data_model_loaded_p boolean) OWNER TO evex;

--
-- Name: apm_package_version__remove_dependency(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__remove_dependency(remove_dependency__dependency_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from apm_package_dependencies 
    where dependency_id = remove_dependency__dependency_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_version__remove_dependency(remove_dependency__dependency_id integer) OWNER TO evex;

--
-- Name: apm_package_version__remove_dependency(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__remove_dependency(remove_dependency__dependency_uri character varying, remove_dependency__dependency_version character varying, remove_dependency__version_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_dep_id                           apm_package_dependencies.dependency_id%TYPE;
BEGIN
      select dependency_id into v_dep_id from apm_package_dependencies 
      where service_uri = remove_dependency__dependency_uri 
      and service_version = remove_dependency__dependency_version;
      PERFORM apm_package_version__remove_dependency(v_dep_id);

      return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_version__remove_dependency(remove_dependency__dependency_uri character varying, remove_dependency__dependency_version character varying, remove_dependency__version_id integer) OWNER TO evex;

--
-- Name: apm_package_version__remove_interface(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__remove_interface(remove_interface__interface_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from apm_package_dependencies 
    where dependency_id = remove_interface__interface_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_version__remove_interface(remove_interface__interface_id integer) OWNER TO evex;

--
-- Name: apm_package_version__remove_interface(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__remove_interface(remove_interface__interface_uri character varying, remove_interface__interface_version character varying, remove_interface__version_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_dep_id                           apm_package_dependencies.dependency_id%TYPE;
BEGIN
      select dependency_id into v_dep_id from apm_package_dependencies
      where service_uri = remove_interface__interface_uri 
      and interface_version = remove_interface__interface_version;
      PERFORM apm_package_version__remove_interface(v_dep_id);

      return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_version__remove_interface(remove_interface__interface_uri character varying, remove_interface__interface_version character varying, remove_interface__version_id integer) OWNER TO evex;

--
-- Name: apm_package_version__sortable_version_name(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__sortable_version_name(version_name character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  a_fields               integer;       
  a_start                integer;       
  a_end                  integer;       
  a_order                varchar(1000) default ''; 
  a_char                 char(1);       
  a_seen_letter          boolean default 'f';        
BEGIN
        a_fields := 0;
	a_start := 1;
	loop
	    a_end := a_start;
    
	    -- keep incrementing a_end until we run into a non-number        
	    while substr(version_name, a_end, 1) >= '0' and substr(version_name, a_end, 1) <= '9' loop
		a_end := a_end + 1;
	    end loop;
	    if a_end = a_start then
	    	return -1;
		-- raise_application_error(-20000, 'Expected number at position ' || a_start);
	    end if;
	    if a_end - a_start > 4 then
	    	return -1;
		-- raise_application_error(-20000, 'Numbers within versions can only be up to 4 digits long');
	    end if;
    
	    -- zero-pad and append the number
	    a_order := a_order || substr('0000', 1, 4 - (a_end - a_start)) ||
		substr(version_name, a_start, a_end - a_start) || '.';
            a_fields := a_fields + 1;                                
	    if a_end > length(version_name) then
		-- end of string - we're outta here
		if a_seen_letter = 'f' then
		    -- append the "final" suffix if there haven't been any letters
		    -- so far (i.e., not development/alpha/beta)
		    a_order := a_order || repeat('0000.',7 - a_fields) || '  3F.';
		end if;
		return a_order;
	    end if;
    
	    -- what's the next character? if a period, just skip it
	    a_char := substr(version_name, a_end, 1);
	    if a_char = '.' then
	    else
		-- if the next character was a letter, append the appropriate characters
		if a_char = 'd' then
		    a_order := a_order || repeat('0000.',7 - a_fields) || '  0D.';
		else if a_char = 'a' then
		    a_order := a_order || repeat('0000.',7 - a_fields) || '  1A.';
		else if a_char = 'b' then
		    a_order := a_order || repeat('0000.',7 - a_fields) || '  2B.';
		end if; end if; end if;
    
		-- can't have something like 3.3a1b2 - just one letter allowed!
		if a_seen_letter = 't' then
		    return -1;
		    -- raise_application_error(-20000, 'Not allowed to have two letters in version name '''
		    --	|| version_name || '''');
		end if;
		a_seen_letter := 't';
    
		-- end of string - we're done!
		if a_end = length(version_name) then
		    return a_order;
		end if;
	    end if;
	    a_start := a_end + 1;
	end loop;
    
END;
$$;


ALTER FUNCTION public.apm_package_version__sortable_version_name(version_name character varying) OWNER TO evex;

--
-- Name: apm_package_version__upgrade(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__upgrade(upgrade__version_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update apm_package_versions
    	set enabled_p = 'f',
	    installed_p = 'f'
	where package_key = (select package_key from apm_package_versions
	    	    	     where version_id = upgrade__version_id);
    update apm_package_versions
    	set enabled_p = 't',
	    installed_p = 't'
	where version_id = upgrade__version_id;			  
    
    return 0; 
END;
$$;


ALTER FUNCTION public.apm_package_version__upgrade(upgrade__version_id integer) OWNER TO evex;

--
-- Name: apm_package_version__upgrade_p(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__upgrade_p(upgrade_p__path character varying, upgrade_p__initial_version_name character varying, upgrade_p__final_version_name character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  v_pos1                            integer;       
  v_pos2                            integer;       
  v_tmp                             varchar(1500);
  v_path                            varchar(1500);
  v_version_from                    apm_package_versions.version_name%TYPE;
  v_version_to                      apm_package_versions.version_name%TYPE;
BEGIN

	-- Set v_path to the tail of the path (the file name).        
	v_path := substr(upgrade_p__path, instr(upgrade_p__path, '/', -1) + 1);

	-- Remove the extension, if it is .sql.
	v_pos1 := position('.sql' in v_path);
	if v_pos1 > 0 then
	    v_path := substr(v_path, 1, v_pos1 - 1);
	end if;

	-- Figure out the from/to version numbers for the individual file.
	v_pos1 := instr(v_path, '-', -1, 2);
	v_pos2 := instr(v_path, '-', -1);
	if v_pos1 = 0 or v_pos2 = 0 then
	    -- There aren't two hyphens in the file name. Bail.
	    return 0;
	end if;

	v_version_from := substr(v_path, v_pos1 + 1, v_pos2 - v_pos1 - 1);
	v_version_to := substr(v_path, v_pos2 + 1);

	if apm_package_version__version_name_greater(upgrade_p__initial_version_name, v_version_from) <= 0 and
	   apm_package_version__version_name_greater(upgrade_p__final_version_name, v_version_to) >= 0 then
	    return 1;
	end if;

	return 0;
        -- exception when others then
	-- Invalid version number.
	-- return 0;
   
END;
$$;


ALTER FUNCTION public.apm_package_version__upgrade_p(upgrade_p__path character varying, upgrade_p__initial_version_name character varying, upgrade_p__final_version_name character varying) OWNER TO evex;

--
-- Name: apm_package_version__version_name_greater(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_package_version__version_name_greater(version_name_one character varying, version_name_two character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  a_order_a		 varchar(250);
  a_order_b		 varchar(250);  
BEGIN
	a_order_a := apm_package_version__sortable_version_name(version_name_one);
	a_order_b := apm_package_version__sortable_version_name(version_name_two);
	if a_order_a < a_order_b then
	    return -1;
	else if a_order_a > a_order_b then
	    return 1;
	end if; end if;

	return 0;   
END;
$$;


ALTER FUNCTION public.apm_package_version__version_name_greater(version_name_one character varying, version_name_two character varying) OWNER TO evex;

--
-- Name: apm_parameter_value__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_parameter_value__delete(delete__value_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from apm_parameter_values 
    where value_id = delete__value_id;
    PERFORM acs_object__delete(delete__value_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.apm_parameter_value__delete(delete__value_id integer) OWNER TO evex;

--
-- Name: apm_parameter_value__new(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_parameter_value__new(new__value_id integer, new__package_id integer, new__parameter_id integer, new__attr_value character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_value_id                  apm_parameter_values.value_id%TYPE;
  v_title                     acs_objects.title%TYPE;
BEGIN
   select pkg.package_key || ': ' || pkg.instance_name || ' - ' || par.parameter_name into v_title from apm_packages pkg, apm_parameters par where pkg.package_id = new__package_id and par.parameter_id = new__parameter_id;

   v_value_id := acs_object__new(
     new__value_id,
     'apm_parameter_value',
     now(),
     null,
     null,
     null,
     't',
     v_title,
     new__package_id
   );

   insert into apm_parameter_values
    (value_id, package_id, parameter_id, attr_value)
     values
    (v_value_id, new__package_id, new__parameter_id, new__attr_value);

   return v_value_id;

END;
$$;


ALTER FUNCTION public.apm_parameter_value__new(new__value_id integer, new__package_id integer, new__parameter_id integer, new__attr_value character varying) OWNER TO evex;

--
-- Name: apm_service__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_service__delete(delete__service_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from apm_services
    where service_id = delete__service_id;
    PERFORM apm_package__delete(
	delete__service_id
    );

    return 0; 
END;
$$;


ALTER FUNCTION public.apm_service__delete(delete__service_id integer) OWNER TO evex;

--
-- Name: apm_service__new(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.apm_service__new(service_id integer, instance_name character varying, package_key character varying, object_type character varying, creation_date timestamp with time zone, creation_user integer, creation_ip character varying, context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_service_id           integer;       
BEGIN
    v_service_id := apm_package__new (
      service_id,
      instance_name,
      package_key,
      object_type,
      creation_date,
      creation_user,
      creation_ip,
      context_id
    );

    return v_service_id;
   
END;
$$;


ALTER FUNCTION public.apm_service__new(service_id integer, instance_name character varying, package_key character varying, object_type character varying, creation_date timestamp with time zone, creation_user integer, creation_ip character varying, context_id integer) OWNER TO evex;

--
-- Name: application_group__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.application_group__delete(group_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    PERFORM acs_group__delete(group_id);

    return 0;
END;
$$;


ALTER FUNCTION public.application_group__delete(group_id integer) OWNER TO evex;

--
-- Name: application_group__group_id_from_package_id(integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.application_group__group_id_from_package_id(group_id_from_package_id__package_id integer, group_id_from_package_id__no_complain_p boolean) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_group_id				  application_groups.group_id%TYPE;
  v_object_name				  varchar;
BEGIN

  select group_id 
    into v_group_id
    from application_groups 
    where package_id = group_id_from_package_id__package_id;

-- TODO: does this shortcut the exception in Oracle?
--    return v_group_id;

  if not found then
    if group_id_from_package_id__no_complain_p != 't' then
      v_object_name := acs_object__name(group_id_from_package_id__package_id);
      raise EXCEPTION '-20000: No group_id found for package % (%)', group_id_from_package_id__package_id, v_object_name;
    end if;
    return null;
  else
    return v_group_id;
  end if;

END;
$$;


ALTER FUNCTION public.application_group__group_id_from_package_id(group_id_from_package_id__package_id integer, group_id_from_package_id__no_complain_p boolean) OWNER TO evex;

--
-- Name: application_group__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.application_group__new(new__group_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__email character varying, new__url character varying, new__group_name character varying, new__package_id integer, new__join_policy character varying, new__context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_group_id		     application_groups.group_id%TYPE;
BEGIN
  v_group_id := acs_group__new (
    new__group_id,
    new__object_type,
    new__creation_date,
    new__creation_user,
    new__creation_ip,
    new__email,
    new__url,
    new__group_name,
    new__join_policy,
    new__context_id
  );

  insert into application_groups (group_id, package_id) 
    values (v_group_id, new__package_id);

  return v_group_id;

END;
$$;


ALTER FUNCTION public.application_group__new(new__group_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__email character varying, new__url character varying, new__group_name character varying, new__package_id integer, new__join_policy character varying, new__context_id integer) OWNER TO evex;

--
-- Name: authority__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.authority__del(p_authority_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  perform acs_object__delete(p_authority_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.authority__del(p_authority_id integer) OWNER TO evex;

--
-- Name: authority__new(integer, character varying, character varying, character varying, boolean, integer, integer, integer, character varying, character varying, integer, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.authority__new(p_authority_id integer, p_object_type character varying, p_short_name character varying, p_pretty_name character varying, p_enabled_p boolean, p_sort_order integer, p_auth_impl_id integer, p_pwd_impl_id integer, p_forgotten_pwd_url character varying, p_change_pwd_url character varying, p_register_impl_id integer, p_register_url character varying, p_help_contact_text character varying, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  
    v_authority_id           integer;
    v_object_type            varchar;    
    v_sort_order             integer;
  
BEGIN
    if p_object_type is null then
        v_object_type := 'authority';
    else
        v_object_type := p_object_type;
    end if;

    if p_sort_order is null then
          select into v_sort_order max(sort_order) + 1
                         from auth_authorities;
    else
        v_sort_order := p_sort_order;
    end if;

    -- Instantiate the ACS Object super type with auditing info
    v_authority_id  := acs_object__new(
        p_authority_id,
        v_object_type,
        now(),
        p_creation_user,
        p_creation_ip,
        p_context_id,
        't',
        p_short_name,
        null
    );

    insert into auth_authorities (authority_id, short_name, pretty_name, enabled_p, 
                                  sort_order, auth_impl_id, pwd_impl_id, 
                                  forgotten_pwd_url, change_pwd_url, register_impl_id,
                                  help_contact_text)
    values (v_authority_id, p_short_name, p_pretty_name, p_enabled_p, 
                                  v_sort_order, p_auth_impl_id, p_pwd_impl_id, 
                                  p_forgotten_pwd_url, p_change_pwd_url, p_register_impl_id,
                                  p_help_contact_text);

   return v_authority_id;
END;

$$;


ALTER FUNCTION public.authority__new(p_authority_id integer, p_object_type character varying, p_short_name character varying, p_pretty_name character varying, p_enabled_p boolean, p_sort_order integer, p_auth_impl_id integer, p_pwd_impl_id integer, p_forgotten_pwd_url character varying, p_change_pwd_url character varying, p_register_impl_id integer, p_register_url character varying, p_help_contact_text character varying, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: banner__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.banner__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_banner_id                    alias for $1;
begin

	perform acs_object__delete(p_banner_id);

	RETURN 0;

end;$_$;


ALTER FUNCTION public.banner__del(integer) OWNER TO evex;

--
-- Name: banner__edit(integer, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.banner__edit(integer, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_banner_id           	 	alias for $1;
    p_name                      alias for $2;
    p_url               		alias for $3;
    p_sort_order		        alias for $4;
begin

    UPDATE banners
    SET name = p_name,
    url = p_url,
	sort_order = p_sort_order
    WHERE banner_id = p_banner_id;

    return p_banner_id;
end;
$_$;


ALTER FUNCTION public.banner__edit(integer, character varying, character varying, integer) OWNER TO evex;

--
-- Name: banner__new(integer, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.banner__new(integer, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_banner_id                    		alias for $1;
    p_name		     		            alias for $2;
    p_url		              		    alias for $3;
    p_sort_order              		    alias for $4;
    p_package_id	               		alias for $5;
    p_creation_date             		alias for $6;
    p_creation_user             		alias for $7;
    p_creation_ip               		alias for $8;
    p_context_id                		alias for $9;
    v_banner_id               			banners.banner_id%TYPE;
begin

	v_banner_id := acs_object__new (
		p_banner_id,        	 -- object_id
		'banner',    -- object_type
		p_creation_date,         -- creation_date
		p_creation_user,         -- creation_user
		p_creation_ip,           -- creation_ip
		p_context_id,            -- context_id
        p_name,               	 -- title
        p_package_id             -- package_id
	);


    INSERT INTO banners (banner_id, name,url,sort_order)
    VALUES (v_banner_id,p_name,p_url,p_sort_order);

    return v_banner_id;
end;$_$;


ALTER FUNCTION public.banner__new(integer, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, integer) OWNER TO evex;

--
-- Name: bitfromint4(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.bitfromint4(integer) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	begin 
    	    return $1::bit(32);
	end;
        $_$;


ALTER FUNCTION public.bitfromint4(integer) OWNER TO evex;

--
-- Name: bittoint4(bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.bittoint4(bit varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
	begin 
    	    return "int4"($1);
	end;
        $_$;


ALTER FUNCTION public.bittoint4(bit varying) OWNER TO evex;

--
-- Name: cal_item__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cal_item__delete(delete__cal_item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	-- Erase the cal_item associated with the id
    delete from 	cal_items
    where		cal_item_id = delete__cal_item_id;
 	
	-- Erase all the priviledges
    delete from 	acs_permissions
    where		object_id = delete__cal_item_id;

    PERFORM acs_event__delete(delete__cal_item_id);

    return 0;
END;
$$;


ALTER FUNCTION public.cal_item__delete(delete__cal_item_id integer) OWNER TO evex;

--
-- Name: cal_item__delete_all(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cal_item__delete_all(delete__recurrence_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_event                             RECORD;
BEGIN
    for v_event in 
	select event_id from acs_events
        where recurrence_id= delete__recurrence_id
    LOOP
        PERFORM cal_item__delete(v_event.event_id);
    END LOOP;

    PERFORM recurrence__delete(delete__recurrence_id);

    return 0;

END;
$$;


ALTER FUNCTION public.cal_item__delete_all(delete__recurrence_id integer) OWNER TO evex;

--
-- Name: cal_item__new(integer, integer, character varying, character varying, boolean, character varying, integer, integer, integer, character varying, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cal_item__new(new__cal_item_id integer, new__on_which_calendar integer, new__name character varying, new__description character varying, new__html_p boolean, new__status_summary character varying, new__timespan_id integer, new__activity_id integer, new__recurrence_id integer, new__object_type character varying, new__context_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_cal_item_id		cal_items.cal_item_id%TYPE;

BEGIN
    v_cal_item_id := acs_event__new(
	new__cal_item_id,	-- event_id
	new__name,		-- name
	new__description,	-- description
        new__html_p,		-- html_p
        new__status_summary,    -- status_summary
	new__timespan_id,	-- timespan_id
	new__activity_id,	-- activity_id
	new__recurrence_id,	-- recurrence_id
	new__object_type,	-- object_type
	new__creation_date,	-- creation_date
	new__creation_user,	-- creation_user
	new__creation_ip,	-- creation_ip
	new__context_id		-- context_id
	);

    insert into cal_items
	(cal_item_id, on_which_calendar)
    values          
	(v_cal_item_id, new__on_which_calendar);

    return v_cal_item_id;

END;
$$;


ALTER FUNCTION public.cal_item__new(new__cal_item_id integer, new__on_which_calendar integer, new__name character varying, new__description character varying, new__html_p boolean, new__status_summary character varying, new__timespan_id integer, new__activity_id integer, new__recurrence_id integer, new__object_type character varying, new__context_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) OWNER TO evex;

--
-- Name: calendar__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.calendar__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$declare
	delete__calendar_id		alias for $1;
    begin
	delete from calendars
	where calendar_id = delete__calendar_id;

	-- Delete all privileges associate with this calendar
	
	delete from     acs_permissions 
        where           object_id = delete__calendar_id;

       delete from     acs_permissions
        where           object_id in (
				select  cal_item_id
                                from    cal_items
                                where   on_which_calendar = delete__calendar_id
			);
                         
	PERFORM acs_object__delete(delete__calendar_id);

    return 0;
    end;$_$;


ALTER FUNCTION public.calendar__delete(integer) OWNER TO evex;

--
-- Name: calendar__new(integer, character varying, character varying, integer, boolean, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.calendar__new(integer, character varying, character varying, integer, boolean, integer, integer, timestamp with time zone, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$declare
	v_calendar_id           calendars.calendar_id%TYPE;
	new__calendar_id	alias for $1;
	new__calendar_name	alias for $2;
	new__object_type	alias for $3;
	new__owner_id		alias for $4;
	new__private_p		alias for $5;
	new__package_id		alias for $6;
	new__context_id		alias for $7;
	new__creation_date	alias for $8;
	new__creation_user	alias for $9;
	new__creation_ip	alias for $10;

    begin
        v_calendar_id := acs_object__new(
		new__calendar_id,
		new__object_type,
		new__creation_date,
		new__creation_user,
		new__creation_ip,
		new__context_id
	);
	
	insert into     calendars
                        (calendar_id, calendar_name, owner_id, package_id, private_p)
	values          (v_calendar_id, new__calendar_name, new__owner_id, new__package_id, new__private_p);
      
	PERFORM acs_permission__grant_permission (
              v_calendar_id,
              new__owner_id,
              'calendar_admin'
        );


	return v_calendar_id;
    end;$_$;


ALTER FUNCTION public.calendar__new(integer, character varying, character varying, integer, boolean, integer, integer, timestamp with time zone, integer, character varying) OWNER TO evex;

--
-- Name: category__change_parent(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category__change_parent(p_category_id integer, p_tree_id integer, p_parent_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_old_left_ind      integer;
    v_old_right_ind     integer;
    v_new_left_ind      integer;
    v_new_right_ind     integer;
    v_width             integer;
BEGIN
 	update categories
	set parent_id = p_parent_id
	where category_id = p_category_id;

	-- first save the subtree, then compact tree, then expand tree to make room
	-- for subtree, then insert it

	select left_ind, right_ind into v_old_left_ind, v_old_right_ind
	from categories
	where category_id = p_category_id;

	v_width := v_old_right_ind - v_old_left_ind + 1;

	-- cut out old subtree
	update categories
	set left_ind = -left_ind, right_ind = -right_ind
	where tree_id = p_tree_id
	and left_ind >= v_old_left_ind
	and right_ind <= v_old_right_ind;

	-- compact parent trees
	update categories
	set right_ind = right_ind - v_width
	where tree_id = p_tree_id
	and left_ind < v_old_left_ind
	and right_ind > v_old_right_ind;

	-- compact right tree portion
	update categories
	set left_ind = left_ind - v_width,
	right_ind = right_ind - v_width
	where tree_id = p_tree_id
	and left_ind > v_old_left_ind;

	if (p_parent_id is null) then
	   select 1, max(right_ind)+1 into v_new_left_ind, v_new_right_ind
	   from categories
	   where tree_id = p_tree_id;
	else
	   select left_ind, right_ind into v_new_left_ind, v_new_right_ind
	   from categories
	   where category_id = p_parent_id;
	end if;

	-- move parent trees to make room
	update categories
	set right_ind = right_ind + v_width
	where tree_id = p_tree_id
	and left_ind <= v_new_left_ind
	and right_ind >= v_new_right_ind;

	-- move right tree portion to make room
	update categories
	set left_ind = left_ind + v_width,
	right_ind = right_ind + v_width
	where tree_id = p_tree_id
	and left_ind > v_new_right_ind;

	-- insert subtree at correct place
	update categories
	set left_ind = -left_ind + (v_new_right_ind - v_old_left_ind),
	right_ind = -right_ind + (v_new_right_ind - v_old_left_ind)
	where tree_id = p_tree_id
	and left_ind < 0;

	-- for debugging reasons
        perform category_tree__check_nested_ind(p_tree_id);

        return 0;
END;

$$;


ALTER FUNCTION public.category__change_parent(p_category_id integer, p_tree_id integer, p_parent_id integer) OWNER TO evex;

--
-- Name: category__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category__del(p_category_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

        v_tree_id       integer;
	v_left_ind      integer;
	v_right_ind     integer;
        node            record;
BEGIN
        select tree_id, left_ind, right_ind
	into v_tree_id, v_left_ind, v_right_ind
	from categories where category_id = p_category_id;

	for node in 
           select category_id
	     from categories
	    where tree_id = v_tree_id
	      and left_ind >= v_left_ind
	      and right_ind <= v_right_ind 
        loop
	   delete from category_object_map where category_id = node.category_id;
	   delete from category_translations where category_id = node.category_id;
	   delete from categories where category_id = node.category_id;
	   perform acs_object__delete(node.category_id);
	end loop;

	update categories
	set right_ind = (right_ind - (1 + v_right_ind - v_left_ind))
	where left_ind <= v_left_ind
	and right_ind > v_left_ind
	and tree_id = v_tree_id;

	update categories
	set right_ind = (right_ind - (1 + v_right_ind - v_left_ind)),
	    left_ind = (left_ind - (1 + v_right_ind - v_left_ind))
	where left_ind > v_left_ind
	and tree_id = v_tree_id;
	
        -- for debugging reasons
        perform category_tree__check_nested_ind(v_tree_id);
        return 0;
END;

$$;


ALTER FUNCTION public.category__del(p_category_id integer) OWNER TO evex;

--
-- Name: category__edit(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category__edit(p_category_id integer, p_locale character varying, p_name character varying, p_description character varying, p_modifying_date timestamp with time zone, p_modifying_user integer, p_modifying_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	-- change category name
    update category_translations
    set name = p_name,
       description = p_description
    where category_id = p_category_id
          and locale = p_locale;

    update acs_objects
    set last_modified = p_modifying_date,
	    modifying_user = p_modifying_user,
	    modifying_ip = p_modifying_ip
    where object_id = p_category_id;

    return 0;
END;

$$;


ALTER FUNCTION public.category__edit(p_category_id integer, p_locale character varying, p_name character varying, p_description character varying, p_modifying_date timestamp with time zone, p_modifying_user integer, p_modifying_ip character varying) OWNER TO evex;

--
-- Name: category__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category__name(p_category_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_name      varchar;
BEGIN
	select name into v_name
	from category_translations
	where category_id = p_category_id
	and locale = 'en_US';

        return 0;
END;

$$;


ALTER FUNCTION public.category__name(p_category_id integer) OWNER TO evex;

--
-- Name: category__new(integer, integer, character varying, character varying, character varying, integer, boolean, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category__new(p_category_id integer, p_tree_id integer, p_locale character varying, p_name character varying, p_description character varying, p_parent_id integer, p_deprecated_p boolean, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_category_id       integer; 
    v_left_ind          integer;
    v_right_ind         integer;
BEGIN
	v_category_id := acs_object__new ( 
		p_category_id,          -- object_id
		'category',           -- object_type
		p_creation_date,        -- creation_date
		p_creation_user,        -- creation_user
		p_creation_ip,          -- creation_ip
		p_tree_id,              -- context_id
                't',                  -- security_inherit_p
                p_name,                 -- title
                null                    -- package_id
	);

	if (p_parent_id is null) then
		select 1, coalesce(max(right_ind)+1,1) into v_left_ind, v_right_ind
		from categories
		where tree_id = p_tree_id;
	else
		select left_ind, right_ind into v_left_ind, v_right_ind
		from categories
		where category_id = p_parent_id;
	end if;

 	insert into categories
        (category_id, tree_id, deprecated_p, parent_id, left_ind, right_ind)
	values
	(v_category_id, p_tree_id, p_deprecated_p, p_parent_id, -1, -2);

	-- move right subtrees to make room for new category
	update categories
	set left_ind = left_ind + 2,
	    right_ind = right_ind + 2
	where tree_id = p_tree_id
	and left_ind > v_right_ind;

	-- expand upper nodes to make room for new category
	update categories
	set right_ind = right_ind + 2
	where tree_id = p_tree_id
	and left_ind <= v_left_ind
	and right_ind >= v_right_ind;

	-- insert new category
	update categories
	set left_ind = v_right_ind,
	    right_ind = v_right_ind + 1
	where category_id = v_category_id;

	insert into category_translations
	    (category_id, locale, name, description)
	values
	    (v_category_id, p_locale, p_name, p_description);

	return v_category_id;
END;

$$;


ALTER FUNCTION public.category__new(p_category_id integer, p_tree_id integer, p_locale character varying, p_name character varying, p_description character varying, p_parent_id integer, p_deprecated_p boolean, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying) OWNER TO evex;

--
-- Name: category__new_translation(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category__new_translation(p_category_id integer, p_locale character varying, p_name character varying, p_description character varying, p_modifying_date timestamp with time zone, p_modifying_user integer, p_modifying_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        insert into category_translations
	    (category_id, locale, name, description)
	values
	    (p_category_id, p_locale, p_name, p_description);

	update acs_objects
        set last_modified = p_modifying_date,
	    modifying_user = p_modifying_user,
	    modifying_ip = p_modifying_ip
	where object_id = p_category_id;
        
        return 0;
END;

$$;


ALTER FUNCTION public.category__new_translation(p_category_id integer, p_locale character varying, p_name character varying, p_description character varying, p_modifying_date timestamp with time zone, p_modifying_user integer, p_modifying_ip character varying) OWNER TO evex;

--
-- Name: category__phase_in(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category__phase_in(p_category_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       update categories
       set deprecated_p = false
       where category_id = p_category_id;

       return 0;
END;

$$;


ALTER FUNCTION public.category__phase_in(p_category_id integer) OWNER TO evex;

--
-- Name: category__phase_out(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category__phase_out(p_category_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       update categories
       set deprecated_p = true
       where category_id = p_category_id;

       return 0;
END;

$$;


ALTER FUNCTION public.category__phase_out(p_category_id integer) OWNER TO evex;

--
-- Name: category_link__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_link__del(p_link_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	-- function for deleting category links
DECLARE
BEGIN
	delete from category_links
	where link_id = p_link_id;

	return p_link_id;
END;
$$;


ALTER FUNCTION public.category_link__del(p_link_id integer) OWNER TO evex;

--
-- Name: category_link__new(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_link__new(p_from_category_id integer, p_to_category_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	-- function for adding category links
DECLARE
	v_link_id		integer;
BEGIN
	v_link_id := nextval ('category_links_id_seq');

	insert into category_links (link_id, from_category_id, to_category_id)
	values (v_link_id, p_from_category_id, p_to_category_id);

	return v_link_id;
END;
$$;


ALTER FUNCTION public.category_link__new(p_from_category_id integer, p_to_category_id integer) OWNER TO evex;

--
-- Name: category_synonym__convert_string(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__convert_string(p_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
-- return string to build search index
DECLARE
        v_index_string	varchar(200);
BEGIN
	-- convert string to uppercase and substitute special chars
        -- TODO: complete
        v_index_string := upper (
                        replace (
                        replace (
                        replace (
                        replace (
                        replace (
                        replace (
			replace (p_name, 'ä', 'AE'), 
					 'Ä', 'AE'),
					 'ö', 'OE'),
					 'Ö', 'OE'),
					 'ü', 'UE'),
					 'Ü', 'UE'),
					 'ß', 'SS'));
					  
	return (' ' || v_index_string || ' ');
END;
$$;


ALTER FUNCTION public.category_synonym__convert_string(p_name character varying) OWNER TO evex;

--
-- Name: category_synonym__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__del(p_synonym_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- delete synonym
DECLARE
BEGIN
	-- delete search results
	delete	from category_search_results
	where	synonym_id = p_synonym_id;

	-- delete synonym index
	delete	from category_synonym_index
	where	synonym_id = p_synonym_id;

	-- delete synonym
	delete	from category_synonyms
	where	synonym_id = p_synonym_id;

	return (1);
END;
$$;


ALTER FUNCTION public.category_synonym__del(p_synonym_id integer) OWNER TO evex;

--
-- Name: category_synonym__edit(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__edit(p_synonym_id integer, p_new_name character varying, p_locale character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	-- update synonym data
	update	category_synonyms
	set	name = p_new_name,
		locale = p_locale
	where	synonym_id = p_synonym_id;

	-- update synonym index and search results
	PERFORM category_synonym__reindex (p_synonym_id, p_new_name, p_locale);

	return (p_synonym_id);
END;
$$;


ALTER FUNCTION public.category_synonym__edit(p_synonym_id integer, p_new_name character varying, p_locale character varying) OWNER TO evex;

--
-- Name: category_synonym__edit_cat_trans_trg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__edit_cat_trans_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- trigger function for updating a category translation
DECLARE
    v_synonym_id    integer;
BEGIN
	-- get synonym_id of updated category translation
    select synonym_id into v_synonym_id
    from   category_synonyms
    where  category_id = OLD.category_id
           and name = OLD.name
           and locale = OLD.locale
           and synonym_p = false;

	-- update synonym
    PERFORM category_synonym__edit (v_synonym_id, NEW.name, NEW.locale);

    return new;
END;
$$;


ALTER FUNCTION public.category_synonym__edit_cat_trans_trg() OWNER TO evex;

--
-- Name: category_synonym__get_similarity(integer, integer, bigint); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__get_similarity(p_len1 integer, p_len2 integer, p_matches bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- calculates similarity of two strings
DECLARE
BEGIN
	return (p_matches * 200 / (p_len1 + p_len2));
END;
$$;


ALTER FUNCTION public.category_synonym__get_similarity(p_len1 integer, p_len2 integer, p_matches bigint) OWNER TO evex;

--
-- Name: category_synonym__new(character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__new(p_name character varying, p_locale character varying, p_category_id integer, p_synonym_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_synonym_id	integer;
BEGIN
	-- get new synonym_id
	if (p_synonym_id is null) then
		v_synonym_id := nextval ('category_synonyms_id_seq');
	else 
		v_synonym_id := p_synonym_id;
	end if;

	-- insert synonym data
	insert into category_synonyms (synonym_id, category_id, locale, name, synonym_p)
	values (v_synonym_id, p_category_id, p_locale, p_name, true);

	-- insert in synonym index and search results
	PERFORM category_synonym__reindex (v_synonym_id, p_name, p_locale);

	return (v_synonym_id);
END;
$$;


ALTER FUNCTION public.category_synonym__new(p_name character varying, p_locale character varying, p_category_id integer, p_synonym_id integer) OWNER TO evex;

--
-- Name: category_synonym__new_cat_trans_trg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__new_cat_trans_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- trigger function for inserting category translation
DECLARE
    v_synonym_id     integer;
BEGIN
	-- create synonym
    v_synonym_id := category_synonym__new (NEW.name, NEW.locale, NEW.category_id, null);

	-- mark synonym as not editable for users
    update category_synonyms
    set synonym_p = false
    where synonym_id = v_synonym_id;

    return new;
END;
$$;


ALTER FUNCTION public.category_synonym__new_cat_trans_trg() OWNER TO evex;

--
-- Name: category_synonym__reindex(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__reindex(p_synonym_id integer, p_name character varying, p_locale character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- build search index for synonym
DECLARE
	v_name		varchar(200);
	v_len		integer;
	v_i		integer;
BEGIN
	-- delete old search results for this synonym
	delete	from category_search_results
	where	synonym_id = p_synonym_id;

	-- delete old synonym index for this synonym
	delete	from category_synonym_index
	where	synonym_id = p_synonym_id;

	-- convert string to uppercase and substitute special chars
	v_name := category_synonym__convert_string (p_name);

	-- rebuild synonym index
	v_len := length (v_name) - 2;
	v_i := 1;
	while (v_i <= v_len) loop
		insert into category_synonym_index
		values (p_synonym_id, substring (v_name, v_i , 3));
		v_i := v_i + 1;
	end loop;

	-- rebuild search results
	insert into category_search_results
	select	s.query_id, p_synonym_id, 
		category_synonym__get_similarity (v_len, length (s.search_text) - 2, count(*))
	from	category_search_index si, 
		category_synonym_index i,
		category_search s
	where	i.synonym_id = p_synonym_id
	and	si.trigram = i.trigram
	and	si.query_id = s.query_id
	and	s.locale = p_locale
	group by s.query_id, s.search_text;

	return (1);
END;
$$;


ALTER FUNCTION public.category_synonym__reindex(p_synonym_id integer, p_name character varying, p_locale character varying) OWNER TO evex;

--
-- Name: category_synonym__search(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_synonym__search(p_search_text character varying, p_locale character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- return id for search string
DECLARE
	v_search_text	varchar(200);
	v_query_id	integer;
	v_len		integer;
	v_i		integer;
BEGIN
	-- check if search text already exists
	select	query_id into v_query_id
	from	category_search
	where	search_text = p_search_text
	and 	locale = p_locale;

	-- simply update old search data if already exists
	if (v_query_id is not null) then
		update	category_search
		set	queried_count = queried_count + 1,
			last_queried = date('now')
		where	query_id = v_query_id;
		return (v_query_id);
	end if;

	-- get new search query id
	v_query_id := nextval ('category_search_id_seq');

	-- convert string to uppercase and substitute special chars
	v_search_text := category_synonym__convert_string (p_search_text);

	-- insert search data
	insert into category_search (query_id, search_text, locale, queried_count, last_queried)
	values (v_query_id, p_search_text, p_locale, 1, date('now'));

	-- build search index
	v_len := length (v_search_text) - 2;
	v_i := 1;
	while (v_i <= v_len) loop
		insert into category_search_index 
		values (v_query_id, substring (v_search_text, v_i , 3));
		v_i := v_i + 1;
	end loop;

	-- build search result
	insert into category_search_results
	select	v_query_id, s.synonym_id, 
		category_synonym__get_similarity (v_len, length (s.name) - 2, count(*))
	from	category_search_index si, 
		category_synonym_index i,
		category_synonyms s
	where	si.query_id = v_query_id
	and	si.trigram = i.trigram
	and	s.synonym_id = i.synonym_id
	and	s.locale = p_locale
	group by s.synonym_id, s.name;

	return (v_query_id);
END;
$$;


ALTER FUNCTION public.category_synonym__search(p_search_text character varying, p_locale character varying) OWNER TO evex;

--
-- Name: category_tree__check_nested_ind(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__check_nested_ind(p_tree_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_negative               numeric;
    v_order                  numeric;
    v_parent                 numeric;
BEGIN
        select count(*) into v_negative from categories
	where tree_id = p_tree_id and (left_ind < 1 or right_ind < 1);

	if v_negative > 0 then 
           raise EXCEPTION '-20001: negative index not allowed!';
        end if;

        select count(*) into v_order from categories
	where tree_id = p_tree_id
	and left_ind >= right_ind;
	
	if v_order > 0 then 
           raise EXCEPTION '-20002: right index must be greater than left index!';
        end if;

        select count(*) into v_parent
	from categories parent, categories child
		where parent.tree_id = p_tree_id
		and child.tree_id = parent.tree_id
		and (parent.left_ind >= child.left_ind or parent.right_ind <= child.right_ind)
		and child.parent_id = parent.category_id;

	if v_parent > 0 then 
           raise EXCEPTION '-20003: child index must be between parent index!';
        end if;

        return 0;
END;

$$;


ALTER FUNCTION public.category_tree__check_nested_ind(p_tree_id integer) OWNER TO evex;

--
-- Name: category_tree__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__copy(p_source_tree integer, p_dest_tree integer, p_creation_user integer, p_creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_new_left_ind          integer;
    v_category_id	    integer;
    source record;
BEGIN
	select coalesce(max(right_ind),0) into v_new_left_ind 
	from categories
	where tree_id = p_dest_tree;

	for source in (select category_id, parent_id, left_ind, right_ind from categories where tree_id = p_source_tree) loop

	   v_category_id := acs_object__new ( 
                null,
		'category',     -- object_type
		now(),            -- creation_date
		p_creation_user,  -- creation_user
		p_creation_ip,    -- creation_ip
	  	p_dest_tree       -- context_id
	   );

	   insert into categories
	   (category_id, tree_id, parent_id, left_ind, right_ind)
	   values
	   (v_category_id, p_dest_tree, source.parent_id, source.left_ind + v_new_left_ind, source.right_ind + v_new_left_ind);
	end loop;

	-- correct parent_ids
	update categories
	set parent_id = (select t.category_id
			from categories s, categories t
			where s.category_id = categories.parent_id
			and t.tree_id = p_dest_tree
			and s.left_ind + v_new_left_ind = t.left_ind)
	where tree_id = p_dest_tree;

	-- copy all translations
	insert into category_translations
	(category_id, locale, name, description)
	(select ct.category_id, t.locale, t.name, t.description
	from category_translations t, categories cs, categories ct
	where ct.tree_id = p_dest_tree
	and cs.tree_id = p_source_tree
	and cs.left_ind + v_new_left_ind = ct.left_ind
	and t.category_id = cs.category_id);

	-- for debugging reasons
	perform category_tree__check_nested_ind(p_dest_tree);

       return 0;
END;

$$;


ALTER FUNCTION public.category_tree__copy(p_source_tree integer, p_dest_tree integer, p_creation_user integer, p_creation_ip character varying) OWNER TO evex;

--
-- Name: category_tree__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__del(p_tree_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

       delete from category_tree_map where tree_id = p_tree_id;

       delete from category_object_map where category_id in (select category_id from categories where tree_id = p_tree_id);

       delete from category_translations where category_id in (select category_id from categories where tree_id = p_tree_id);
 
       delete from categories where tree_id = p_tree_id;
 
       delete from acs_objects where context_id = p_tree_id;

       delete from acs_permissions where object_id = p_tree_id;

       delete from category_tree_translations where tree_id  = p_tree_id;
       delete from category_trees where tree_id  = p_tree_id;
 
       perform acs_object__delete(p_tree_id);

       return 0;
END;

$$;


ALTER FUNCTION public.category_tree__del(p_tree_id integer) OWNER TO evex;

--
-- Name: category_tree__edit(integer, character varying, character varying, character varying, boolean, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__edit(p_tree_id integer, p_locale character varying, p_tree_name character varying, p_description character varying, p_site_wide_p boolean, p_modifying_date timestamp with time zone, p_modifying_user integer, p_modifying_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	update category_trees
	set site_wide_p = p_site_wide_p
	where tree_id = p_tree_id;

	update category_tree_translations
	set name = p_tree_name,
	    description = p_description
	where tree_id = p_tree_id
	and locale = p_locale;

	update acs_objects
	set last_modified = p_modifying_date,
	    modifying_user = p_modifying_user,
	    modifying_ip = p_modifying_ip
	where object_id = p_tree_id;

       return 0;
END;

$$;


ALTER FUNCTION public.category_tree__edit(p_tree_id integer, p_locale character varying, p_tree_name character varying, p_description character varying, p_site_wide_p boolean, p_modifying_date timestamp with time zone, p_modifying_user integer, p_modifying_ip character varying) OWNER TO evex;

--
-- Name: category_tree__map(integer, integer, integer, boolean, boolean, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__map(p_object_id integer, p_tree_id integer, p_subtree_category_id integer, p_assign_single_p boolean, p_require_category_p boolean, p_widget character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_map_count              integer;
BEGIN
	select count(*) 
	into v_map_count
	from category_tree_map
	where object_id = p_object_id
	and tree_id = p_tree_id;

	if v_map_count = 0 then
	   insert into category_tree_map
	   (tree_id, subtree_category_id, object_id,
	    assign_single_p, require_category_p, widget)
	   values (p_tree_id, p_subtree_category_id, p_object_id,
	           p_assign_single_p, p_require_category_p, p_widget);
	end if;
        return 0;
END;

$$;


ALTER FUNCTION public.category_tree__map(p_object_id integer, p_tree_id integer, p_subtree_category_id integer, p_assign_single_p boolean, p_require_category_p boolean, p_widget character varying) OWNER TO evex;

--
-- Name: category_tree__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__name(p_tree_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_name                   varchar;
BEGIN
	select name into v_name
	from category_tree_translations
	where tree_id = p_tree_id
	and locale = 'en_US';

	return v_name;
END;

$$;


ALTER FUNCTION public.category_tree__name(p_tree_id integer) OWNER TO evex;

--
-- Name: category_tree__new(integer, character varying, character varying, character varying, boolean, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__new(p_tree_id integer, p_locale character varying, p_tree_name character varying, p_description character varying, p_site_wide_p boolean, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  
    v_tree_id               integer;
BEGIN
	v_tree_id := acs_object__new (
		p_tree_id,         -- object_id
		'category_tree', -- object_type
		p_creation_date,   -- creation_date
		p_creation_user,   -- creation_user
		p_creation_ip,     -- creation_ip
		p_context_id,      -- context_id
                p_tree_name,       -- title
                null               -- package_id
	);

	insert into category_trees
	   (tree_id, site_wide_p)
	values
	   (v_tree_id, p_site_wide_p);

	perform acs_permission__grant_permission (
		v_tree_id,             -- object_id
		p_creation_user,       -- grantee_id
		'category_tree_read' -- privilege
	);
	perform acs_permission__grant_permission (
		v_tree_id,                -- object_id
		p_creation_user,          -- grantee_id
		'category_tree_write'   -- privilege
	);
	perform acs_permission__grant_permission (
		v_tree_id,                          -- object_id
		p_creation_user,                    -- grantee_id
		'category_tree_grant_permissions' -- privilege
	);

	insert into category_tree_translations
	    (tree_id, locale, name, description)
	values
	    (v_tree_id, p_locale, p_tree_name, p_description);

	return v_tree_id;
END;

$$;


ALTER FUNCTION public.category_tree__new(p_tree_id integer, p_locale character varying, p_tree_name character varying, p_description character varying, p_site_wide_p boolean, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: category_tree__new_translation(integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__new_translation(p_tree_id integer, p_locale character varying, p_tree_name character varying, p_description character varying, p_modifying_date timestamp with time zone, p_modifying_user integer, p_modifying_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	insert into category_tree_translations
	    (tree_id, locale, name, description)
	values
	    (p_tree_id, p_locale, p_tree_name, p_description);

	update acs_objects
	set last_modified = p_modifying_date,
	    modifying_user = p_modifying_user,
	    modifying_ip = p_modifying_ip
	where object_id = p_tree_id;
        return 0;
END;

$$;


ALTER FUNCTION public.category_tree__new_translation(p_tree_id integer, p_locale character varying, p_tree_name character varying, p_description character varying, p_modifying_date timestamp with time zone, p_modifying_user integer, p_modifying_ip character varying) OWNER TO evex;

--
-- Name: category_tree__unmap(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.category_tree__unmap(p_object_id integer, p_tree_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	delete from category_tree_map
	where object_id = p_object_id
	and tree_id = p_tree_id;
        return 0;
END;

$$;


ALTER FUNCTION public.category_tree__unmap(p_object_id integer, p_tree_id integer) OWNER TO evex;

--
-- Name: cmp_pg_version(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cmp_pg_version(p__version character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    pg_version integer[];
    user_pg_version integer[];
    index integer;
    ret_val integer;
    i integer;
BEGIN
    ret_val = 0;

    user_pg_version := string_to_array(trim(p__version),'.')::int[];
    
    --   select string_to_array(setting, '.')::int[] into pg_version from pg_settings where name = 'server_version';
    -- the following version does not barf on beta-versions etc.
    select string_to_array(setting::int/10000 || '.' || (setting::int%10000)/100 || '.' || (setting::int%100), '.')::int[] into pg_version
    from pg_settings where name = 'server_version_num';

    for index in array_length(user_pg_version, 1) + 1..array_length(pg_version, 1) loop
        user_pg_version[index] := 0;
    end loop;

    index := 1;

    while (index <= array_length(pg_version, 1) and ret_val = 0) loop
        if user_pg_version[index] > pg_version[index] then
            ret_val := -1;
    elsif user_pg_version[index] < pg_version[index] then
            ret_val := 1;
        end if;
        index := index + 1;
    end loop;

    return ret_val;
END;

$$;


ALTER FUNCTION public.cmp_pg_version(p__version character varying) OWNER TO evex;

--
-- Name: column_exists(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.column_exists(column_exists__table_name character varying, column_exists__column_name character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN

        return count(*) > 0
          from pg_class c, pg_attribute a
         where c.relname = lower(column_exists__table_name)
           and c.oid = a.attrelid
           and a.attname = lower(column_exists__column_name);

END;
$$;


ALTER FUNCTION public.column_exists(column_exists__table_name character varying, column_exists__column_name character varying) OWNER TO evex;

--
-- Name: composition_rel__check_index(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.composition_rel__check_index(check_index__component_id integer, check_index__container_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result                              boolean;       
  n_rows                              integer;       
  dc                                  record;
  r1                                  record;
  r2                                  record;
BEGIN
    result := 't';

    -- Loop through all the direct containers (DC) of COMPONENT_ID
    -- that are also contained by CONTAINER_ID and verify that the
    -- GROUP_COMPONENT_INDEX contains the (GROUP_ID, DC.REL_ID,
    -- CONTAINER_ID) triple.
    for dc in  select r.rel_id, r.object_id_one as container_id
               from acs_rels r, composition_rels c
               where r.rel_id = c.rel_id
               and r.object_id_two = check_index__component_id 
    LOOP

      if composition_rel__check_path_exists_p(dc.container_id,
                             check_index__container_id) = 't' then
        select case when count(*) = 0 then 0 else 1 end into n_rows
        from group_component_index
        where group_id = check_index__container_id
        and component_id = check_index__component_id
        and rel_id = dc.rel_id;

        if n_rows = 0 then
          result := 'f';
          PERFORM acs_log__error('composition_rel.check_representation',
                        'Row missing from group_component_index for (' ||
                        'group_id = ' || check_index__container_id || ', ' ||
                        'component_id = ' || check_index__component_id || ', ' ||
                        'rel_id = ' || dc.rel_id || ')');
        end if;

      end if;

    end loop;

    -- Loop through all the containers of CONTAINER_ID.
    for r1 in  select r.object_id_one as container_id
               from acs_rels r, composition_rels c
               where r.rel_id = c.rel_id
               and r.object_id_two = check_index__container_id
               union
               select check_index__container_id as container_id
               from dual 
    LOOP
      -- Loop through all the components of COMPONENT_ID and make a
      -- recursive call.
      for r2 in  select r.object_id_two as component_id
                 from acs_rels r, composition_rels c
                 where r.rel_id = c.rel_id
                 and r.object_id_one = check_index__component_id
                 union
                 select check_index__component_id as component_id
                 from dual 
      LOOP
        if (r1.container_id != check_index__container_id or
            r2.component_id != check_index__component_id) and
           composition_rel__check_index(r2.component_id, r1.container_id) = 'f' then
          result := 'f';
        end if;
      end loop;
    end loop;

    return result;
   
END;
$$;


ALTER FUNCTION public.composition_rel__check_index(check_index__component_id integer, check_index__container_id integer) OWNER TO evex;

--
-- Name: composition_rel__check_path_exists_p(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.composition_rel__check_path_exists_p(component_id integer, container_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  row                    record;
BEGIN
    if component_id = container_id then
      return 't';
    end if;

    for row in  select r.object_id_one as parent_id
                from acs_rels r, composition_rels c
                where r.rel_id = c.rel_id
                and r.object_id_two = component_id 
    LOOP
      if composition_rel__check_path_exists_p(row.parent_id, container_id) = 't' then
        return 't';
      end if;
    end loop;

    return 'f';
   
END;
$$;


ALTER FUNCTION public.composition_rel__check_path_exists_p(component_id integer, container_id integer) OWNER TO evex;

--
-- Name: composition_rel__check_representation(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.composition_rel__check_representation(check_representation__rel_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  container_id                                 groups.group_id%TYPE;
  component_id                                 groups.group_id%TYPE;
  result                                       boolean;     
  row                                          record;  
BEGIN
    result := 't';

    if acs_object__check_representation(check_representation__rel_id) = 'f' then
      result := 'f';
    end if;

    select object_id_one, object_id_two
    into container_id, component_id
    from acs_rels
    where rel_id = check_representation__rel_id;

    -- First let us check that the index has all the rows it should.
    if composition_rel__check_index(component_id, container_id) = 'f' then
      result := 'f';
    end if;

    -- Now let us check that the index doesn't have any extraneous rows
    -- relating to this relation.
    for row in  select *
                from group_component_index
                where rel_id = check_representation__rel_id  
    LOOP
      if composition_rel__check_path_exists_p(row.component_id, row.group_id) = 'f' then
        result := 'f';
        PERFORM acs_log__error('composition_rel.check_representation',
                      'Extraneous row in group_component_index: ' ||
                      'group_id = ' || row.group_id || ', ' ||
                      'component_id = ' || row.component_id || ', ' ||
                      'rel_id = ' || row.rel_id || ', ' ||
                      'container_id = ' || row.container_id || '.');
      end if;
    end loop;

    return result;
   
END;
$$;


ALTER FUNCTION public.composition_rel__check_representation(check_representation__rel_id integer) OWNER TO evex;

--
-- Name: composition_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.composition_rel__delete(rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    PERFORM acs_rel__delete(rel_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.composition_rel__delete(rel_id integer) OWNER TO evex;

--
-- Name: composition_rel__new(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.composition_rel__new(object_id_one integer, object_id_two integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- composition_rel__new/2 maybe obsolete, when we define proper defaults for /6
--
DECLARE
BEGIN
        return composition_rel__new(null,
                                    'composition_rel',
                                    object_id_one,
                                    object_id_two,
                                    null,
                                    null);
END;
$$;


ALTER FUNCTION public.composition_rel__new(object_id_one integer, object_id_two integer) OWNER TO evex;

--
-- Name: composition_rel__new(integer, character varying, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.composition_rel__new(new__rel_id integer, rel_type character varying, object_id_one integer, object_id_two integer, creation_user integer, creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_rel_id               integer;       
BEGIN
    raise NOTICE 'composition_rel__new one % two %', object_id_one, object_id_two;
    v_rel_id := acs_rel__new (
      new__rel_id,
      rel_type,
      object_id_one,
      object_id_two,
      object_id_one,
      creation_user,
      creation_ip
    );

    insert into composition_rels
     (rel_id)
    values
     (v_rel_id);

    return v_rel_id;
   
END;
$$;


ALTER FUNCTION public.composition_rel__new(new__rel_id integer, rel_type character varying, object_id_one integer, object_id_two integer, creation_user integer, creation_ip character varying) OWNER TO evex;

--
-- Name: composition_rels_del_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.composition_rels_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_object_id_one acs_rels.object_id_one%TYPE;
  v_object_id_two acs_rels.object_id_two%TYPE;
  n_rows          integer;
  v_error         text;
  map             record;
BEGIN
  -- First check if removing this relation would violate any relational constraints
  v_error := rel_constraint__violation_if_removed(old.rel_id);
  if v_error is not null then
      raise EXCEPTION '-20000: %', v_error;
  end if;

  select object_id_one, object_id_two into v_object_id_one, v_object_id_two
  from acs_rels
  where rel_id = old.rel_id;

  for map in  select *
	      from group_component_map
	      where rel_id = old.rel_id 
  LOOP

    delete from group_element_index
    where rel_id = old.rel_id;

    select count(*) into n_rows
    from group_component_map
    where group_id = map.group_id
    and component_id = map.component_id;

    if n_rows = 0 then

      perform party_approved_member__remove(map.group_id, member_id, rel_id, rel_type)
      from group_approved_member_map
      where group_id = map.group_id
      and container_id = map.component_id;

      delete from group_element_index
      where group_id = map.group_id
      and container_id = map.component_id
      and ancestor_rel_type = 'membership_rel';
    end if;

  end loop;


  for map in  select *
              from group_component_map
	      where group_id in (select group_id
		               from group_component_map
		               where component_id = v_object_id_one
			       union
			       select v_object_id_one
			       from dual)
              and component_id in (select component_id
			           from group_component_map
			           where group_id = v_object_id_two
				   union
				   select v_object_id_two
				   from dual)
              and group_contains_p(group_id, component_id, rel_id) = 'f' 
  LOOP

    delete from group_element_index
    where group_id = map.group_id
    and element_id = map.component_id
    and rel_id = map.rel_id;

    select count(*) into n_rows
    from group_component_map
    where group_id = map.group_id
    and component_id = map.component_id;

    if n_rows = 0 then
    end if;

      perform party_approved_member__remove(map.group_id, member_id, rel_id, rel_type)
      from group_approved_member_map
      where group_id = map.group_id
      and container_id = map.component_id;

      delete from group_element_index
      where group_id = map.group_id
      and container_id = map.component_id
      and ancestor_rel_type = 'membership_rel';

  end loop;

  return old;

END;
$$;


ALTER FUNCTION public.composition_rels_del_tr() OWNER TO evex;

--
-- Name: composition_rels_in_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.composition_rels_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_object_id_one acs_rels.object_id_one%TYPE;
  v_object_id_two acs_rels.object_id_two%TYPE;
  v_rel_type      acs_rels.rel_type%TYPE;
  v_error         text;
  map             record;
BEGIN
  
  -- First check if added this relation violated any relational constraints
  v_error := rel_constraint__violation(new.rel_id);

  if v_error is not null then
      raise EXCEPTION '-20000: %', v_error;
  end if;

  select object_id_one, object_id_two, rel_type
  into v_object_id_one, v_object_id_two, v_rel_type
  from acs_rels
  where rel_id = new.rel_id;

  -- Insert a row for me in group_element_index
  insert into group_element_index
   (group_id, element_id, rel_id, container_id,
    rel_type, ancestor_rel_type)
  values
   (v_object_id_one, v_object_id_two, new.rel_id, v_object_id_one,
    v_rel_type, 'composition_rel');

  -- Add to the denormalized party_approved_member_map

  perform party_approved_member__add(v_object_id_one, member_id, rel_id, rel_type)
  from group_approved_member_map m
  where group_id = v_object_id_two
  and not exists (select 1
		  from group_element_map
		  where group_id = v_object_id_one
		  and element_id = m.member_id
		  and rel_id = m.rel_id);

  -- Make my composable elements be elements of my new composite group
  insert into group_element_index
   (group_id, element_id, rel_id, container_id,
    rel_type, ancestor_rel_type)
  select distinct
   v_object_id_one, element_id, rel_id, container_id,
   m.rel_type, ancestor_rel_type
  from group_element_map m
  join acs_rel_types t on (m.rel_type = t.rel_type)
  where group_id = v_object_id_two
  and t.composable_p = 't'
  and not exists (select 1
		  from group_element_map
		  where group_id = v_object_id_one
		  and element_id = m.element_id
		  and rel_id = m.rel_id);

  -- For all direct or indirect containers of my new composite group, 
  -- add me and add my elements
  for map in  select distinct group_id
	      from group_component_map
	      where component_id = v_object_id_one 
  LOOP

    -- Add a row for me

    insert into group_element_index
     (group_id, element_id, rel_id, container_id,
      rel_type, ancestor_rel_type)
    values
     (map.group_id, v_object_id_two, new.rel_id, v_object_id_one,
      v_rel_type, 'composition_rel');

    -- Add to party_approved_member_map

    perform party_approved_member__add(map.group_id, member_id, rel_id, m.rel_type)
    from group_approved_member_map m
    join acs_rel_types t on (m.rel_type = t.rel_type)
    where group_id = v_object_id_two
    and t.composable_p = 't'
    and not exists (select 1
		    from group_element_map
		    where group_id = map.group_id
		    and element_id = m.member_id
		    and rel_id = m.rel_id);

    -- Add rows for my composable elements

    insert into group_element_index
     (group_id, element_id, rel_id, container_id,
      rel_type, ancestor_rel_type)
    select distinct
     map.group_id, element_id, rel_id, container_id,
     m.rel_type, ancestor_rel_type
    from group_element_map m
    join acs_rel_types t on (m.rel_type = t.rel_type)
    where group_id = v_object_id_two
    and t.composable_p = 't'
    and not exists (select 1
		    from group_element_map
		    where group_id = map.group_id
		    and element_id = m.element_id
		    and rel_id = m.rel_id);
  end loop;

  return new;

END;
$$;


ALTER FUNCTION public.composition_rels_in_tr() OWNER TO evex;

--
-- Name: content_extlink__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_extlink__copy(copy__extlink_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
--
-- content_extlink__copy/4 maybe obsolete, when we define proper defaults for /5
--
DECLARE
  v_extlink_id                 cr_extlinks.extlink_id%TYPE;
BEGIN
	v_extlink_id := content_extlink__copy (
		copy__extlink_id,
		copy__target_folder_id,
		copy__creation_user,
		copy__creation_ip,
		NULL
	);
	return 0;
END;
$$;


ALTER FUNCTION public.content_extlink__copy(copy__extlink_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying) OWNER TO evex;

--
-- Name: content_extlink__copy(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_extlink__copy(copy__extlink_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying, copy__name character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_url                        cr_extlinks.url%TYPE;
  v_description                cr_extlinks.description%TYPE;
  v_label                      cr_extlinks.label%TYPE;
  v_extlink_id                 cr_extlinks.extlink_id%TYPE;
BEGIN

  if content_folder__is_folder(copy__target_folder_id) = 't' then
    select
      parent_id
    into
      v_current_folder_id
    from
      cr_items
    where
      item_id = copy__extlink_id;

    -- can't copy to the same folder

    select
      i.name, e.url, e.description, e.label
    into
      v_name, v_url, v_description, v_label
    from
      cr_extlinks e, cr_items i
    where
      e.extlink_id = i.item_id
    and
      e.extlink_id = copy__extlink_id;
	
	-- copy to a different folder, or same folder if name
	-- is different
    if copy__target_folder_id != v_current_folder_id  or ( v_name <> copy__name and copy__name is not null ) then

      if content_folder__is_registered(copy__target_folder_id,
        'content_extlink','f') = 't' then

        v_extlink_id := content_extlink__new(
            coalesce (copy__name, v_name),
            v_url,
            v_label,
            v_description,
            copy__target_folder_id,
            null,
            current_timestamp,
	    copy__creation_user,
	    copy__creation_ip,
            null
        );

      end if;
    end if;
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_extlink__copy(copy__extlink_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying, copy__name character varying) OWNER TO evex;

--
-- Name: content_extlink__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_extlink__delete(delete__extlink_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  delete from cr_extlinks
    where extlink_id = delete__extlink_id;

  PERFORM content_item__delete(delete__extlink_id);

return 0; 
END;
$$;


ALTER FUNCTION public.content_extlink__delete(delete__extlink_id integer) OWNER TO evex;

--
-- Name: content_extlink__is_extlink(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_extlink__is_extlink(is_extlink__item_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_extlink_p                        boolean;
BEGIN

  select 
    count(1) = 1 into v_extlink_p
  from 
    cr_extlinks
  where 
    extlink_id = is_extlink__item_id;
  
  return v_extlink_p;
 
END;
$$;


ALTER FUNCTION public.content_extlink__is_extlink(is_extlink__item_id integer) OWNER TO evex;

--
-- Name: content_extlink__new(character varying, character varying, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_extlink__new(new__name character varying, new__url character varying, new__label character varying, new__description character varying, new__parent_id integer, new__extlink_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_extlink__new/9 maybe obsolete, when we define proper defaults for /10
--
DECLARE
BEGIN
  return content_extlink__new(new__name,
                              new__url,
                              new__label,
                              new__description,
                              new__parent_id,
                              new__extlink_id,
                              new__creation_date,
                              new__creation_user,
                              new__creation_ip,
                              null
  );

END;
$$;


ALTER FUNCTION public.content_extlink__new(new__name character varying, new__url character varying, new__label character varying, new__description character varying, new__parent_id integer, new__extlink_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) OWNER TO evex;

--
-- Name: content_extlink__new(character varying, character varying, character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_extlink__new(new__name character varying, new__url character varying, new__label character varying, new__description character varying, new__parent_id integer, new__extlink_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_extlink_id                cr_extlinks.extlink_id%TYPE;
  v_package_id                acs_objects.package_id%TYPE;
  v_label                     cr_extlinks.label%TYPE;
  v_name                      cr_items.name%TYPE;
BEGIN

  if new__label is null then
    v_label := new__url;
  else
    v_label := new__label;
  end if;

  if new__name is null then
    select nextval('t_acs_object_id_seq') into v_extlink_id from dual;
    v_name := 'link' || v_extlink_id;
  else
    v_name := new__name;
  end if;

  if new__package_id is null then
    v_package_id := acs_object__package_id(new__parent_id);
  else
    v_package_id := new__package_id;
  end if;

  v_extlink_id := content_item__new(
      v_name, 
      new__parent_id,
      new__extlink_id,
      null,
      new__creation_date, 
      new__creation_user, 
      null,
      new__creation_ip, 
      'content_item',
      'content_extlink', 
      null,
      null,
      'text/plain',
      null,      
      null,
      null,  -- data
      null,  -- relation_tag
      'f',   -- is_live      
      'text',
      v_package_id,
      't'    -- with_child_rels
  );

  insert into cr_extlinks
    (extlink_id, url, label, description)
  values
    (v_extlink_id, new__url, v_label, new__description);

  update acs_objects
  set title = v_label
  where object_id = v_extlink_id;

  return v_extlink_id;

END;
$$;


ALTER FUNCTION public.content_extlink__new(new__name character varying, new__url character varying, new__label character varying, new__description character varying, new__parent_id integer, new__extlink_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer) OWNER TO evex;

--
-- Name: content_folder__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__copy(copy__folder_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_valid_folders_p            integer;        
  v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_label                      cr_folders.label%TYPE;
  v_description                cr_folders.description%TYPE;
  v_new_folder_id              cr_folders.folder_id%TYPE;
  v_folder_contents_val        record;
BEGIN
	v_new_folder_id := content_folder__copy (
			copy__folder_id,
			copy__target_folder_id,
			copy__creation_user,
			copy__creation_ip,
			NULL
			);
	return v_new_folder_id;
END;
$$;


ALTER FUNCTION public.content_folder__copy(copy__folder_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying) OWNER TO evex;

--
-- Name: content_folder__copy(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__copy(copy__folder_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying, copy__name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_valid_folders_p            integer;
  v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_label                      cr_folders.label%TYPE;
  v_description                cr_folders.description%TYPE;
  v_new_folder_id              cr_folders.folder_id%TYPE;
  v_folder_contents_val        record;
BEGIN

  if copy__folder_id = content_item__get_root_folder(null) 
     or copy__folder_id = content_template__get_root_folder() then
     raise EXCEPTION '-20000: content_folder.copy - Not allowed to copy root folder';
  end if;

  select 
    count(*)
  into 
    v_valid_folders_p
  from 
    cr_folders
  where
    folder_id = copy__target_folder_id
  or 
    folder_id = copy__folder_id;

  if v_valid_folders_p != 2 then 
    raise EXCEPTION '-20000: content_folder.copy - Invalid folder(s)';
  end if;

  if copy__target_folder_id = copy__folder_id then 
    raise EXCEPTION '-20000: content_folder.copy - Cannot copy folder to itself';
  end if;
  
  if content_folder__is_sub_folder(copy__folder_id, copy__target_folder_id) = 't' then
    raise EXCEPTION '-20000: content_folder.copy - Destination folder is subfolder';
  end if;

  if content_folder__is_registered(copy__target_folder_id,'content_folder','f') != 't' then
    raise EXCEPTION '-20000: content_folder.copy - Destination folder does not allow subfolders';
  end if;

  -- get the source folder info
  select
    name, label, description, parent_id
  into
    v_name, v_label, v_description, v_current_folder_id
  from 
    cr_items i, cr_folders f
  where
    f.folder_id = i.item_id
  and
    f.folder_id = copy__folder_id;

  -- would be better to check if the copy__name alredy exists in the destination folder.

  if v_current_folder_id = copy__target_folder_id and (v_name = copy__name or copy__name is null) then
    raise EXCEPTION '-20000: content_folder.copy - Destination folder is parent folder and folder alredy exists';
  end if;

      -- create the new folder
      v_new_folder_id := content_folder__new(
          coalesce (copy__name, v_name),
	  v_label,
	  v_description,
	  copy__target_folder_id,
	  copy__target_folder_id,
          null,
          now(),
	  copy__creation_user,
	  copy__creation_ip,
          't',
          null
      );

      -- copy attributes of original folder
      insert into cr_folder_type_map
        select 
          v_new_folder_id as folder_id, content_type
        from
          cr_folder_type_map map
        where
          folder_id = copy__folder_id
        and
	  -- do not register content_type if it is already registered
          not exists ( select 1 from cr_folder_type_map
	               where folder_id = v_new_folder_id 
		       and content_type = map.content_type ) ;

      -- for each item in the folder, copy it
      for v_folder_contents_val in select
                                     item_id
                                   from
                                     cr_items
                                   where
                                     parent_id = copy__folder_id 
      LOOP
        
	PERFORM content_item__copy(
	    v_folder_contents_val.item_id,
	    v_new_folder_id,
	    copy__creation_user,
	    copy__creation_ip,
            null
	);

      end loop;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_folder__copy(copy__folder_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying, copy__name character varying) OWNER TO evex;

--
-- Name: content_folder__del(integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__del(delete__folder_id integer, p_cascade_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count                        integer;       
  v_child_row                    record;
  v_parent_id                    integer;  
  v_path                         varchar;     
  v_folder_sortkey               varbit;
BEGIN

  if p_cascade_p = 'f' then
    select count(*) into v_count from cr_items 
     where parent_id = delete__folder_id;
    -- check if the folder contains any items
    if v_count > 0 then
      v_path := content_item__get_path(delete__folder_id, null);
      raise EXCEPTION '-20000: Folder ID % (%) cannot be deleted because it is not empty.', delete__folder_id, v_path;
    end if;  
  else 
  -- delete children
    select into v_folder_sortkey tree_sortkey
    from cr_items where item_id=delete__folder_id;

    for v_child_row in select
        item_id, tree_sortkey, name
        from cr_items
        where tree_sortkey between v_folder_sortkey and tree_right(v_folder_sortkey)   
	and tree_sortkey != v_folder_sortkey
        order by tree_sortkey desc
    loop
	if content_folder__is_folder(v_child_row.item_id) then
	  perform content_folder__delete(v_child_row.item_id);
        else
         perform content_item__delete(v_child_row.item_id);
	end if;
    end loop;
  end if;

  PERFORM content_folder__unregister_content_type(
      delete__folder_id,
      'content_revision',
      't' 
  );

  delete from cr_folder_type_map
    where folder_id = delete__folder_id;

  select parent_id into v_parent_id from cr_items 
    where item_id = delete__folder_id;
  raise notice 'deleteing folder %',delete__folder_id;
  PERFORM content_item__delete(delete__folder_id);

  -- check if any folders are left in the parent
  update cr_folders set has_child_folders = 'f' 
    where folder_id = v_parent_id and not exists (
      select 1 from cr_items 
        where parent_id = v_parent_id and content_type = 'content_folder');

  return 0; 
END;
$$;


ALTER FUNCTION public.content_folder__del(delete__folder_id integer, p_cascade_p boolean) OWNER TO evex;

--
-- Name: content_folder__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__delete(delete__folder_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_folder__delete/1 maybe obsolete, when we define proper defaults for /2
--
DECLARE
  v_count                        integer;       
  v_parent_id                    integer;  
  v_path                         varchar;     
BEGIN
	return content_folder__del(
		delete__folder_id,
		'f'
		);
END;
$$;


ALTER FUNCTION public.content_folder__delete(delete__folder_id integer) OWNER TO evex;

--
-- Name: content_folder__delete(integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__delete(delete__folder_id integer, p_cascade_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        PERFORM content_folder__del(delete__folder_id,p_cascade_p);
  return 0; 
END;
$$;


ALTER FUNCTION public.content_folder__delete(delete__folder_id integer, p_cascade_p boolean) OWNER TO evex;

--
-- Name: content_folder__edit_name(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__edit_name(edit_name__folder_id integer, edit_name__name character varying, edit_name__label character varying, edit_name__description character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_name_already_exists_p        integer;
BEGIN

  if edit_name__name is not null and edit_name__name != '' then
    PERFORM content_item__edit_name(edit_name__folder_id, edit_name__name);
  end if;

  if edit_name__label is not null and edit_name__label != '' then
    update acs_objects
    set title = edit_name__label
    where object_id = edit_name__folder_id;
  end if;

  if edit_name__label is not null and edit_name__label != '' and 
     edit_name__description is not null and edit_name__description != '' then 

    update cr_folders
      set label = edit_name__label,
      description = edit_name__description
      where folder_id = edit_name__folder_id;

  else if(edit_name__label is not null and edit_name__label != '') and 
         (edit_name__description is null or edit_name__description = '') then  
    update cr_folders
      set label = edit_name__label
      where folder_id = edit_name__folder_id;

  end if; end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_folder__edit_name(edit_name__folder_id integer, edit_name__name character varying, edit_name__label character varying, edit_name__description character varying) OWNER TO evex;

--
-- Name: content_folder__get_index_page(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__get_index_page(get_index_page__folder_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_folder_id                            cr_folders.folder_id%TYPE;
  v_index_page_id                        cr_items.item_id%TYPE;
BEGIN

  -- if the folder is a symlink, resolve it
  if content_symlink__is_symlink(get_index_page__folder_id) = 't' then
    v_folder_id := content_symlink__resolve(get_index_page__folder_id);
  else
    v_folder_id := get_index_page__folder_id;
  end if;

  select
    item_id into v_index_page_id
  from
    cr_items
  where
    parent_id = v_folder_id
  and
    name = 'index'
  and
    content_item__is_subclass(
      content_item__get_content_type(content_symlink__resolve(item_id)),
    'content_folder') = 'f'
  and
    content_item__is_subclass(
      content_item__get_content_type(content_symlink__resolve(item_id)),
    'content_template') = 'f';

  if NOT FOUND then 
     return null;
  end if;

  return v_index_page_id;

END;
$$;


ALTER FUNCTION public.content_folder__get_index_page(get_index_page__folder_id integer) OWNER TO evex;

--
-- Name: content_folder__get_label(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__get_label(get_label__folder_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_label                           cr_folders.label%TYPE;
BEGIN

  select 
    label into v_label 
  from 
    cr_folders       
  where 
    folder_id = get_label__folder_id;

  return v_label;
 
END;
$$;


ALTER FUNCTION public.content_folder__get_label(get_label__folder_id integer) OWNER TO evex;

--
-- Name: content_folder__is_empty(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__is_empty(is_empty__folder_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_return                         boolean;    
BEGIN

  select
    count(*) = 0 into v_return
  from
    cr_items
  where
    parent_id = is_empty__folder_id;

  return v_return;
 
END;
$$;


ALTER FUNCTION public.content_folder__is_empty(is_empty__folder_id integer) OWNER TO evex;

--
-- Name: content_folder__is_folder(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__is_folder(item_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN

  return count(*) > 0 from cr_folders
    where folder_id = item_id;

END;
$$;


ALTER FUNCTION public.content_folder__is_folder(item_id integer) OWNER TO evex;

--
-- Name: content_folder__is_registered(integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__is_registered(is_registered__folder_id integer, is_registered__content_type character varying, is_registered__include_subtypes boolean) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_is_registered                       integer;
  v_subtype_val                         record;
BEGIN

  if is_registered__include_subtypes = 'f' or  is_registered__include_subtypes is null then
    select 
      count(1)
    into 
      v_is_registered
    from
      cr_folder_type_map
    where
      folder_id = is_registered__folder_id
    and
      content_type = is_registered__content_type;

  else
--                         select
--                            object_type
--                          from 
--                            acs_object_types
--                          where 
--                            object_type <> 'acs_object'
--                          connect by 
--                            prior object_type = supertype
--                          start with 
--                            object_type = is_registered.content_type 

    v_is_registered := 1;
    for v_subtype_val in select o.object_type
                         from acs_object_types o, acs_object_types o2
                         where o.object_type <> 'acs_object'
                           and o2.object_type = is_registered__content_type
                           and o.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey)
                         order by o.tree_sortkey
    LOOP
      if content_folder__is_registered(is_registered__folder_id,
                       v_subtype_val.object_type, 'f') = 'f' then
        v_is_registered := 0;
      end if;
    end loop;
  end if;

  if v_is_registered = 0 then
    return 'f';
  else
    return 't';
  end if;
 
END;
$$;


ALTER FUNCTION public.content_folder__is_registered(is_registered__folder_id integer, is_registered__content_type character varying, is_registered__include_subtypes boolean) OWNER TO evex;

--
-- Name: content_folder__is_root(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__is_root(is_root__folder_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_is_root                       boolean;       
BEGIN

  select parent_id = -4 into v_is_root 
    from cr_items where item_id = is_root__folder_id;

  return v_is_root;
 
END;
$$;


ALTER FUNCTION public.content_folder__is_root(is_root__folder_id integer) OWNER TO evex;

--
-- Name: content_folder__is_sub_folder(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__is_sub_folder(is_sub_folder__folder_id integer, is_sub_folder__target_folder_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_parent_id                           integer default 0;       
  v_sub_folder_p                        boolean default 'f';           
  v_rec                                 record;
BEGIN

  if is_sub_folder__folder_id = content_item__get_root_folder(null) or
    is_sub_folder__folder_id = content_template__get_root_folder() then

    v_sub_folder_p := 't';
  end if;

--               select
--                 parent_id
--               from 
--                 cr_items
--               connect by
--                 prior parent_id = item_id
--               start with
--                 item_id = is_sub_folder__target_folder_id

  for v_rec in select i2.parent_id
               from cr_items i1, cr_items i2
               where i1.item_id = is_sub_folder__target_folder_id
                 and i1.tree_sortkey between i2.tree_sortkey and tree_right(i2.tree_sortkey)
               order by i2.tree_sortkey desc
  LOOP
    v_parent_id := v_rec.parent_id;
    exit when v_parent_id = is_sub_folder__folder_id;
    -- we did not find the folder, reset v_parent_id
    v_parent_id := -4;
  end LOOP;

  if v_parent_id != -4 then 
    v_sub_folder_p := 't';
  end if;

  return v_sub_folder_p;
 
END;
$$;


ALTER FUNCTION public.content_folder__is_sub_folder(is_sub_folder__folder_id integer, is_sub_folder__target_folder_id integer) OWNER TO evex;

--
-- Name: content_folder__move(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__move(move__folder_id integer, move__target_folder_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_folder__move/2 maybe obsolete, when we define proper defaults for /3
--
DECLARE
BEGIN

  perform content_folder__move (
                                move__folder_id,
                                move__target_folder_id,
                                NULL
                               );
  return null;
END;
$$;


ALTER FUNCTION public.content_folder__move(move__folder_id integer, move__target_folder_id integer) OWNER TO evex;

--
-- Name: content_folder__move(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__move(move__folder_id integer, move__target_folder_id integer, move__name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_source_folder_id           integer;       
  v_valid_folders_p            integer;
BEGIN

  select 
    count(*)
  into 
    v_valid_folders_p
  from 
    cr_folders
  where
    folder_id = move__target_folder_id
  or 
    folder_id = move__folder_id;

  if v_valid_folders_p != 2 then
    raise EXCEPTION '-20000: content_folder.move - Not valid folder(s)';
  end if;

  if move__folder_id = content_item__get_root_folder(null) or
    move__folder_id = content_template__get_root_folder() then
    raise EXCEPTION '-20000: content_folder.move - Cannot move root folder';
  end if;
  
  if move__target_folder_id = move__folder_id then
    raise EXCEPTION '-20000: content_folder.move - Cannot move a folder to itself';
  end if;

  if content_folder__is_sub_folder(move__folder_id, move__target_folder_id) = 't' then
    raise EXCEPTION '-20000: content_folder.move - Destination folder is subfolder';
  end if;

  if content_folder__is_registered(move__target_folder_id,'content_folder','f') != 't' then
    raise EXCEPTION '-20000: content_folder.move - Destination folder does not allow subfolders';
  end if;

  select parent_id into v_source_folder_id from cr_items 
    where item_id = move__folder_id;

   -- update the parent_id for the folder
   update cr_items 
     set parent_id = move__target_folder_id,
         name = coalesce ( move__name, name )
     where item_id = move__folder_id;

  -- update the has_child_folders flags

  -- update the source
  update cr_folders set has_child_folders = 'f' 
    where folder_id = v_source_folder_id and not exists (
      select 1 from cr_items 
        where parent_id = v_source_folder_id 
          and content_type = 'content_folder');

  -- update the destination
  update cr_folders set has_child_folders = 't'
    where folder_id = move__target_folder_id;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_folder__move(move__folder_id integer, move__target_folder_id integer, move__name character varying) OWNER TO evex;

--
-- Name: content_folder__new(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_folder__new/4 maybe obsolete, when we define proper defaults for /11
--
DECLARE
BEGIN
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   null,
                                   null,
                                   now(),
                                   null,
                                   null,
                                   't',
                                   null
               );

END;
$$;


ALTER FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer) OWNER TO evex;

--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_folder__new/5 maybe obsolete, when we define proper defaults for /11
--
DECLARE
BEGIN
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   null,
                                   null,
                                   now(),
                                   null,
                                   null,
                                   new__package_id
               );

END;
$$;


ALTER FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__package_id integer) OWNER TO evex;

--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__context_id integer, new__folder_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_folder__new/9 maybe obsolete, when we define proper defaults for /11
--
DECLARE
BEGIN
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   new__context_id,
                                   new__folder_id,
                                   new__creation_date,
                                   new__creation_user,
                                   new__creation_ip,
                                   't',
                                   null::integer
               );

END;
$$;


ALTER FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__context_id integer, new__folder_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) OWNER TO evex;

--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__context_id integer, new__folder_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__security_inherit_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_folder__new/10 maybe obsolete, when we define proper defaults for /11
--
DECLARE
BEGIN
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   new__context_id,
                                   new__folder_id,
                                   new__creation_date,
                                   new__creation_user,
                                   new__creation_ip,
                                   new__security_inherit_p,
                                   null::integer
               );

END;
$$;


ALTER FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__context_id integer, new__folder_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__security_inherit_p boolean) OWNER TO evex;

--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__context_id integer, new__folder_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_folder__new/10 maybe obsolete, when we define proper defaults for /11
--
DECLARE
  v_folder_id                 cr_folders.folder_id%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
  v_package_id                acs_objects.package_id%TYPE;
BEGIN
        return content_folder__new(new__name,
                                   new__label,
                                   new__description,
                                   new__parent_id,
                                   new__context_id,
                                   new__folder_id,
                                   new__creation_date,
                                   new__creation_user,
                                   new__creation_ip,
                                   't',
                                   new__package_id
               );
END;
$$;


ALTER FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__context_id integer, new__folder_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer) OWNER TO evex;

--
-- Name: content_folder__new(character varying, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__context_id integer, new__folder_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__security_inherit_p boolean, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_folder_id                 cr_folders.folder_id%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
BEGIN

  -- set the context_id
  if new__context_id is null then
    v_context_id := new__parent_id;
  else
    v_context_id := new__context_id;
  end if;

  -- parent_id = security_context_root means that this is a mount point
  if new__parent_id != -4 and 
    content_folder__is_folder(new__parent_id) and
    content_folder__is_registered(new__parent_id,'content_folder','f') = 'f' then

    raise EXCEPTION '-20000: This folder does not allow subfolders to be created';
    return null;

  else

    v_folder_id := content_item__new(
	new__folder_id,
	new__name, 
        new__parent_id,
        null,
        new__creation_date, 
        new__creation_user, 
	new__context_id,
	new__creation_ip, 
	'f',
	'text/plain',
	null,
	'text',
	new__security_inherit_p,
	'CR_FILES',
	'content_folder',
        'content_folder',
        new__package_id
    );

    insert into cr_folders (
      folder_id, label, description, package_id
    ) values (
      v_folder_id, new__label, new__description, new__package_id
    );

    -- set the correct object title
    update acs_objects
    set title = new__label
    where object_id = v_folder_id;

    -- inherit the attributes of the parent folder
    if new__parent_id is not null then
    
      insert into cr_folder_type_map
        select
          v_folder_id as folder_id, content_type
        from
          cr_folder_type_map

where
          folder_id = new__parent_id;
    end if;

    -- update the child flag on the parent
    update cr_folders set has_child_folders = 't'
      where folder_id = new__parent_id;

    return v_folder_id;

  end if;

  return v_folder_id; 
END;
$$;


ALTER FUNCTION public.content_folder__new(new__name character varying, new__label character varying, new__description character varying, new__parent_id integer, new__context_id integer, new__folder_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__security_inherit_p boolean, new__package_id integer) OWNER TO evex;

--
-- Name: content_folder__register_content_type(integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__register_content_type(register_content_type__folder_id integer, register_content_type__content_type character varying, register_content_type__include_subtypes boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_is_registered boolean;  
BEGIN

  if register_content_type__include_subtypes = 'f' then

    v_is_registered := content_folder__is_registered(
        register_content_type__folder_id,
	register_content_type__content_type, 
	'f' 
    );

    if v_is_registered = 'f' then

        insert into cr_folder_type_map (
	  folder_id, content_type
	) values (
	  register_content_type__folder_id, 
	  register_content_type__content_type
	);

    end if;

  else

--    insert into cr_folder_type_map
--      select 
--        register_content_type__folder_id as folder_id, 
--        object_type as content_type
--      from
--        acs_object_types
--      where
--        object_type <> 'acs_object'
--      and
--        not exists (select 1 from cr_folder_type_map
--                    where folder_id = register_content_type__folder_id
--                    and content_type = acs_object_types.object_type)
--      connect by 
--        prior object_type = supertype
--      start with 
--        object_type = register_content_type__content_type;
    
    insert into cr_folder_type_map
      select register_content_type__folder_id as folder_id, 
        o.object_type as content_type
      from acs_object_types o, acs_object_types o2
      where o.object_type <> 'acs_object'
        and not exists (select 1
                        from cr_folder_type_map
                        where folder_id = register_content_type__folder_id
                          and content_type = o.object_type)
        and o2.object_type = register_content_type__content_type
        and o.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey);
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_folder__register_content_type(register_content_type__folder_id integer, register_content_type__content_type character varying, register_content_type__include_subtypes boolean) OWNER TO evex;

--
-- Name: content_folder__unregister_content_type(integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_folder__unregister_content_type(unregister_content_type__folder_id integer, unregister_content_type__content_type character varying, unregister_content_type__include_subtypes boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  if unregister_content_type__include_subtypes = 'f' then
    delete from cr_folder_type_map
      where folder_id = unregister_content_type__folder_id
      and content_type = unregister_content_type__content_type;
  else

--    delete from cr_folder_type_map
--    where folder_id = unregister_content_type__folder_id
--    and content_type in (select object_type
--           from acs_object_types    
--	   where object_type <> 'acs_object'
--	   connect by prior object_type = supertype
--	   start with 
--             object_type = unregister_content_type__content_type);

    delete from cr_folder_type_map
    where folder_id = unregister_content_type__folder_id
    and content_type in (select o.object_type
                           from acs_object_types o, acs_object_types o2
	                  where o.object_type <> 'acs_object'
                            and o2.object_type = unregister_content_type__content_type
                            and o.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey));

  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_folder__unregister_content_type(unregister_content_type__folder_id integer, unregister_content_type__content_type character varying, unregister_content_type__include_subtypes boolean) OWNER TO evex;

--
-- Name: content_item__copy(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__copy(copy__item_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying DEFAULT NULL::character varying, copy__name character varying DEFAULT NULL::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_current_folder_id           cr_folders.folder_id%TYPE;
  v_num_revisions               integer;       
  v_name                        cr_items.name%TYPE;
  v_content_type                cr_items.content_type%TYPE;
  v_locale                      cr_items.locale%TYPE;
  v_item_id                     cr_items.item_id%TYPE;
  v_revision_id                 cr_revisions.revision_id%TYPE;
  v_is_registered               boolean;
  v_old_revision_id             cr_revisions.revision_id%TYPE;
  v_new_revision_id             cr_revisions.revision_id%TYPE;
  v_old_live_revision_id        cr_revisions.revision_id%TYPE;
  v_new_live_revision_id        cr_revisions.revision_id%TYPE;
  v_storage_type                cr_items.storage_type%TYPE;
BEGIN

  -- call content_folder.copy if the item is a folder
  if content_folder__is_folder(copy__item_id) = 't' then
    PERFORM content_folder__copy(
        copy__item_id,
        copy__target_folder_id,
        copy__creation_user,
        copy__creation_ip,
	copy__name
    ); 

  -- call content_symlink.copy if the item is a symlink
  else if content_symlink__is_symlink(copy__item_id) = 't' then
    PERFORM content_symlink__copy(
        copy__item_id,
        copy__target_folder_id,
        copy__creation_user,
        copy__creation_ip,
	copy__name
    );

  -- call content_extlink.copy if the item is an url
  else if content_extlink__is_extlink(copy__item_id) = 't' then
    PERFORM content_extlink__copy(
        copy__item_id,
        copy__target_folder_id,
        copy__creation_user,
        copy__creation_ip,
	copy__name
    );

  -- make sure the target folder is really a folder
  else if content_folder__is_folder(copy__target_folder_id) = 't' then

    select
      parent_id
    into
      v_current_folder_id
    from
      cr_items
    where
      item_id = copy__item_id;

    select
      content_type, name, locale,
      coalesce(live_revision, latest_revision), storage_type
    into
      v_content_type, v_name, v_locale, v_revision_id, v_storage_type
    from
      cr_items
    where
      item_id = copy__item_id;

    -- copy to a different folder, or allow copy to the same folder
    -- with a different name

    if copy__target_folder_id != v_current_folder_id  or ( v_name != copy__name and copy__name is not null ) then
      -- make sure the content type of the item is registered to the folder
      v_is_registered := content_folder__is_registered(
          copy__target_folder_id,
          v_content_type,
          'f'
      );

      if v_is_registered = 't' then
        --
        -- create the new content item via content_item__new/21
	--
        v_item_id := content_item__new(
            coalesce (copy__name, v_name),
            copy__target_folder_id,
            null,               -- item_id
            v_locale,
            now(),              -- creation_date
            copy__creation_user,
            null,               -- context_id
            copy__creation_ip,
            'content_item',            
            v_content_type,
            null,               -- title
            null,               -- description
            'text/plain',       -- mime_type
            null,               -- nls_language
            null,               -- text
            null,               -- data
            null,               -- relation_tag
            'f',                -- is_live	    
            v_storage_type,
	    null,               -- package_id
	    't'                 -- with_child_rels
        );

	select
          latest_revision, live_revision into v_old_revision_id, v_old_live_revision_id
        from
       	  cr_items
        where
       	  item_id = copy__item_id;
	end if;

        -- copy the latest revision (if any) to the new item
	if v_old_revision_id is not null then
          v_new_revision_id := content_revision__copy (
              v_old_revision_id,
              null,
              v_item_id,
              copy__creation_user,
              copy__creation_ip
          );
        end if;

        -- copy the live revision (if there is one and it differs from the latest) to the new item
	if v_old_live_revision_id is not null then
          if v_old_live_revision_id <> v_old_revision_id then
            v_new_live_revision_id := content_revision__copy (
              v_old_live_revision_id,
              null,
              v_item_id,
              copy__creation_user,
              copy__creation_ip
            );
          else
            v_new_live_revision_id := v_new_revision_id;
          end if;
        end if;

        update cr_items set live_revision = v_new_live_revision_id, latest_revision = v_new_revision_id where item_id = v_item_id;

    end if;

  end if; end if; end if; end if;

  return v_item_id;

END;
$$;


ALTER FUNCTION public.content_item__copy(copy__item_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying, copy__name character varying) OWNER TO evex;

--
-- Name: content_item__copy2(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__copy2(copy2__item_id integer, copy2__target_folder_id integer, copy2__creation_user integer, copy2__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

	perform content_item__copy (
		copy2__item_id,
		copy2__target_folder_id,
		copy2__creation_user,
		copy2__creation_ip,
		null
		);
	return copy2__item_id;

END;
$$;


ALTER FUNCTION public.content_item__copy2(copy2__item_id integer, copy2__target_folder_id integer, copy2__creation_user integer, copy2__creation_ip character varying) OWNER TO evex;

--
-- Name: content_item__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__del(delete__item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_revision_val record;
  v_child_val record;
BEGIN
  --
  -- Delete all revisions of this item
  --
  -- The following loop could be dropped / replaced by a cascade
  -- operation, when proper foreign keys are used along the
  -- inheritence path.
  --
  for v_revision_val in select revision_id 
                        from   cr_revisions
                        where  item_id = delete__item_id 
  LOOP
    PERFORM acs_object__delete(v_revision_val.revision_id);
  end loop;

  --
  -- Delete all children of this item via a recursive call.
  --
  -- The following loop is just needed to delete the revisions of
  -- child items. It could be removed, when proper foreign keys are
  -- used along the inheritence path of cr_content_revisions (which is
  -- not enforced and not always the case).
  --
  for v_child_val in select item_id
                      from   cr_items
                      where  parent_id = delete__item_id 
  LOOP     
     PERFORM content_item__delete(v_child_val.item_id);
  end loop; 

  --
  -- Finally, delete the acs_object of the item.
  --
  PERFORM acs_object__delete(delete__item_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__del(delete__item_id integer) OWNER TO evex;

--
-- Name: content_item__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__delete(delete__item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
   PERFORM content_item__del (delete__item_id);
   return 0; 
END;
$$;


ALTER FUNCTION public.content_item__delete(delete__item_id integer) OWNER TO evex;

--
-- Name: content_item__edit_name(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__edit_name(edit_name__item_id integer, edit_name__name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  exists_id                      integer;       
BEGIN
  select
    item_id
  into 
    exists_id
  from 
    cr_items
  where
    name = edit_name__name
  and 
    parent_id = (select 
	           parent_id
		 from
		   cr_items
		 where
		   item_id = edit_name__item_id);
  if NOT FOUND then
    update cr_items
      set name = edit_name__name
      where item_id = edit_name__item_id;

    update acs_objects
      set title = edit_name__name
      where object_id = edit_name__item_id;
  else
    if exists_id != edit_name__item_id then
      raise EXCEPTION '-20000: An item with the name % already exists in this directory.', edit_name__name;
    end if;
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__edit_name(edit_name__item_id integer, edit_name__name character varying) OWNER TO evex;

--
-- Name: content_item__generic_move(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__generic_move(move__item_id integer, move__target_item_id integer, move__name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  if move__target_item_id is null then 
	raise exception 'attempt to move item_id % to null folder_id', move__item_id;
  end if;

  if content_folder__is_folder(move__item_id) = 't' then

    PERFORM content_folder__move(move__item_id, move__target_item_id);

  elsif content_folder__is_folder(move__target_item_id) = 't' then

    if content_folder__is_registered(move__target_item_id,
          content_item__get_content_type(move__item_id),'f') = 't' and
       content_folder__is_registered(move__target_item_id,
          content_item__get_content_type(content_symlink__resolve(move__item_id)),'f') = 't'
      then
    end if;
  end if;

  -- update the parent_id for the item

  update cr_items 
    set parent_id = move__target_item_id,
        name = coalesce(move__name, name)
    where item_id = move__item_id;

  -- GN: the following "end if" appears to be not needed
  -- end if;

  if move__name is not null then
    update acs_objects
      set title = move__name
      where object_id = move__item_id;
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__generic_move(move__item_id integer, move__target_item_id integer, move__name character varying) OWNER TO evex;

--
-- Name: content_item__get_best_revision(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_best_revision(get_best_revision__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_revision_id                             cr_revisions.revision_id%TYPE;
BEGIN
    
  select
    coalesce(live_revision, latest_revision )
  into
    v_revision_id
  from
    cr_items
  where
    item_id = get_best_revision__item_id;

  return v_revision_id;
 
END;
$$;


ALTER FUNCTION public.content_item__get_best_revision(get_best_revision__item_id integer) OWNER TO evex;

--
-- Name: content_item__get_content_type(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_content_type(get_content_type__item_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_content_type                           cr_items.content_type%TYPE;
BEGIN

  select
    content_type into v_content_type
  from 
    cr_items
  where 
    item_id = get_content_type__item_id;  

  return v_content_type;
 
END;
$$;


ALTER FUNCTION public.content_item__get_content_type(get_content_type__item_id integer) OWNER TO evex;

--
-- Name: content_item__get_context(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_context(get_context__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_context_id                        acs_objects.context_id%TYPE;
BEGIN

  select
    context_id
  into
    v_context_id
  from
    acs_objects
  where
    object_id = get_context__item_id;

  if NOT FOUND then 
     raise EXCEPTION '-20000: Content item % does not exist in content_item.get_context', get_context__item_id;
  end if;

  return v_context_id;
 
END;
$$;


ALTER FUNCTION public.content_item__get_context(get_context__item_id integer) OWNER TO evex;

--
-- Name: content_item__get_id(character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_id(get_id__item_path character varying, get_id__root_folder_id integer, get_id__resolve_index boolean) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_item_path                    varchar; 
  v_root_folder_id               cr_items.item_id%TYPE;
  get_id__parent_id              integer;       
  child_id                       integer;       
  start_pos                      integer default 1;        
  end_pos                        integer;       
  counter                        integer default 1;
  item_name                      varchar;  
BEGIN

  if get_id__root_folder_id is null then
    select c_root_folder_id from content_item_globals into v_root_folder_id;
  else
    v_root_folder_id := get_id__root_folder_id;
  end if;

  -- If the request path is the root, then just return the root folder
  if get_id__item_path = '/' then
    return v_root_folder_id;
  end if;  

  -- Remove leading, trailing spaces, leading slashes
  v_item_path := rtrim(ltrim(trim(get_id__item_path), '/'), '/');

  get_id__parent_id := v_root_folder_id;

  -- if parent_id is a symlink, resolve it
  get_id__parent_id := content_symlink__resolve(get_id__parent_id);

  LOOP

    end_pos := instr(v_item_path, '/', 1, counter);

    if end_pos = 0 then
      item_name := substr(v_item_path, start_pos);
    else
      item_name := substr(v_item_path, start_pos, end_pos - start_pos);
      counter := counter + 1;
    end if;

    select 
      item_id into child_id
    from 
      cr_items
    where
      parent_id = get_id__parent_id
    and
      name = item_name;

    if NOT FOUND then 
       return null;
    end if;

    exit when end_pos = 0;

    get_id__parent_id := child_id;

    -- if parent_id is a symlink, resolve it
    get_id__parent_id := content_symlink__resolve(get_id__parent_id);

    start_pos := end_pos + 1;
      
  end loop;

  if get_id__resolve_index = 't' then

    -- if the item is a folder and has an index page, then return

    if content_folder__is_folder(child_id ) = 't' and
      content_folder__get_index_page(child_id) is not null then 

      child_id := content_folder__get_index_page(child_id);
    end if;

  end if;

  return child_id;

END;
$$;


ALTER FUNCTION public.content_item__get_id(get_id__item_path character varying, get_id__root_folder_id integer, get_id__resolve_index boolean) OWNER TO evex;

--
-- Name: content_item__get_latest_revision(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_latest_revision(get_latest_revision__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_revision_id                               integer;
  v_rec                                       record;
BEGIN
  for v_rec in 
  select 
    r.revision_id 
  from 
    cr_revisions r, acs_objects o
  where 
    r.revision_id = o.object_id
  and 
    r.item_id = get_latest_revision__item_id
  order by 
    o.creation_date desc
  LOOP
      v_revision_id := v_rec.revision_id;
      exit;
  end LOOP;

  return v_revision_id;
 
END;
$$;


ALTER FUNCTION public.content_item__get_latest_revision(get_latest_revision__item_id integer) OWNER TO evex;

--
-- Name: content_item__get_live_revision(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_live_revision(get_live_revision__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_revision_id                             acs_objects.object_id%TYPE;
BEGIN

  select
    live_revision into v_revision_id
  from
    cr_items
  where
    item_id = get_live_revision__item_id;

  return v_revision_id;
 
END;
$$;


ALTER FUNCTION public.content_item__get_live_revision(get_live_revision__item_id integer) OWNER TO evex;

--
-- Name: content_item__get_parent_folder(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_parent_folder(get_parent_folder__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_folder_id                              cr_folders.folder_id%TYPE;
  v_parent_folder_p                        boolean default 'f';       
BEGIN
  v_folder_id := get_parent_folder__item_id;

  while NOT v_parent_folder_p and v_folder_id is not null LOOP

    select
      parent_id, content_folder__is_folder(parent_id) 
    into 
      v_folder_id, v_parent_folder_p
    from
      cr_items
    where
      item_id = v_folder_id;

  end loop; 

  return v_folder_id;
 
END;
$$;


ALTER FUNCTION public.content_item__get_parent_folder(get_parent_folder__item_id integer) OWNER TO evex;

--
-- Name: content_item__get_path(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_path(get_path__item_id integer, get_path__root_folder_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count                          integer;       
  v_resolved_root_id               integer;       
  v_path                           text    default '';  
  v_rec                            record;
BEGIN

  -- check that the item exists
  select count(*) into v_count from cr_items where item_id = get_path__item_id;

  if v_count = 0 then
    raise EXCEPTION '-20000: Invalid item ID: %', get_path__item_id;
  end if;

  -- begin walking down the path to the item (from the repository root)
 
  -- if the root folder is not null then prepare for a relative path

  if get_path__root_folder_id is not null then

    -- if root_folder_id is a symlink, resolve it (child items will point
    -- to the actual folder, not the symlink)

    v_resolved_root_id := content_symlink__resolve(get_path__root_folder_id);

    -- check to see if the item is under or out side the root_id
    PERFORM 1 from cr_items i, 
        (select tree_sortkey from cr_items where item_id = v_resolved_root_id) a
    where tree_ancestor_p(a.tree_sortkey, i.tree_sortkey) and i.item_id = get_path__item_id;

    if NOT FOUND then
        -- if not found then we need to go up the folder and append ../ until we have common ancestor

        for v_rec in select i1.name, i1.parent_id, tree_level(i1.tree_sortkey) as tree_level
                 from cr_items i1, (select tree_ancestor_keys(tree_sortkey) as tree_sortkey from cr_items where item_id = v_resolved_root_id) i2,
                 (select tree_sortkey from cr_items where item_id = get_path__item_id) i3
                 where 
                 i1.parent_id <> 0
                 and i2.tree_sortkey = i1.tree_sortkey
                 and not tree_ancestor_p(i2.tree_sortkey, i3.tree_sortkey)
                 order by tree_level desc
        LOOP
            v_path := v_path || '../';
        end loop;
        -- lets now assign the new root_id to be the last parent_id on the loop
        v_resolved_root_id := v_rec.parent_id;

    end if;

    -- go downwards the tree and append the name and /
    for v_rec in select i1.name, i1.item_id, tree_level(i1.tree_sortkey) as tree_level
             from cr_items i1, (select tree_sortkey from cr_items where item_id = v_resolved_root_id) i2,
            (select tree_ancestor_keys(tree_sortkey) as tree_sortkey from cr_items where item_id = get_path__item_id) i3
             where 
             i1.tree_sortkey = i3.tree_sortkey
             and i1.tree_sortkey > i2.tree_sortkey
             order by tree_level
    LOOP
        v_path := v_path || v_rec.name;
        if v_rec.item_id <> get_path__item_id then 
            -- put a / if we are still going down
            v_path := v_path || '/';
        end if;
    end loop;

  else

    -- this is an absolute path so prepend a '/'
    -- loop over the absolute path

    for v_rec in select i2.name, tree_level(i2.tree_sortkey) as tree_level
                 from cr_items i1, cr_items i2
                 where i2.parent_id <> 0
                 and i1.item_id = get_path__item_id
                 and i1.tree_sortkey between i2.tree_sortkey and tree_right(i2.tree_sortkey)
                 order by tree_level
    LOOP
      v_path := v_path || '/' || v_rec.name;
    end loop;

  end if;

  return v_path;
 
END;
$$;


ALTER FUNCTION public.content_item__get_path(get_path__item_id integer, get_path__root_folder_id integer) OWNER TO evex;

--
-- Name: content_item__get_publish_date(integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_publish_date(get_publish_date__item_id integer, get_publish_date__is_live boolean) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_revision_id                            cr_revisions.revision_id%TYPE;
  v_publish_date                           cr_revisions.publish_date%TYPE;
BEGIN

  if get_publish_date__is_live then
    select
	publish_date into v_publish_date
    from
	cr_revisions r, cr_items i
    where
      i.item_id = get_publish_date__item_id
    and
      r.revision_id = i.live_revision;
  else
    select
	publish_date into v_publish_date
    from
	cr_revisions r, cr_items i
    where
      i.item_id = get_publish_date__item_id
    and
      r.revision_id = i.latest_revision;
  end if;

  return v_publish_date;
 
END;
$$;


ALTER FUNCTION public.content_item__get_publish_date(get_publish_date__item_id integer, get_publish_date__is_live boolean) OWNER TO evex;

--
-- Name: content_item__get_revision_count(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_revision_count(get_revision_count__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_count                       integer;       
BEGIN

  select
    count(*) into v_count
  from 
    cr_revisions
  where
    item_id = get_revision_count__item_id;

  return v_count;
 
END;
$$;


ALTER FUNCTION public.content_item__get_revision_count(get_revision_count__item_id integer) OWNER TO evex;

--
-- Name: content_item__get_root_folder(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_root_folder(get_root_folder__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_folder_id                             cr_folders.folder_id%TYPE;
BEGIN

  if get_root_folder__item_id is NULL or get_root_folder__item_id in (-4,-100,-200) then

    select c_root_folder_id from content_item_globals into v_folder_id;

  else

    select i2.item_id into v_folder_id
    from cr_items i1, cr_items i2
    where i2.parent_id = -4
    and i1.item_id = get_root_folder__item_id
    and i1.tree_sortkey between i2.tree_sortkey and tree_right(i2.tree_sortkey);

    if NOT FOUND then
       raise EXCEPTION ' -20000: Could not find a root folder for item ID %. Either the item does not exist or its parent value is corrupted.', get_root_folder__item_id;
    end if;
  end if;    

  return v_folder_id;
 
END;
$$;


ALTER FUNCTION public.content_item__get_root_folder(get_root_folder__item_id integer) OWNER TO evex;

--
-- Name: content_item__get_template(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_template(get_template__item_id integer, get_template__use_context character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_template_id                        cr_templates.template_id%TYPE;
  v_content_type                       cr_items.content_type%TYPE;
BEGIN

  -- look for a template assigned specifically to this item
  select
    template_id 
  into 
     v_template_id
  from
    cr_item_template_map
  where
    item_id = get_template__item_id
  and
    use_context = get_template__use_context;
  -- otherwise get the default for the content type
  if NOT FOUND then
    select 
      m.template_id
    into 
      v_template_id
    from
      cr_items i, cr_type_template_map m
    where
      i.item_id = get_template__item_id
    and
      i.content_type = m.content_type
    and
      m.use_context = get_template__use_context
    and
      m.is_default = 't';

    if NOT FOUND then
       return null;
    end if;
  end if;

  return v_template_id;
 
END;
$$;


ALTER FUNCTION public.content_item__get_template(get_template__item_id integer, get_template__use_context character varying) OWNER TO evex;

--
-- Name: content_item__get_title(integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_title(get_title__item_id integer, get_title__is_live boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_title                           cr_revisions.title%TYPE;
  v_content_type                    cr_items.content_type%TYPE;
BEGIN
  
  select content_type into v_content_type from cr_items 
    where item_id = get_title__item_id;

  if v_content_type = 'content_folder' then
    select label into v_title from cr_folders 
      where folder_id = get_title__item_id;
  else if v_content_type = 'content_symlink' then
    select label into v_title from cr_symlinks 
      where symlink_id = get_title__item_id;
  else if v_content_type = 'content_extlink' then
    select label into v_title from cr_extlinks
      where extlink_id = get_title__item_id;            
  else
    if get_title__is_live then
      select
	title into v_title
      from
	cr_revisions r, cr_items i
      where
        i.item_id = get_title__item_id
      and
        r.revision_id = i.live_revision;
    else
      select
	title into v_title
      from
	cr_revisions r, cr_items i
      where
        i.item_id = get_title__item_id
      and
        r.revision_id = i.latest_revision;
    end if;
  end if; end if; end if;

  return v_title;

END;
$$;


ALTER FUNCTION public.content_item__get_title(get_title__item_id integer, get_title__is_live boolean) OWNER TO evex;

--
-- Name: content_item__get_virtual_path(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__get_virtual_path(get_virtual_path__item_id integer, get_virtual_path__root_folder_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_path                                  varchar; 
  v_item_id                               cr_items.item_id%TYPE;
  v_is_folder                             boolean;       
  v_index                                 cr_items.item_id%TYPE;
BEGIN
  -- XXX possible bug: root_folder_id arg is ignored.

  -- first resolve the item
  v_item_id := content_symlink__resolve(get_virtual_path__item_id);

  v_is_folder := content_folder__is_folder(v_item_id);
  v_index := content_folder__get_index_page(v_item_id);

  -- if the folder has an index page
  if v_is_folder = 't' and v_index is not null then
    v_path := content_item__get_path(content_symlink__resolve(v_index),null);
  else
    v_path := content_item__get_path(v_item_id,null);
  end if;

  return v_path;
 
END;
$$;


ALTER FUNCTION public.content_item__get_virtual_path(get_virtual_path__item_id integer, get_virtual_path__root_folder_id integer) OWNER TO evex;

--
-- Name: content_item__is_index_page(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__is_index_page(is_index_page__item_id integer, is_index_page__folder_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN
  if content_folder__get_index_page(is_index_page__folder_id) = is_index_page__item_id then
    return 't';
  else
    return 'f';
  end if;
 
END;
$$;


ALTER FUNCTION public.content_item__is_index_page(is_index_page__item_id integer, is_index_page__folder_id integer) OWNER TO evex;

--
-- Name: content_item__is_publishable(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__is_publishable(is_publishable__item_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_child_count                          integer;       
  v_rel_count                            integer;       
  v_content_type			 varchar;
  v_template_id                          cr_templates.template_id%TYPE;
  v_child_type                           record;
  v_rel_type                             record;
  -- v_pub_wf                               record;
BEGIN
  -- check valid item_id
  select content_item__get_content_type(is_publishable__item_id) into v_content_type;

  if v_content_type is null then 
	raise exception 'content_item__is_publishable item_id % invalid',is_publishable__item_id;
  end if;

  -- validate children
  -- make sure the # of children of each type fall between min_n and max_n
  for v_child_type in select child_type, min_n, max_n
                      from   cr_type_children
                      where  parent_type = v_content_type 
	              and    (min_n is not null or max_n is not null)
  LOOP
    select count(item_id) into v_child_count
    from   cr_items
    where  parent_id = is_publishable__item_id
    and    content_item__get_content_type(child_id) = v_child_type.child_type;

    -- make sure # of children is in range
    if v_child_type.min_n is not null 
      and v_child_count < v_child_type.min_n then
      return 'f';
    end if;
    if v_child_type.max_n is not null
      and v_child_count > v_child_type.max_n then
      return 'f';
    end if;

  end LOOP;

  -- validate relations
  -- make sure the # of ext links of each type fall between min_n and max_n
  -- only check if one of min_n max_n not null
  for v_rel_type in select target_type, min_n, max_n
                    from   cr_type_relations
                    where  content_type = v_content_type
		    and    (max_n is not null or min_n is not null)
  LOOP
    select count(rel_id) into v_rel_count
    from   cr_item_rels i, acs_objects o
    where  i.related_object_id = o.object_id
    and    i.item_id = is_publishable__item_id
    and    coalesce(content_item__get_content_type(o.object_id),o.object_type) = v_rel_type.target_type;
      
    -- make sure # of object relations is in range
    if v_rel_type.min_n is not null 
      and v_rel_count < v_rel_type.min_n then
      return 'f';
    end if;
    if v_rel_type.max_n is not null 
      and v_rel_count > v_rel_type.max_n then
      return 'f';
    end if;
  end loop;

  -- validate publishing workflows
  -- make sure any 'publishing_wf' associated with this item are finished
  -- KG: logic is wrong here.  Only the latest workflow matters, and even
  -- that is a little problematic because more than one workflow may be
  -- open on an item.  In addition, this should be moved to CMS.
  
  -- Removed this as having workflow stuff in the CR is just plain wrong.
  -- DanW, Aug 25th, 2001.

  --   for v_pub_wf in  select
  --                      case_id, state
  --                    from
  --                      wf_cases
  --                    where
  --                      workflow_key = 'publishing_wf'
  --                    and
  --                      object_id = is_publishable__item_id
  -- 
  --   LOOP
  --     if v_pub_wf.state != 'finished' then
  --        return 'f';
  --     end if;
  --   end loop;

  -- if NOT FOUND then 
  --   return 'f';
  -- end if;

  return 't';
 
END;
$$;


ALTER FUNCTION public.content_item__is_publishable(is_publishable__item_id integer) OWNER TO evex;

--
-- Name: content_item__is_published(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__is_published(is_published__item_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN

  return
    count(*) > 0
  from
    cr_items
  where
    live_revision is not null
  and
    publish_status = 'live'
  and
    item_id = is_published__item_id;
 
END;
$$;


ALTER FUNCTION public.content_item__is_published(is_published__item_id integer) OWNER TO evex;

--
-- Name: content_item__is_subclass(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__is_subclass(is_subclass__object_type character varying, is_subclass__supertype character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_subclass_p                        boolean;      
  v_inherit_val                       record;
BEGIN
  select count(*) > 0 into v_subclass_p where exists (
	select 1
          from acs_object_types o, acs_object_types o2
         where o2.object_type = is_subclass__supertype
           and o.object_type = is_subclass__object_type
           and o.tree_sortkey between o2.tree_sortkey and tree_right(o2.tree_sortkey));

  return v_subclass_p;

END;
$$;


ALTER FUNCTION public.content_item__is_subclass(is_subclass__object_type character varying, is_subclass__supertype character varying) OWNER TO evex;

--
-- Name: content_item__is_valid_child(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__is_valid_child(is_valid_child__item_id integer, is_valid_child__content_type character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
--
-- variant without relation_tag
--
DECLARE
  v_is_valid_child                       boolean;       
  v_max_children                         cr_type_children.max_n%TYPE;
  v_n_children                           integer;       
BEGIN

  v_is_valid_child := 'f';

  -- first check if content_type is a registered child_type
  select sum(max_n) into v_max_children
  from   cr_type_children
  where  parent_type = content_item__get_content_type(is_valid_child__item_id)
  and    child_type = is_valid_child__content_type;

  if NOT FOUND then 
     return 'f';
  end if;

  -- if the max is null then infinite number is allowed
  if v_max_children is null then
    return 't';
  end if;

  -- next check if there are already max_n children of that content type
  select count(item_id) into v_n_children
  from   cr_items
  where  parent_id = is_valid_child__item_id
  and    content_item__get_content_type(child_id) = is_valid_child__content_type;

  if NOT FOUND then 
     return 'f';
  end if;

  if v_n_children < v_max_children then
    v_is_valid_child := 't';
  end if;

  return v_is_valid_child;
 
END;
$$;


ALTER FUNCTION public.content_item__is_valid_child(is_valid_child__item_id integer, is_valid_child__content_type character varying) OWNER TO evex;

--
-- Name: content_item__is_valid_child(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__is_valid_child(is_valid_child__item_id integer, is_valid_child__content_type character varying, is_valid_child__relation_tag character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_is_valid_child                       boolean;       
  v_max_children                         cr_type_children.max_n%TYPE;
  v_n_children                           integer;       
  v_null_exists				 boolean;
BEGIN

  v_is_valid_child := 'f';

  -- first check if content_type is a registered child_type
  select sum(max_n) into v_max_children
  from   cr_type_children
  where  parent_type = content_item__get_content_type(is_valid_child__item_id)
  and    child_type = is_valid_child__content_type
  and    (is_valid_child__relation_tag is null or is_valid_child__relation_tag = relation_tag);

  if NOT FOUND then 
      return 'f';
  end if;

  -- if the max is null then infinite number is allowed
  if v_max_children is null then
    return 't';
  end if;

  --
  -- Next check if there are already max_n children of that content type.
  -- Use cr_child_rels only, when a non-null relation_tag is provided.
  --
  if is_valid_child__relation_tag is null then
        select count(item_id) into v_n_children
        from   cr_items
        where  parent_id = is_valid_child__item_id
        and    content_item__get_content_type(child_id) = is_valid_child__content_type;
  else
        select count(rel_id) into v_n_children
        from   cr_child_rels
        where  parent_id = is_valid_child__item_id
        and    content_item__get_content_type(child_id) = is_valid_child__content_type
        and    is_valid_child__relation_tag = relation_tag;
  end if;
  
  if NOT FOUND then 
     return 'f';
  end if;

  if v_n_children < v_max_children then
    v_is_valid_child := 't';
  end if;

  return v_is_valid_child;
 
END;
$$;


ALTER FUNCTION public.content_item__is_valid_child(is_valid_child__item_id integer, is_valid_child__content_type character varying, is_valid_child__relation_tag character varying) OWNER TO evex;

--
-- Name: content_item__move(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__move(move__item_id integer, move__target_folder_id integer, move__name character varying DEFAULT NULL::character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  if move__target_folder_id is null then 
	raise exception 'attempt to move item_id % to null folder_id', move__item_id;
  end if;

  if content_folder__is_folder(move__item_id) = 't' then

    PERFORM content_folder__move(move__item_id, move__target_folder_id);

  elsif content_folder__is_folder(move__target_folder_id) = 't' then
   

    if content_folder__is_registered(move__target_folder_id,
          content_item__get_content_type(move__item_id),'f') = 't' and
       content_folder__is_registered(move__target_folder_id,
          content_item__get_content_type(content_symlink__resolve(move__item_id)),'f') = 't'
      then
    -- update the parent_id for the item

    update cr_items 
      set parent_id = move__target_folder_id,
          name = coalesce(move__name, name)
      where item_id = move__item_id;
    end if;

    if move__name is not null then
      update acs_objects
        set title = move__name
        where object_id = move__item_id;
    end if;

  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__move(move__item_id integer, move__target_folder_id integer, move__name character varying) OWNER TO evex;

--
-- Name: content_item__new(character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- calls content_item__new/6
--
DECLARE
BEGIN
        return content_item__new(new__name, new__parent_id, null, null, null, new__package_id);
END;
$$;


ALTER FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__package_id integer) OWNER TO evex;

--
-- Name: content_item__new(character varying, integer, character varying, text, text, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__title character varying, new__description text, new__text text, new__package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	raise NOTICE 'content_item__new/5 is deprecated, call content_item__new/21 instead';

	-- calls content_item__new/20

        return content_item__new(new__name,
                                 new__parent_id,
                                 null,               -- item_id
                                 null,               -- locale
                                 now(),              -- creation_date 
                                 null,               -- creation_user
                                 null,               -- context_id
                                 null,               -- creation_ip
                                 'content_item',     -- item_subtype
                                 'content_revision', -- content_type
                                 new__title,
                                 new__description,
                                 'text/plain',       -- mime_type
                                 null,               -- nls_language
                                 new__text,
                                 null,               -- data
				 null,               -- relation_tag
				 'f',                -- is_live				 
                                 'text',             -- storage_type
                                 new__package_id,
				 't'                 -- with_child_rels
               );

END;
$$;


ALTER FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__title character varying, new__description text, new__text text, new__package_id integer) OWNER TO evex;

--
-- Name: content_item__new(integer, character varying, integer, character varying, timestamp with time zone, integer, integer, character varying, boolean, character varying, text, public.cr_item_storage_type_enum, boolean, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__new(new__item_id integer, new__name character varying, new__parent_id integer, new__title character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__context_id integer, new__creation_ip character varying, new__is_live boolean, new__mime_type character varying, new__text text, new__storage_type public.cr_item_storage_type_enum, new__security_inherit_p boolean, new__storage_area_key character varying, new__item_subtype character varying, new__content_type character varying, new__package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- differs from other content_item__new/17 by
--    this version has 1st arg item_id vs. 3rd arg (differs as well from /20)
--    this version does not have a "locale" and "nls_language"
--    this version has "is_live" (like /20)
--    this version has "security_inherit_p"

DECLARE
  new__description	      varchar default null;
  new__relation_tag           varchar default null;
  new__nls_language	      varchar default null; 
  v_parent_id                 cr_items.parent_id%TYPE;
  v_parent_type               acs_objects.object_type%TYPE;
  v_item_id                   cr_items.item_id%TYPE;
  v_revision_id               cr_revisions.revision_id%TYPE;
  v_title                     cr_revisions.title%TYPE;
  v_rel_id                    acs_objects.object_id%TYPE;
  v_rel_tag                   cr_child_rels.relation_tag%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
BEGIN

  -- place the item in the context of the pages folder if no
  -- context specified 

  if new__parent_id is null then
    select c_root_folder_id from content_item_globals into v_parent_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- Determine context_id
  if new__context_id is null then
    v_context_id := v_parent_id;
  else
    v_context_id := new__context_id;
  end if;

  -- use the name of the item if no title is supplied
  if new__title is null or new__title = '' then
    v_title := new__name;
  else
    v_title := new__title;
  end if;

  if v_parent_id = -4 or 
    content_folder__is_folder(v_parent_id) = 't' then

    if v_parent_id != -4 and 
      content_folder__is_registered(
        v_parent_id, new__content_type, 'f') = 'f' then

      raise EXCEPTION '-20000: This items content type % is not registered to this folder %', new__content_type, v_parent_id;
    end if;

  else if v_parent_id != -4 then

     select object_type into v_parent_type from acs_objects
       where object_id = v_parent_id;

     if NOT FOUND then 
       raise EXCEPTION '-20000: Invalid parent ID % specified in content_item.new',  v_parent_id;
     end if;

     if content_item__is_subclass(v_parent_type, 'content_item') = 't' and
	content_item__is_valid_child(v_parent_id, new__content_type) = 'f' then

       raise EXCEPTION '-20000: This items content type % is not allowed in this container %', new__content_type, v_parent_id;
     end if;

  end if; end if;

 
  -- Create the object

  v_item_id := acs_object__new(
      new__item_id,
      new__item_subtype, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      v_context_id,
      new__security_inherit_p,
      v_title,
      new__package_id
  );

  insert into cr_items (
    item_id, name, content_type, parent_id, storage_type, storage_area_key
  ) values (
    v_item_id, new__name, new__content_type, v_parent_id, new__storage_type,
    new__storage_area_key
  );

  -- if the parent is not a folder, insert into cr_child_rels
  if v_parent_id != -4 and
    content_folder__is_folder(v_parent_id) = 'f' and 
    content_item__is_valid_child(v_parent_id, new__content_type) = 't' then

    if new__relation_tag is null then
      v_rel_tag := content_item__get_content_type(v_parent_id) 
        || '-' || new__content_type;
    else
      v_rel_tag := new__relation_tag;
    end if;

    v_rel_id := acs_object__new(
      null,
      'cr_item_child_rel',
      new__creation_date,
      null,
      null,
      v_parent_id,
      'f',
      v_rel_tag || ': ' || v_parent_id || ' - ' || v_item_id,
      new__package_id
    );

    insert into cr_child_rels (
      rel_id, parent_id, child_id, relation_tag, order_n
    ) values (
      v_rel_id, v_parent_id, v_item_id, v_rel_tag, v_item_id
    );

  end if;

  if new__title is not null or 
     new__text is not null then

    -- call content_revision__new/13

    v_revision_id := content_revision__new(
	v_title,
	new__description,
        now(),               -- publish_date
	new__mime_type,
        null,                -- nls_language,
	new__text,
	v_item_id,
        null,                -- revision_id
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
	null,                -- content_length
        new__package_id
    );

  end if;

  -- make the revision live if is_live is true
  if new__is_live = 't' then
    PERFORM content_item__set_live_revision(v_revision_id);
  end if;

  return v_item_id;

END;
$$;


ALTER FUNCTION public.content_item__new(new__item_id integer, new__name character varying, new__parent_id integer, new__title character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__context_id integer, new__creation_ip character varying, new__is_live boolean, new__mime_type character varying, new__text text, new__storage_type public.cr_item_storage_type_enum, new__security_inherit_p boolean, new__storage_area_key character varying, new__item_subtype character varying, new__content_type character varying, new__package_id integer) OWNER TO evex;

--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__item_id integer, new__locale character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__context_id integer, new__creation_ip character varying, new__item_subtype character varying, new__content_type character varying, new__title character varying, new__description character varying, new__mime_type character varying, new__nls_language character varying, new__data integer, new__package_id integer DEFAULT NULL::integer, new__with_child_rels boolean DEFAULT true) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- This version passes "data" as integer (lob version), most other use
-- "text" and "storage_type"
-- 
DECLARE
  new__relation_tag           varchar default null;
  new__is_live                boolean default 'f';

  v_parent_id                 cr_items.parent_id%TYPE;
  v_parent_type               acs_objects.object_type%TYPE;
  v_item_id                   cr_items.item_id%TYPE;
  v_revision_id               cr_revisions.revision_id%TYPE;
  v_title                     cr_revisions.title%TYPE;
  v_rel_id                    acs_objects.object_id%TYPE;
  v_rel_tag                   cr_child_rels.relation_tag%TYPE;
  v_context_id                acs_objects.context_id%TYPE;
BEGIN

  -- place the item in the context of the pages folder if no
  -- context specified 

  if new__parent_id is null then
    select c_root_folder_id from content_item_globals into v_parent_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- Determine context_id
  if new__context_id is null then
    v_context_id := v_parent_id;
  else
    v_context_id := new__context_id;
  end if;

  -- use the name of the item if no title is supplied
  if new__title is null or new__title = '' then
    v_title := new__name;
  else
    v_title := new__title;
  end if;

  if v_parent_id = -4 or 
    content_folder__is_folder(v_parent_id) = 't' then

    if v_parent_id != -4 and 
      content_folder__is_registered(
        v_parent_id, new__content_type, 'f') = 'f' then

      raise EXCEPTION '-20000: This items content type % is not registered to this folder %', new__content_type, v_parent_id;
    end if;

  else if v_parent_id != -4 then

     select object_type into v_parent_type from acs_objects
       where object_id = v_parent_id;

     if NOT FOUND then 
       raise EXCEPTION '-20000: Invalid parent ID % specified in content_item.new',  v_parent_id;
     end if;

     if content_item__is_subclass(v_parent_type, 'content_item') = 't' and
	content_item__is_valid_child(v_parent_id, new__content_type) = 'f' then

       raise EXCEPTION '-20000: This items content type % is not allowed in this container %', new__content_type, v_parent_id;
     end if;

  end if; end if;

  -- Create the object

  v_item_id := acs_object__new(
      new__item_id,
      new__item_subtype, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      v_context_id,
      't',
      v_title,
      new__package_id
  );

  insert into cr_items (
    item_id, name, content_type, parent_id, storage_type
  ) values (
    v_item_id, new__name, new__content_type, v_parent_id, 'lob'
  );

  -- if the parent is not a folder, insert into cr_child_rels
  if new__with_child_rels = 't' and
    v_parent_id != -4 and
    content_folder__is_folder(v_parent_id) = 'f' and
    content_item__is_valid_child(v_parent_id, new__content_type) = 't' then

    if new__relation_tag is null or new__relation_tag = '' then
      v_rel_tag := content_item__get_content_type(v_parent_id) 
        || '-' || new__content_type;
    else
      v_rel_tag := new__relation_tag;
    end if;

    v_rel_id := acs_object__new(
      null,
      'cr_item_child_rel',
      now(),
      null,
      null,
      v_parent_id,
      't',
      v_rel_tag || ': ' || v_parent_id || ' - ' || v_item_id,
      new__package_id
    );

    insert into cr_child_rels (
      rel_id, parent_id, child_id, relation_tag, order_n
    ) values (
      v_rel_id, v_parent_id, v_item_id, v_rel_tag, v_item_id
    );

  end if;

  -- create the revision if data or title is not null

  if new__data is not null then

    -- call content_revision__new/12 (data is integer)
    
    v_revision_id := content_revision__new(
        v_title,
	new__description,
        now(),               -- publish_date
	new__mime_type,
	new__nls_language,
	new__data,
        v_item_id,
        null,                -- revision_id
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
        new__package_id
        );

  elsif new__title is not null then

    -- call content_revision__new/13 (data is null)

    v_revision_id := content_revision__new(
	v_title,
	new__description,
        now(),               -- publish_date
	new__mime_type,
        new_nls_language,
	null,                -- data/text
	v_item_id,
        null,                -- revision_id
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
	null,                -- content_length
        new__package_id
    );

  end if;

  -- make the revision live if is_live is true
  if new__is_live = 't' then
    PERFORM content_item__set_live_revision(v_revision_id);
  end if;

  return v_item_id;
 
END;
$$;


ALTER FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__item_id integer, new__locale character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__context_id integer, new__creation_ip character varying, new__item_subtype character varying, new__content_type character varying, new__title character varying, new__description character varying, new__mime_type character varying, new__nls_language character varying, new__data integer, new__package_id integer, new__with_child_rels boolean) OWNER TO evex;

--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, public.cr_item_storage_type_enum, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__item_id integer, new__locale character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__context_id integer, new__creation_ip character varying, new__item_subtype character varying, new__content_type character varying, new__title character varying, new__description character varying, new__mime_type character varying, new__nls_language character varying, new__text character varying, new__storage_type public.cr_item_storage_type_enum, new__package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_item__new/17 is deprecated, one should call /20
--
DECLARE
BEGIN
	raise NOTICE 'content_item__new/17 is deprecated, call content_item__new/21 instead';

        return content_item__new(new__name,
                                 new__parent_id,
                                 new__item_id,
                                 new__locale,
                                 new__creation_date,
                                 new__creation_user,
				 new__context_id,
                                 new__creation_ip,
                                 new__item_subtype,
                                 new__content_type,
                                 new__title,
                                 new__description,
                                 new__mime_type,
                                 new__nls_language,
                                 new__text,
                                 null,  -- data
				 null,  -- relation_tag
				 'f',   -- is_live
				 new__storage_type,
                                 new__package_id,
				 't'    -- with_child_rels
               );
END;
$$;


ALTER FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__item_id integer, new__locale character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__context_id integer, new__creation_ip character varying, new__item_subtype character varying, new__content_type character varying, new__title character varying, new__description character varying, new__mime_type character varying, new__nls_language character varying, new__text character varying, new__storage_type public.cr_item_storage_type_enum, new__package_id integer) OWNER TO evex;

--
-- Name: content_item__new(character varying, integer, integer, character varying, timestamp with time zone, integer, integer, character varying, character varying, character varying, character varying, text, character varying, character varying, character varying, text, character varying, boolean, public.cr_item_storage_type_enum, integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__item_id integer, new__locale character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__context_id integer, new__creation_ip character varying, new__item_subtype character varying, new__content_type character varying, new__title character varying, new__description text, new__mime_type character varying, new__nls_language character varying, new__text character varying, new__data text, new__relation_tag character varying, new__is_live boolean, new__storage_type public.cr_item_storage_type_enum, new__package_id integer DEFAULT NULL::integer, new__with_child_rels boolean DEFAULT true) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_parent_id      cr_items.parent_id%TYPE;
  v_parent_type    acs_objects.object_type%TYPE;
  v_item_id        cr_items.item_id%TYPE;
  v_title          cr_revisions.title%TYPE;
  v_revision_id    cr_revisions.revision_id%TYPE;
  v_rel_id         acs_objects.object_id%TYPE;
  v_rel_tag        cr_child_rels.relation_tag%TYPE;
  v_context_id     acs_objects.context_id%TYPE;
  v_storage_type   cr_items.storage_type%TYPE;
BEGIN

  -- place the item in the context of the pages folder if no
  -- context specified 

  if new__parent_id is null then
    select c_root_folder_id from content_item_globals into v_parent_id;
  else
    v_parent_id := new__parent_id;
  end if;

  -- Determine context_id
  if new__context_id is null then
    v_context_id := v_parent_id;
  else
    v_context_id := new__context_id;
  end if;

  -- use the name of the item if no title is supplied
  if new__title is null or new__title = '' then
    v_title := new__name;
  else
    v_title := new__title;
  end if;

  if v_parent_id = -4 or 
    content_folder__is_folder(v_parent_id) = 't' then

    if v_parent_id != -4 and 
      content_folder__is_registered(
        v_parent_id, new__content_type, 'f') = 'f' then

      raise EXCEPTION '-20000: This items content type % is not registered to this folder %', new__content_type, v_parent_id;
    end if;

  else if v_parent_id != -4 then

     if new__relation_tag is null then
       v_rel_tag := content_item__get_content_type(v_parent_id) 
         || '-' || new__content_type;
     else
       v_rel_tag := new__relation_tag;
     end if;

     select object_type into v_parent_type from acs_objects
       where object_id = v_parent_id;

     if NOT FOUND then 
       raise EXCEPTION '-20000: Invalid parent ID % specified in content_item.new',  v_parent_id;
     end if;

     if content_item__is_subclass(v_parent_type, 'content_item') = 't' and
        content_item__is_valid_child(v_parent_id, new__content_type, v_rel_tag) = 'f' then

       raise EXCEPTION '-20000: This items content type % is not allowed in this container %', new__content_type, v_parent_id;
     end if;

  end if; end if;

  -- Create the object

  v_item_id := acs_object__new(
      new__item_id,
      new__item_subtype, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      v_context_id,
      't',
      v_title,
      new__package_id
  );


  insert into cr_items (
    item_id, name, content_type, parent_id, storage_type
  ) values (
    v_item_id, new__name, new__content_type, v_parent_id, new__storage_type
  );

  -- if the parent is not a folder, insert into cr_child_rels
  if new__with_child_rels = 't' and
    v_parent_id != -4 and
    content_folder__is_folder(v_parent_id) = 'f' then

    v_rel_id := acs_object__new(
      null,
      'cr_item_child_rel',
      now(),
      null,
      null,
      v_parent_id,
      't',
      v_rel_tag || ': ' || v_parent_id || ' - ' || v_item_id,
      new__package_id
    );

    insert into cr_child_rels (
      rel_id, parent_id, child_id, relation_tag, order_n
    ) values (
      v_rel_id, v_parent_id, v_item_id, v_rel_tag, v_item_id
    );

  end if;

  if new__data is not null then
  
    -- call content_revision__new/13
    
    v_revision_id := content_revision__new(
        v_title,
	new__description,
        now(),              -- publish_date
	new__mime_type,
	new__nls_language,
	new__data,
        v_item_id,
        null,               -- revision_id
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
	null,               -- content_length
        new__package_id
        );

  elsif new__text is not null or new__title is not null then

    -- call content_revision__new/13

    v_revision_id := content_revision__new(
        v_title,
	new__description,
        now(),              -- publish_date
	new__mime_type,
        new__nls_language,
	new__text,
	v_item_id,
        null,               -- revision_id
        new__creation_date, 
        new__creation_user, 
        new__creation_ip,
	null,               -- content_length
        new__package_id
    );

  end if;

  -- make the revision live if is_live is true
  if new__is_live = 't' then
    PERFORM content_item__set_live_revision(v_revision_id);
  end if;

  return v_item_id;

END;
$$;


ALTER FUNCTION public.content_item__new(new__name character varying, new__parent_id integer, new__item_id integer, new__locale character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__context_id integer, new__creation_ip character varying, new__item_subtype character varying, new__content_type character varying, new__title character varying, new__description text, new__mime_type character varying, new__nls_language character varying, new__text character varying, new__data text, new__relation_tag character varying, new__is_live boolean, new__storage_type public.cr_item_storage_type_enum, new__package_id integer, new__with_child_rels boolean) OWNER TO evex;

--
-- Name: content_item__register_template(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__register_template(register_template__item_id integer, register_template__template_id integer, register_template__use_context character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
                                        
BEGIN

 -- register template if it is not already registered
  insert into cr_item_template_map
  select
    register_template__item_id as item_id,
    register_template__template_id as template_id,
    register_template__use_context as use_context
  from
    dual
  where
    not exists ( select 1
                 from
                   cr_item_template_map
                 where
                   item_id = register_template__item_id
                 and
                   template_id = register_template__template_id
                 and
                   use_context = register_template__use_context );

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__register_template(register_template__item_id integer, register_template__template_id integer, register_template__use_context character varying) OWNER TO evex;

--
-- Name: content_item__relate(integer, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__relate(relate__item_id integer, relate__object_id integer, relate__relation_tag character varying, relate__order_n integer, relate__relation_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_content_type                 cr_items.content_type%TYPE;
  v_object_type                  acs_objects.object_type%TYPE;
  v_is_valid                     integer;       
  v_rel_id                       integer;       
  v_package_id                   integer;       
  v_exists                       integer;       
  v_order_n                      cr_item_rels.order_n%TYPE;
BEGIN

  -- check the relationship is valid
  v_content_type := content_item__get_content_type (relate__item_id);
  v_object_type := content_item__get_content_type (relate__object_id);

  select
    count(1) into v_is_valid
  from
    cr_type_relations
  where
    content_item__is_subclass( v_object_type, target_type ) = 't'
  and
    content_item__is_subclass( v_content_type, content_type ) = 't';

  if v_is_valid = 0 then
    raise EXCEPTION '-20000: There is no registered relation type matching this item relation.';
  end if;

  if relate__item_id != relate__object_id then
    -- check that these two items are not related already
    --dbms_output.put_line( 'checking if the items are already related...');
    
    select
      rel_id, 1 into v_rel_id, v_exists
    from
      cr_item_rels
    where
      item_id = relate__item_id
    and
      related_object_id = relate__object_id
    and
      relation_tag = relate__relation_tag;

    if NOT FOUND then
       v_exists := 0;
    end if;
    
    v_package_id := acs_object__package_id(relate__item_id);

    -- if order_n is null, use rel_id (the order the item was related)
    if relate__order_n is null then
      v_order_n := v_rel_id;
    else
      v_order_n := relate__order_n;
    end if;


    -- if relationship does not exist, create it
    if v_exists <> 1 then
      --dbms_output.put_line( 'creating new relationship...');
      v_rel_id := acs_object__new(
        null,
        relate__relation_type,
        now(),
        null,
        null,
        relate__item_id,
        't',
        relate__relation_tag || ': ' || relate__item_id || ' - ' || relate__object_id,
        v_package_id
      );

      insert into cr_item_rels (
        rel_id, item_id, related_object_id, order_n, relation_tag
      ) values (
        v_rel_id, relate__item_id, relate__object_id, v_order_n, 
        relate__relation_tag
      );

    -- if relationship already exists, update it
    else
      --dbms_output.put_line( 'updating existing relationship...');
      update cr_item_rels set
        relation_tag = relate__relation_tag,
        order_n = v_order_n
      where
        rel_id = v_rel_id;

      update acs_objects set
        title = relate__relation_tag || ': ' || relate__item_id || ' - ' || relate__object_id
      where object_id = v_rel_id;
    end if;

  end if;

  return v_rel_id;
 
END;
$$;


ALTER FUNCTION public.content_item__relate(relate__item_id integer, relate__object_id integer, relate__relation_tag character varying, relate__order_n integer, relate__relation_type character varying) OWNER TO evex;

--
-- Name: content_item__set_live_revision(integer, character varying, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__set_live_revision(set_live_revision__revision_id integer, set_live_revision__publish_status character varying DEFAULT 'ready'::character varying, set_live_revision__publish_date timestamp with time zone DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  update
    cr_items
  set
    live_revision = set_live_revision__revision_id,
    publish_status = set_live_revision__publish_status
  where
    item_id = (select
                 item_id
               from
                 cr_revisions
               where
                 revision_id = set_live_revision__revision_id);

  update
    cr_revisions
  set
    publish_date = set_live_revision__publish_date
  where
    revision_id = set_live_revision__revision_id;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__set_live_revision(set_live_revision__revision_id integer, set_live_revision__publish_status character varying, set_live_revision__publish_date timestamp with time zone) OWNER TO evex;

--
-- Name: content_item__set_release_period(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__set_release_period(set_release_period__item_id integer, set_release_period__start_when timestamp with time zone, set_release_period__end_when timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count                                    integer;       
BEGIN

  select count(*) into v_count from cr_release_periods 
    where item_id = set_release_period__item_id;

  if v_count = 0 then
    insert into cr_release_periods (
      item_id, start_when, end_when
    ) values (
      set_release_period__item_id, 
      set_release_period__start_when, 
      set_release_period__end_when
    );
  else
    update cr_release_periods
      set start_when = set_release_period__start_when,
      end_when = set_release_period__end_when
    where
      item_id = set_release_period__item_id;
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__set_release_period(set_release_period__item_id integer, set_release_period__start_when timestamp with time zone, set_release_period__end_when timestamp with time zone) OWNER TO evex;

--
-- Name: content_item__unregister_template(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__unregister_template(unregister_template__item_id integer, unregister_template__template_id integer, unregister_template__use_context character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
                                        
BEGIN

  if unregister_template__use_context is null and 
     unregister_template__template_id is null then

    delete from cr_item_template_map
      where item_id = unregister_template__item_id;

  else if unregister_template__use_context is null then

    delete from cr_item_template_map
      where template_id = unregister_template__template_id
      and item_id = unregister_template__item_id;

  else if unregister_template__template_id is null then

    delete from cr_item_template_map
      where item_id = unregister_template__item_id
      and use_context = unregister_template__use_context;

  else

    delete from cr_item_template_map
      where template_id = unregister_template__template_id
      and item_id = unregister_template__item_id
      and use_context = unregister_template__use_context;

  end if; end if; end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__unregister_template(unregister_template__item_id integer, unregister_template__template_id integer, unregister_template__use_context character varying) OWNER TO evex;

--
-- Name: content_item__unrelate(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__unrelate(unrelate__rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  -- delete the relation object
  PERFORM acs_rel__delete(unrelate__rel_id);

  -- delete the row from the cr_item_rels table
  delete from cr_item_rels where rel_id = unrelate__rel_id;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__unrelate(unrelate__rel_id integer) OWNER TO evex;

--
-- Name: content_item__unset_live_revision(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__unset_live_revision(unset_live_revision__item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  update
    cr_items
  set
    live_revision = NULL
  where
    item_id = unset_live_revision__item_id;

  -- if an items publish status is "live", change it to "ready"
  update
    cr_items
  set
    publish_status = 'production'
  where
    publish_status = 'live'
  and
    item_id = unset_live_revision__item_id;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__unset_live_revision(unset_live_revision__item_id integer) OWNER TO evex;

--
-- Name: content_item__write_to_file(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item__write_to_file(item_id integer, root_path character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  -- blob_loc               cr_revisions.content%TYPE;
  -- v_revision             cr_items.live_revision%TYPE;
BEGIN
  
  -- FIXME:
  raise NOTICE 'not implemented for postgresql';
/*
  v_revision := content_item__get_live_revision(item_id);

  select content into blob_loc from cr_revisions 
    where revision_id = v_revision;

  if NOT FOUND then 
    raise EXCEPTION '-20000: No live revision for content item % in content_item.write_to_file.', item_id;    
  end if;
  
  PERFORM blob_to_file(root_path || content_item__get_path(item_id), blob_loc);
*/
  return 0; 
END;
$$;


ALTER FUNCTION public.content_item__write_to_file(item_id integer, root_path character varying) OWNER TO evex;

--
-- Name: content_item_search__utrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_item_search__utrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    if new.live_revision is not null and coalesce(old.live_revision,0) <> new.live_revision
    and (select publish_date from cr_revisions where revision_id=new.live_revision) <= current_timestamp then
        perform search_observer__enqueue(new.live_revision,'INSERT');        
    end if;

    if old.live_revision is not null and old.live_revision <> coalesce(new.live_revision,0)
    and (select publish_date from cr_revisions where revision_id=old.live_revision) <= current_timestamp then
        perform search_observer__enqueue(old.live_revision,'DELETE');
    end if;
    if old.live_revision is not null and new.publish_status = 'expired' then
        perform search_observer__enqueue(old.live_revision,'DELETE');
    end if;

    return new;
END;
$$;


ALTER FUNCTION public.content_item_search__utrg() OWNER TO evex;

--
-- Name: content_keyword__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__del(delete__keyword_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_rec                          record; 
BEGIN

  for v_rec in select item_id from cr_item_keyword_map 
    where keyword_id = delete__keyword_id LOOP
    PERFORM content_keyword__item_unassign(v_rec.item_id, delete__keyword_id);
  end LOOP;

  PERFORM acs_object__delete(delete__keyword_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_keyword__del(delete__keyword_id integer) OWNER TO evex;

--
-- Name: content_keyword__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__delete(delete__keyword_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_rec                          record; 
BEGIN
  perform content_keyword__del(delete__keyword_id);
  return 0; 
END;
$$;


ALTER FUNCTION public.content_keyword__delete(delete__keyword_id integer) OWNER TO evex;

--
-- Name: content_keyword__get_description(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__get_description(get_description__keyword_id integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_description                           text; 
BEGIN

  select description into v_description from cr_keywords
    where keyword_id = get_description__keyword_id;

  return v_description;
 
END;
$$;


ALTER FUNCTION public.content_keyword__get_description(get_description__keyword_id integer) OWNER TO evex;

--
-- Name: content_keyword__get_heading(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__get_heading(get_heading__keyword_id integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_heading                           text; 
BEGIN

  select heading into v_heading from cr_keywords
    where keyword_id = get_heading__keyword_id;

  return v_heading;
 
END;
$$;


ALTER FUNCTION public.content_keyword__get_heading(get_heading__keyword_id integer) OWNER TO evex;

--
-- Name: content_keyword__get_path(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__get_path(get_path__keyword_id integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_path                          text default '';
  v_is_found                      boolean default 'f';   
  v_heading                       cr_keywords.heading%TYPE;
  v_rec                           record;
BEGIN
--               select
--                 heading 
--               from (
--                  select 
--                    heading, level as tree_level
--                  from cr_keywords
--                    connect by prior parent_id = keyword_id
--                    start with keyword_id = get_path.keyword_id) k 
--                order by 
--                  tree_level desc 

  for v_rec in select heading 
               from (select k2.heading, tree_level(k2.tree_sortkey) as tree_level
                     from cr_keywords k1, cr_keywords k2
                     where k1.keyword_id = get_path__keyword_id
                       and k1.tree_sortkey between k2.tree_sortkey and tree_right(k2.tree_sortkey)) k
                order by tree_level desc 
  LOOP
      v_heading := v_rec.heading;
      v_is_found := 't';
      v_path := v_path || '/' || v_heading;
  end LOOP;

  if v_is_found = 'f' then
    return null;
  else
    return v_path;
  end if;
 
END;
$$;


ALTER FUNCTION public.content_keyword__get_path(get_path__keyword_id integer) OWNER TO evex;

--
-- Name: content_keyword__is_assigned(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__is_assigned(is_assigned__item_id integer, is_assigned__keyword_id integer, is_assigned__recurse character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_ret                               boolean;    
  v_is_assigned__recurse	      varchar;
BEGIN
  if is_assigned__recurse is null then 
	v_is_assigned__recurse := 'none';
  else
      	v_is_assigned__recurse := is_assigned__recurse;	
  end if;

  -- Look for an exact match
  if v_is_assigned__recurse = 'none' then
      return count(*) > 0 from cr_item_keyword_map
       where item_id = is_assigned__item_id
         and keyword_id = is_assigned__keyword_id;
  end if;

  -- Look from specific to general
  if v_is_assigned__recurse = 'up' then
      return count(*) > 0
      where exists (select 1
                    from (select keyword_id from cr_keywords c, cr_keywords c2
	                  where c2.keyword_id = is_assigned__keyword_id
                            and c.tree_sortkey between c2.tree_sortkey and tree_right(c2.tree_sortkey)) t,
                      cr_item_keyword_map m
                    where t.keyword_id = m.keyword_id
                      and m.item_id = is_assigned__item_id);
  end if;

  if v_is_assigned__recurse = 'down' then
      return count(*) > 0
      where exists (select 1
                    from (select k2.keyword_id
                          from cr_keywords k1, cr_keywords k2
                          where k1.keyword_id = is_assigned__keyword_id
                            and k1.tree_sortkey between k2.tree_sortkey and tree_right(k2.tree_sortkey)) t, 
                      cr_item_keyword_map m
                    where t.keyword_id = m.keyword_id
                      and m.item_id = is_assigned__item_id);

  end if;  

  -- Tried none, up and down - must be an invalid parameter
  raise EXCEPTION '-20000: The recurse parameter to content_keyword.is_assigned should be ''none'', ''up'' or ''down''';
  
  return null;
END;
$$;


ALTER FUNCTION public.content_keyword__is_assigned(is_assigned__item_id integer, is_assigned__keyword_id integer, is_assigned__recurse character varying) OWNER TO evex;

--
-- Name: content_keyword__is_leaf(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__is_leaf(is_leaf__keyword_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN

  return 
      count(*) = 0
  from 
    cr_keywords k
  where
    k.parent_id = is_leaf__keyword_id;
 
END;
$$;


ALTER FUNCTION public.content_keyword__is_leaf(is_leaf__keyword_id integer) OWNER TO evex;

--
-- Name: content_keyword__item_assign(integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__item_assign(item_assign__item_id integer, item_assign__keyword_id integer, item_assign__context_id integer, item_assign__creation_user integer, item_assign__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  exists_p                            boolean;
BEGIN
  
  -- Do nothing if the keyword is assigned already
  select count(*) > 0 into exists_p from dual 
    where exists (select 1 from cr_item_keyword_map
                   where item_id = item_assign__item_id 
                   and keyword_id = item_assign__keyword_id);

  if NOT exists_p then

    insert into cr_item_keyword_map (
      item_id, keyword_id
    ) values (
      item_assign__item_id, item_assign__keyword_id
    );
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_keyword__item_assign(item_assign__item_id integer, item_assign__keyword_id integer, item_assign__context_id integer, item_assign__creation_user integer, item_assign__creation_ip character varying) OWNER TO evex;

--
-- Name: content_keyword__item_unassign(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__item_unassign(item_unassign__item_id integer, item_unassign__keyword_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  delete from cr_item_keyword_map
    where item_id = item_unassign__item_id 
    and keyword_id = item_unassign__keyword_id;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_keyword__item_unassign(item_unassign__item_id integer, item_unassign__keyword_id integer) OWNER TO evex;

--
-- Name: content_keyword__new(character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__new(new__heading character varying, new__description character varying, new__parent_id integer, new__keyword_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__object_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  return content_keyword__new(new__heading,
                              new__description,
                              new__parent_id,
                              new__keyword_id,
                              new__creation_date,
                              new__creation_user,
                              new__creation_ip,
                              new__object_type,
                              null
  );

END;
$$;


ALTER FUNCTION public.content_keyword__new(new__heading character varying, new__description character varying, new__parent_id integer, new__keyword_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__object_type character varying) OWNER TO evex;

--
-- Name: content_keyword__new(character varying, character varying, integer, integer, timestamp with time zone, integer, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__new(new__heading character varying, new__description character varying, new__parent_id integer, new__keyword_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__object_type character varying, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_id                        integer;       
  v_package_id                acs_objects.package_id%TYPE;
BEGIN

  if new__package_id is null then
    v_package_id := acs_object__package_id(new__parent_id);
  else
    v_package_id := new__package_id;
  end if;

  v_id := acs_object__new (new__keyword_id,
                           new__object_type,
                           new__creation_date, 
                           new__creation_user, 
                           new__creation_ip,
                           new__parent_id,
                           't',
                           new__heading,
                           v_package_id
  );
    
  insert into cr_keywords 
    (heading, description, keyword_id, parent_id)
  values
    (new__heading, new__description, v_id, new__parent_id);

  return v_id;
 
END;
$$;


ALTER FUNCTION public.content_keyword__new(new__heading character varying, new__description character varying, new__parent_id integer, new__keyword_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__object_type character varying, new__package_id integer) OWNER TO evex;

--
-- Name: content_keyword__set_description(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__set_description(set_description__keyword_id integer, set_description__description character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  update cr_keywords set 
    description = set_description__description
  where
    keyword_id = set_description__keyword_id;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_keyword__set_description(set_description__keyword_id integer, set_description__description character varying) OWNER TO evex;

--
-- Name: content_keyword__set_heading(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_keyword__set_heading(set_heading__keyword_id integer, set_heading__heading character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  update cr_keywords set 
    heading = set_heading__heading
  where
    keyword_id = set_heading__keyword_id;

  update acs_objects
  set title = set_heading__heading
  where object_id = set_heading__keyword_id;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_keyword__set_heading(set_heading__keyword_id integer, set_heading__heading character varying) OWNER TO evex;

--
-- Name: content_revision__content_copy(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__content_copy(content_copy__revision_id integer, content_copy__revision_id_dest integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_item_id                            cr_items.item_id%TYPE;
  v_content_length                     cr_revisions.content_length%TYPE;
  v_revision_id_dest                   cr_revisions.revision_id%TYPE;
  v_content                            cr_revisions.content%TYPE;
  v_lob                                cr_revisions.lob%TYPE;
  v_new_lob                            cr_revisions.lob%TYPE;
  v_storage_type                       varchar;
BEGIN
  if content_copy__revision_id is null then 
	raise exception 'content_revision__content_copy attempt to copy a null revision_id';
  end if;

  select
    content_length, item_id
  into
    v_content_length, v_item_id
  from
    cr_revisions
  where
    revision_id = content_copy__revision_id;

  -- get the destination revision
  if content_copy__revision_id_dest is null then
    select
      latest_revision into v_revision_id_dest
    from
      cr_items
    where
      item_id = v_item_id;
  else
    v_revision_id_dest := content_copy__revision_id_dest;
  end if;


  -- only copy the content if the source content is not null
  if v_content_length is not null and v_content_length > 0 then

    /* The internal LOB types - BLOB, CLOB, and NCLOB - use copy semantics, as 
       opposed to the reference semantics which apply to BFILEs.
       When a BLOB, CLOB, or NCLOB is copied from one row to another row in 
       the same table or in a different table, the actual LOB value is
       copied, not just the LOB locator. */

    select r.content, r.content_length, r.lob, i.storage_type 
      into v_content, v_content_length, v_lob, v_storage_type
      from cr_revisions r, cr_items i 
     where r.item_id = i.item_id 
       and r.revision_id = content_copy__revision_id;

    if v_storage_type = 'lob' then
        v_new_lob := empty_lob();

	PERFORM lob_copy(v_lob, v_new_lob);

        update cr_revisions
           set content = null,
               content_length = v_content_length,
               lob = v_new_lob
         where revision_id = v_revision_id_dest;
	-- this call has to be before the above instruction,
	-- because lob references the v_new_lob 
	--        PERFORM lob_copy(v_lob, v_new_lob);
    else 
        -- this will work for both file and text types... well sort of.
        -- this really just creates a reference to the first file which is
        -- wrong since, the item_id, revision_id uniquely describes the 
        -- location of the file in the content repository file system.  
        -- after copy is called, the content attribute needs to be updated 
        -- with the new relative file path:

        -- update cr_revisions
        -- set content = '[cr_create_content_file $item_id $revision_id [cr_fs_path]$old_rel_path]'
        -- where revision_id = :revision_id
        
        -- old_rel_path is the content attribute value of the content revision
        -- that is being copied.
        update cr_revisions
           set content = v_content,
               content_length = v_content_length,
               lob = null
         where revision_id = v_revision_id_dest;
    end if;

  end if;

  return 0; 
END;
$_$;


ALTER FUNCTION public.content_revision__content_copy(content_copy__revision_id integer, content_copy__revision_id_dest integer) OWNER TO evex;

--
-- Name: content_revision__copy(integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__copy(copy__revision_id integer, copy__copy_id integer, copy__target_item_id integer, copy__creation_user integer, copy__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_copy_id                    cr_revisions.revision_id%TYPE;
  v_target_item_id             cr_items.item_id%TYPE;
  type_rec                     record;
BEGIN
  -- use the specified item_id or the item_id of the original revision 
  --   if none is specified
  if copy__target_item_id is null then
    select item_id into v_target_item_id from cr_revisions 
      where revision_id = copy__revision_id;
  else
    v_target_item_id := copy__target_item_id;
  end if;

  -- use the copy_id or generate a new copy_id if none is specified
  --   the copy_id is a revision_id
  if copy__copy_id is null then
    select nextval('t_acs_object_id_seq') into v_copy_id from dual;
  else
    v_copy_id := copy__copy_id;
  end if;

  -- create the basic object
  insert into acs_objects (
                 object_id,
                 object_type,
                 context_id,
                 security_inherit_p,
                 creation_user,
                 creation_date,
                 creation_ip,
                 last_modified,
                 modifying_user,
                 modifying_ip,
                 title,
                 package_id)
       select
         v_copy_id as object_id,
         object_type,
         v_target_item_id,
         security_inherit_p,
         copy__creation_user as creation_user,
         now() as creation_date,
         copy__creation_ip as creation_ip,
         now() as last_modified,
         copy__creation_user as modifying_user,
         copy__creation_ip as modifying_ip,
         title,
         package_id
       from
         acs_objects
       where
         object_id = copy__revision_id;

  -- create the basic revision (using v_target_item_id)
  insert into cr_revisions 
      select 
        v_copy_id as revision_id, 
        v_target_item_id as item_id, 
        title, 
        description, 
        publish_date, 
        mime_type, 
        nls_language, 
        lob,
	content,
        content_length
      from 
        cr_revisions 
      where
        revision_id = copy__revision_id;

  -- iterate over the ancestor types and copy attributes
  for type_rec in select ot2.object_type, tree_level(ot2.tree_sortkey) as level
                  from acs_object_types ot1, acs_object_types ot2, acs_objects o
                  where ot2.object_type <> 'acs_object'                       
                    and ot2.object_type <> 'content_revision'
                    and o.object_id = copy__revision_id 
                    and ot1.object_type = o.object_type 
                    and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
                  order by level desc
  LOOP
    PERFORM content_revision__copy_attributes(type_rec.object_type, 
                                              copy__revision_id, v_copy_id);
  end loop;

  return v_copy_id;
 
END;
$$;


ALTER FUNCTION public.content_revision__copy(copy__revision_id integer, copy__copy_id integer, copy__target_item_id integer, copy__creation_user integer, copy__creation_ip character varying) OWNER TO evex;

--
-- Name: content_revision__copy_attributes(character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__copy_attributes(copy_attributes__content_type character varying, copy_attributes__revision_id integer, copy_attributes__copy_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_table_name                            acs_object_types.table_name%TYPE;
  v_id_column                             acs_object_types.id_column%TYPE;
  cols                                    varchar default ''; 
  attr_rec                                record;
BEGIN

  if copy_attributes__content_type is null or copy_attributes__revision_id is null or copy_attributes__copy_id is null then 
     raise exception 'content_revision__copy_attributes called with null % % %',copy_attributes__content_type,copy_attributes__revision_id, copy_attributes__copy_id;
  end if;

  select table_name, id_column into v_table_name, v_id_column
  from acs_object_types where object_type = copy_attributes__content_type;

  for attr_rec in select
                    attribute_name
                  from
                    acs_attributes
                  where
                    object_type = copy_attributes__content_type 
  LOOP
    cols := cols || ', ' || attr_rec.attribute_name;
  end loop;

    execute 'insert into ' || v_table_name || '(' || v_id_column || cols || ')' || ' select ' || copy_attributes__copy_id || 
          ' as ' || v_id_column || cols || ' from ' || 
          v_table_name || ' where ' || v_id_column || ' = ' || 
          copy_attributes__revision_id;

  return 0; 

END;
$$;


ALTER FUNCTION public.content_revision__copy_attributes(copy_attributes__content_type character varying, copy_attributes__revision_id integer, copy_attributes__copy_id integer) OWNER TO evex;

--
-- Name: content_revision__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__del(delete__revision_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_item_id              cr_items.item_id%TYPE;
  v_latest_revision      cr_revisions.revision_id%TYPE;
BEGIN
  --
  -- Get item_id and the latest revision
  --
  select item_id
  into   v_item_id
  from   cr_revisions 
  where  revision_id = delete__revision_id;

  select latest_revision
  into   v_latest_revision
  from   cr_items
  where  item_id = v_item_id;

  --
  -- Recalculate latest revision in case it was deleted
  --
  if v_latest_revision = delete__revision_id then

      select r.revision_id
       into v_latest_revision
       from cr_revisions r, acs_objects o
      where o.object_id = r.revision_id
        and r.item_id = v_item_id
        and r.revision_id <> delete__revision_id
      order by o.creation_date desc limit 1;

      if NOT FOUND then
         v_latest_revision := null;
      end if;

      update cr_items set latest_revision = v_latest_revision
      where item_id = v_item_id;
      
  end if; 

  --
  -- Delete the revision
  --
  PERFORM acs_object__delete(delete__revision_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_revision__del(delete__revision_id integer) OWNER TO evex;

--
-- Name: content_revision__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__delete(delete__revision_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  PERFORM content_revision__del(delete__revision_id);
  return 0; 
END;
$$;


ALTER FUNCTION public.content_revision__delete(delete__revision_id integer) OWNER TO evex;

--
-- Name: content_revision__get_content(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__get_content(get_content__revision_id integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_storage_type                      varchar;
  v_lob_id                            integer;
  v_data                              text;
BEGIN
       select i.storage_type, r.lob 
         into v_storage_type, v_lob_id
         from cr_items i, cr_revisions r
        where i.item_id = r.item_id 
          and r.revision_id = get_content__revision_id;
        
        if v_storage_type = 'lob' then
           return v_lob_id::text;
        else 
           return content
             from cr_revisions
            where revision_id = get_content__revision_id;
        end if;

END;
$$;


ALTER FUNCTION public.content_revision__get_content(get_content__revision_id integer) OWNER TO evex;

--
-- Name: content_revision__get_number(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__get_number(get_number__revision_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_revision                         cr_revisions.revision_id%TYPE;
  v_row_count                        integer default 0;
  rev_cur                            record;
BEGIN
  for rev_cur in select
                   revision_id
                 from 
                   cr_revisions r, acs_objects o
                 where
                   item_id = (select item_id from cr_revisions 
                               where revision_id = get_number__revision_id)
                 and
                   o.object_id = r.revision_id
                 order by
                   o.creation_date
  LOOP
    v_row_count := v_row_count + 1;
    if rev_cur.revision_id = get_number__revision_id then 
       return v_row_count;
       exit;
    end if;
  end LOOP;

  return null;
 
END;
$$;


ALTER FUNCTION public.content_revision__get_number(get_number__revision_id integer) OWNER TO evex;

--
-- Name: content_revision__is_latest(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__is_latest(is_latest__revision_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN

  return count(*) > 0 from cr_items
    where latest_revision = is_latest__revision_id;
 
END;
$$;


ALTER FUNCTION public.content_revision__is_latest(is_latest__revision_id integer) OWNER TO evex;

--
-- Name: content_revision__is_live(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__is_live(is_live__revision_id integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
BEGIN

  return count(*) > 0 from cr_items
   where live_revision = is_live__revision_id;

END;
$$;


ALTER FUNCTION public.content_revision__is_live(is_live__revision_id integer) OWNER TO evex;

--
-- Name: content_revision__new(character varying, character varying, timestamp with time zone, character varying, text, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__new(new__title character varying, new__description character varying, new__publish_date timestamp with time zone, new__mime_type character varying, new__text text, new__item_id integer, new__package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	raise NOTICE 'content_revision__new/7 is deprecated, call content_revision__new/13 instead';

        return content_revision__new(new__title,
                                     new__description,
                                     new__publish_date,
                                     new__mime_type,
                                     null,
                                     new__text,
                                     new__item_id,
                                     null,
                                     now(),
                                     null,
                                     null,
                                     null,
                                     new__package_id
               );

END;
$$;


ALTER FUNCTION public.content_revision__new(new__title character varying, new__description character varying, new__publish_date timestamp with time zone, new__mime_type character varying, new__text text, new__item_id integer, new__package_id integer) OWNER TO evex;

--
-- Name: content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__new(new__title character varying, new__description character varying, new__publish_date timestamp with time zone, new__mime_type character varying, new__nls_language character varying, new__data integer, new__item_id integer, new__revision_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_revision_id               integer;       
  v_package_id                acs_objects.package_id%TYPE;
  v_content_type              acs_object_types.object_type%TYPE;
BEGIN

  v_content_type := content_item__get_content_type(new__item_id);

  if new__package_id is null then
    v_package_id := acs_object__package_id(new__item_id);
  else
    v_package_id := new__package_id;
  end if;

  v_revision_id := acs_object__new(
      new__revision_id,
      v_content_type, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      new__item_id,
      't',
      new__title,
      v_package_id
  );

  -- binary data is stored in cr_revisions using Dons lob hack.
  -- This routine only inserts the lob id.  It would need to be followed by 
  -- ns_pg blob_dml from within a tcl script to actually insert the lob data.

  -- After the lob data is inserted, the content_length needs to be updated 
  -- as well.
  -- DanW, 2001-05-10.

  insert into cr_revisions (
    revision_id, title, description, mime_type, publish_date,
    nls_language, lob, item_id, content_length
  ) values (
    v_revision_id, new__title, new__description,
    new__mime_type, 
    new__publish_date, new__nls_language, new__data, 
    new__item_id, 0
  );

  return v_revision_id;

END;
$$;


ALTER FUNCTION public.content_revision__new(new__title character varying, new__description character varying, new__publish_date timestamp with time zone, new__mime_type character varying, new__nls_language character varying, new__data integer, new__item_id integer, new__revision_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer) OWNER TO evex;

--
-- Name: content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, text, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__new(new__title character varying, new__description character varying, new__publish_date timestamp with time zone, new__mime_type character varying, new__nls_language character varying, new__text text, new__item_id integer, new__revision_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$   
DECLARE
BEGIN
	raise NOTICE 'content_revision__new/12 is deprecated, call content_revision__new/13 instead';

        return content_revision__new(new__title,
                                     new__description,
                                     new__publish_date,
                                     new__mime_type,
                                     new__nls_language,
                                     new__text,
                                     new__item_id,
                                     new__revision_id,
                                     new__creation_date,
                                     new__creation_user,
                                     new__creation_ip,
                                     null,               -- content_length
                                     new__package_id
		);
END
$$;


ALTER FUNCTION public.content_revision__new(new__title character varying, new__description character varying, new__publish_date timestamp with time zone, new__mime_type character varying, new__nls_language character varying, new__text text, new__item_id integer, new__revision_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer) OWNER TO evex;

--
-- Name: content_revision__new(character varying, character varying, timestamp with time zone, character varying, character varying, text, integer, integer, timestamp with time zone, integer, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__new(new__title character varying, new__description character varying, new__publish_date timestamp with time zone, new__mime_type character varying, new__nls_language character varying, new__text text, new__item_id integer, new__revision_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__content_length integer, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_revision_id               integer;       
  v_package_id                acs_objects.package_id%TYPE;
  v_content_type              acs_object_types.object_type%TYPE;
  v_storage_type              cr_items.storage_type%TYPE;
  v_length                    cr_revisions.content_length%TYPE;
BEGIN

  v_content_type := content_item__get_content_type(new__item_id);

  if new__package_id is null then
    v_package_id := acs_object__package_id(new__item_id);
  else
    v_package_id := new__package_id;
  end if;

  v_revision_id := acs_object__new(
      new__revision_id,
      v_content_type, 
      new__creation_date, 
      new__creation_user, 
      new__creation_ip, 
      new__item_id,
      't',
      new__title,
      v_package_id
  );

  select storage_type into v_storage_type
    from cr_items
   where item_id = new__item_id;

  if v_storage_type = 'text' then 
     v_length := length(new__text);
  else
     v_length := coalesce(new__content_length,0);
  end if;

  -- text data is stored directly in cr_revisions using text datatype.

  insert into cr_revisions (
    revision_id, title, description, mime_type, publish_date,
    nls_language, content, item_id, content_length
  ) values (
    v_revision_id, new__title, new__description,
     new__mime_type, 
    new__publish_date, new__nls_language, 
    new__text, new__item_id, v_length
  );

  return v_revision_id;
 
END;
$$;


ALTER FUNCTION public.content_revision__new(new__title character varying, new__description character varying, new__publish_date timestamp with time zone, new__mime_type character varying, new__nls_language character varying, new__text text, new__item_id integer, new__revision_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__content_length integer, new__package_id integer) OWNER TO evex;

--
-- Name: content_revision__revision_name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__revision_name(p_revision_id integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
        return 'Revision ' || content_revision__get_number(revision_id) || 
               ' of ' || (select count(*) from cr_revisions where item_id = r.item_id) || ' for item: ' 
               || content_item__get_title(item_id)
               from cr_revisions r where r.revision_id = p_revision_id;
END;
$$;


ALTER FUNCTION public.content_revision__revision_name(p_revision_id integer) OWNER TO evex;

--
-- Name: content_revision__to_html(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__to_html(to_html__revision_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp_clob                        text;          
  blob_loc                        integer;          
BEGIN

  -- FIXME
  -- ctx_doc.filter('cr_doc_filter_index', revision_id, tmp_clob);

  select 
    content into blob_loc
  from 
    cr_revisions 
  where 
    revision_id = to_html__revision_id
  for update;

 PERFORM clob_to_blob(tmp_clob, blob_loc);

 PERFORM dbms_lob__freetemporary(tmp_clob);

 return 0; 
END;
$$;


ALTER FUNCTION public.content_revision__to_html(to_html__revision_id integer) OWNER TO evex;

--
-- Name: content_revision__to_temporary_clob(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_revision__to_temporary_clob(to_temporary_clob__revision_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  -- b                                         blob;          
  -- c                                         text;          
BEGIN
  -- FIXME:  I cannot find an instance in the 4.2 beta code where this
  --         is used so I am not worrying about porting it for now.
  --         DCW - 2001-03-28.

  raise EXCEPTION 'not implemented content_revision.to_temporary_clob';
/*
  insert into cr_content_text (
    revision_id, content
  ) values (
    revision_id, empty_clob()
  ) returning content into c;

  select content into b from cr_revisions 
    where revision_id = to_temporary_clob__revision_id;

  PERFORM blob_to_clob(b, c);
*/
  return 0; 
END;
$$;


ALTER FUNCTION public.content_revision__to_temporary_clob(to_temporary_clob__revision_id integer) OWNER TO evex;

--
-- Name: content_search__itrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_search__itrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
if (select live_revision from cr_items where item_id=new.item_id) = new.revision_id and new.publish_date >= current_timestamp then
        perform search_observer__enqueue(new.revision_id,'INSERT');
    end if;
    return new;
END;
$$;


ALTER FUNCTION public.content_search__itrg() OWNER TO evex;

--
-- Name: content_search__utrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_search__utrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_live_revision integer;
BEGIN
    select into v_live_revision live_revision from
        cr_items where item_id=old.item_id;
    if old.revision_id=v_live_revision
      and new.publish_date <= current_timestamp then
        insert into search_observer_queue (
            object_id,
            event
        ) values (
old.revision_id,
            'UPDATE'
        );
    end if;
    return new;
END;
$$;


ALTER FUNCTION public.content_search__utrg() OWNER TO evex;

--
-- Name: content_symlink__copy(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__copy(copy__symlink_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_symlink__copy/4 maybe obsolete, when we define proper defaults for /5
--
DECLARE
  v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_target_id                  cr_items.item_id%TYPE;
  v_label                      cr_symlinks.label%TYPE;
  v_symlink_id                 cr_symlinks.symlink_id%TYPE;
BEGIN
	v_symlink_id := content_symlink__copy (
		copy__symlink_id,
		copy__target_folder_id,
	        copy__creation_user,
                copy__creation_ip,
                NULL
                );
	return v_symlink_id;
END;
$$;


ALTER FUNCTION public.content_symlink__copy(copy__symlink_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying) OWNER TO evex;

--
-- Name: content_symlink__copy(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__copy(copy__symlink_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying, copy__name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
v_current_folder_id          cr_folders.folder_id%TYPE;
  v_name                       cr_items.name%TYPE;
  v_target_id                  cr_items.item_id%TYPE;
  v_label                      cr_symlinks.label%TYPE;
  v_symlink_id                 cr_symlinks.symlink_id%TYPE;
BEGIN
  -- XXX: bug if target is not a folder this will silently fail.

  if content_folder__is_folder(copy__target_folder_id) = 't' then
    select
      parent_id
    into
      v_current_folder_id
    from
      cr_items
    where
      item_id = copy__symlink_id;

    -- can't copy to the same folder unless name is different

    select
      i.name, content_symlink__resolve(i.item_id), s.label
    into
      v_name, v_target_id, v_label
    from
      cr_symlinks s, cr_items i
    where
      s.symlink_id = i.item_id
    and
      s.symlink_id = copy__symlink_id;

	-- copy to a different folder, or same folder if name
	-- is different
    if copy__target_folder_id != v_current_folder_id  or ( v_name <> copy_name and copy_name is not null ) then
      if content_folder__is_registered(copy__target_folder_id,
        'content_symlink','f') = 't' then
        if content_folder__is_registered(copy__target_folder_id,
          content_item__get_content_type(content_symlink__resolve(copy__symlink_id)),'f') = 't' then

	  v_symlink_id := content_symlink__new(
              coalesce (copy__name,v_name),
	      v_label,
              v_target_id,
              copy__target_folder_id,
              null,
              now(),
	      copy__creation_user,
	      copy__creation_ip,
              null
          );


	end if;
      end if;
    end if;
  end if;

  return v_symlink_id; 
END;
$$;


ALTER FUNCTION public.content_symlink__copy(copy__symlink_id integer, copy__target_folder_id integer, copy__creation_user integer, copy__creation_ip character varying, copy__name character varying) OWNER TO evex;

--
-- Name: content_symlink__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__del(del__symlink_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  delete from cr_symlinks
    where symlink_id = del__symlink_id;

  PERFORM content_item__delete(del__symlink_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_symlink__del(del__symlink_id integer) OWNER TO evex;

--
-- Name: content_symlink__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__delete(delete__symlink_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  PERFORM content_symlink__del(delete__symlink_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_symlink__delete(delete__symlink_id integer) OWNER TO evex;

--
-- Name: content_symlink__is_symlink(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__is_symlink(is_symlink__item_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_symlink_p                        boolean;
BEGIN

  select 
    count(*) = 1 into v_symlink_p
  from 
    cr_symlinks
  where 
    symlink_id = is_symlink__item_id;

  return v_symlink_p;  
 
END;
$$;


ALTER FUNCTION public.content_symlink__is_symlink(is_symlink__item_id integer) OWNER TO evex;

--
-- Name: content_symlink__new(character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__new(new__name character varying, new__label character varying, new__target_id integer, new__parent_id integer, new__symlink_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_symlink__new/8 maybe obsolete, when we define proper defaults for /9
--
DECLARE
BEGIN
  return content_extlink__new(new__name,
                              new__label,
                              new__target_id,
                              new__parent_id,
                              new__symlink_id,
                              new__creation_date,
                              new__creation_user,
                              new__creation_ip,
                              null
  );

END;
$$;


ALTER FUNCTION public.content_symlink__new(new__name character varying, new__label character varying, new__target_id integer, new__parent_id integer, new__symlink_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) OWNER TO evex;

--
-- Name: content_symlink__new(character varying, character varying, integer, integer, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__new(new__name character varying, new__label character varying, new__target_id integer, new__parent_id integer, new__symlink_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_symlink_id                cr_symlinks.symlink_id%TYPE;
  v_package_id                acs_objects.package_id%TYPE;
  v_name                      cr_items.name%TYPE;
  v_label                     cr_symlinks.label%TYPE;
  v_ctype                     varchar;
BEGIN

  -- SOME CHECKS --

  -- 1) check that the target is now a symlink
  if content_symlink__is_symlink(new__target_id) = 't' then
    raise EXCEPTION '-20000: Cannot create a symlink to a symlink %', new__target_id;
  end if;

  -- 2) check that the parent is a folder
  if content_folder__is_folder(new__parent_id) = 'f' then
    raise EXCEPTION '-20000: The parent is not a folder';
  end if;

  -- 3) check that parent folder supports symlinks
  if content_folder__is_registered(new__parent_id,'content_symlink','f') = 'f' then
    raise EXCEPTION '-20000: This folder does not allow symlinks to be created';
  end if;

  -- 4) check that the content folder supports the target items content type
  if content_folder__is_registered(new__parent_id, content_item__get_content_type(new__target_id), 'f') = 'f' then

    v_ctype := content_item__get_content_type(new__target_id);
    raise EXCEPTION '-20000: This folder does not allow symlinks to items of type % to be created', v_ctype;
  end if;

  -- PASSED ALL CHECKS --

  -- Select default name if the name is null
  if  new__name is null or new__name = '' then
    select 
      'symlink_to_' ||  name into v_name
    from 
      cr_items
    where
       item_id =  new__target_id;
  
    if NOT FOUND then 
       v_name := null;
    end if;
  else
    v_name :=  new__name;
  end if;

  -- Select default label if the label is null
  if new__label is null then
    v_label := 'Symlink to ' || v_name;
  else
    v_label := new__label;
  end if;

  if new__package_id is null then
    v_package_id := acs_object__package_id(new__parent_id);
  else
    v_package_id := new__package_id;
  end if;

  v_symlink_id := content_item__new(
      v_name, 
      new__parent_id,
      new__symlink_id,
      null,
      new__creation_date, 
      new__creation_user, 
      null,
      new__creation_ip, 
      'content_item',
      'content_symlink', 
      null,
      null,
      'text/plain',
      null,
      null,
      'text',
      v_package_id
  );

  insert into cr_symlinks
    (symlink_id, target_id, label)
  values
    (v_symlink_id, new__target_id, v_label);

  update acs_objects
  set title = v_label
  where object_id = v_symlink_id;

  return v_symlink_id;

END;
$$;


ALTER FUNCTION public.content_symlink__new(new__name character varying, new__label character varying, new__target_id integer, new__parent_id integer, new__symlink_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__package_id integer) OWNER TO evex;

--
-- Name: content_symlink__resolve(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__resolve(resolve__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_target_id                     cr_items.item_id%TYPE;
BEGIN

  select
    target_id into v_target_id
  from
    cr_symlinks
  where
    symlink_id = resolve__item_id;
  
  if NOT FOUND then
     return resolve__item_id;
  else
     return v_target_id;
  end if;

END;
$$;


ALTER FUNCTION public.content_symlink__resolve(resolve__item_id integer) OWNER TO evex;

--
-- Name: content_symlink__resolve_content_type(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_symlink__resolve_content_type(resolve_content_type__item_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_content_type                               cr_items.content_type%TYPE;
BEGIN

  select 
    content_item__get_content_type(target_id) into v_content_type
  from
    cr_symlinks
  where
    symlink_id = resolve_content_type__item_id;

  return v_content_type;
 
END;
$$;


ALTER FUNCTION public.content_symlink__resolve_content_type(resolve_content_type__item_id integer) OWNER TO evex;

--
-- Name: content_template__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__del(delete__template_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  delete from cr_type_template_map
    where template_id = delete__template_id;

  delete from cr_item_template_map
    where template_id = delete__template_id;
 
  delete from cr_templates
    where template_id = delete__template_id;

  PERFORM content_item__delete(delete__template_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_template__del(delete__template_id integer) OWNER TO evex;

--
-- Name: content_template__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__delete(delete__template_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  PERFORM content_template__delete(delete__template_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_template__delete(delete__template_id integer) OWNER TO evex;

--
-- Name: content_template__get_path(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__get_path(template_id integer, root_folder_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
                                        
BEGIN

  return content_item__get_path(template_id, root_folder_id);

END;
$$;


ALTER FUNCTION public.content_template__get_path(template_id integer, root_folder_id integer) OWNER TO evex;

--
-- Name: content_template__get_root_folder(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__get_root_folder() RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  v_folder_id                 integer;
BEGIN
  select c_root_folder_id from content_template_globals into v_folder_id;
  return v_folder_id;
END;
$$;


ALTER FUNCTION public.content_template__get_root_folder() OWNER TO evex;

--
-- Name: content_template__is_template(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__is_template(is_template__template_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN
  
  return count(*) > 0 from cr_templates
    where template_id = is_template__template_id;
 
END;
$$;


ALTER FUNCTION public.content_template__is_template(is_template__template_id integer) OWNER TO evex;

--
-- Name: content_template__new(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__new(new__name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_template__new/1 maybe obsolete, when we define proper defaults for /8
--
DECLARE
BEGIN
        return content_template__new(new__name,
                                     null,
                                     null,
                                     now(),
                                     null,
                                     null
        );

END;
$$;


ALTER FUNCTION public.content_template__new(new__name character varying) OWNER TO evex;

--
-- Name: content_template__new(character varying, text, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__new(new__name character varying, new__text text, new__is_live boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_template__new/3 maybe obsolete, when we define proper defaults for /8
--
DECLARE
BEGIN
        return content_template__new(new__name,
                                     null,
                                     null,
                                     now(),
                                     null,
                                     null,
                                     new__text,
                                     new__is_live
        );

END;
$$;


ALTER FUNCTION public.content_template__new(new__name character varying, new__text text, new__is_live boolean) OWNER TO evex;

--
-- Name: content_template__new(character varying, integer, integer, timestamp with time zone, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__new(new__name character varying, new__parent_id integer, new__template_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- content_template__new/6 maybe obsolete, when we define proper defaults for /8
--
DECLARE
  v_template_id               cr_templates.template_id%TYPE;
  v_parent_id                 cr_items.parent_id%TYPE;
BEGIN

  if new__parent_id is null then
    select c_root_folder_id into v_parent_id from content_template_globals;
  else
    v_parent_id := new__parent_id;
  end if;

  -- make sure we're allowed to create a template in this folder
  if content_folder__is_folder(new__parent_id) = 't' and
    content_folder__is_registered(new__parent_id,'content_template','f') = 'f' then

    raise EXCEPTION '-20000: This folder does not allow templates to be created';

  else
    v_template_id := content_item__new (
        new__name, 
        v_parent_id,
        new__template_id,
        null,
        new__creation_date, 
        new__creation_user, 
        null,
        new__creation_ip,
        'content_item',
        'content_template',
        null,   -- title
        null,   -- description
        'text/plain',
        null,   -- nls_language
        null,   -- text
        null,   -- data
        null,   -- relation_tag
        'f',    -- is_live
        'text', -- storage_type
        null,   -- package_id
        't'     -- with_child_rels
    );  

    insert into cr_templates ( 
      template_id 
    ) values (
      v_template_id
    );

    return v_template_id;

  end if;
 
END;
$$;


ALTER FUNCTION public.content_template__new(new__name character varying, new__parent_id integer, new__template_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying) OWNER TO evex;

--
-- Name: content_template__new(character varying, integer, integer, timestamp with time zone, integer, character varying, text, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_template__new(new__name character varying, new__parent_id integer, new__template_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__text text, new__is_live boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_template_id               cr_templates.template_id%TYPE;
  v_parent_id                 cr_items.parent_id%TYPE;
BEGIN

  if new__parent_id is null then
    select c_root_folder_id into v_parent_id from content_template_globals;
  else
    v_parent_id := new__parent_id;
  end if;

  -- make sure we're allowed to create a template in this folder
  if content_folder__is_folder(new__parent_id) = 't' and
    content_folder__is_registered(new__parent_id,'content_template','f') = 'f' then

    raise EXCEPTION '-20000: This folder does not allow templates to be created';

  else
    v_template_id := content_item__new (
        new__template_id,     -- new__item_id
        new__name,            -- new__name
        v_parent_id,          -- new__parent_id
        null,                 -- new__title
        new__creation_date,   -- new__creation_date
        new__creation_user,   -- new__creation_user
        null,                 -- new__context_id
        new__creation_ip,     -- new__creation_ip
        new__is_live,         -- new__is_live
        'text/plain',       -- new__mime_type
        new__text,            -- new__text
        'text',             -- new__storage_type
        't',                -- new__security_inherit_p
        'CR_FILES',         -- new__storage_area_key
        'content_item',     -- new__item_subtype
        'content_template'  -- new__content_type
    );

    insert into cr_templates ( 
      template_id 
    ) values (
      v_template_id
    );

    return v_template_id;

  end if;
 
END;
$$;


ALTER FUNCTION public.content_template__new(new__name character varying, new__parent_id integer, new__template_id integer, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__text text, new__is_live boolean) OWNER TO evex;

--
-- Name: content_type__create_attribute(character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__create_attribute(create_attribute__content_type character varying, create_attribute__attribute_name character varying, create_attribute__datatype character varying, create_attribute__pretty_name character varying, create_attribute__pretty_plural character varying, create_attribute__sort_order integer, create_attribute__default_value character varying, create_attribute__column_spec character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_attr_id                                acs_attributes.attribute_id%TYPE;
  v_table_name                             acs_object_types.table_name%TYPE;
  v_column_exists                          boolean;       
BEGIN

 -- add the appropriate column to the table
 
 select table_name into v_table_name from acs_object_types
  where object_type = create_attribute__content_type;

 if NOT FOUND then
   raise EXCEPTION '-20000: Content type % does not exist in content_type.create_attribute', create_attribute__content_type;
 end if; 

 select count(*) > 0 into v_column_exists 
   from pg_class c, pg_attribute a
  where c.relname::varchar = v_table_name
    and c.oid = a.attrelid
    and a.attname = lower(create_attribute__attribute_name);

 v_attr_id := acs_attribute__create_attribute (
   create_attribute__content_type,
   create_attribute__attribute_name,
   create_attribute__datatype,
   create_attribute__pretty_name,
   create_attribute__pretty_plural,
   null,
   null,
   create_attribute__default_value,
   1,
   1,
   create_attribute__sort_order,
   'type_specific',
   'f',
   not v_column_exists,
   null,
   null,
   null,
   null,
   null,
   create_attribute__column_spec
 );

 PERFORM content_type__refresh_view(create_attribute__content_type);

 return v_attr_id;

END;
$$;


ALTER FUNCTION public.content_type__create_attribute(create_attribute__content_type character varying, create_attribute__attribute_name character varying, create_attribute__datatype character varying, create_attribute__pretty_name character varying, create_attribute__pretty_plural character varying, create_attribute__sort_order integer, create_attribute__default_value character varying, create_attribute__column_spec character varying) OWNER TO evex;

--
-- Name: content_type__create_type(character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__create_type(create_type__content_type character varying, create_type__supertype character varying, create_type__pretty_name character varying, create_type__pretty_plural character varying, create_type__table_name character varying, create_type__id_column character varying, create_type__name_method character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_temp_p                            boolean;       
  v_supertype_table                   acs_object_types.table_name%TYPE;
                                        
BEGIN

  if (create_type__supertype <> 'content_revision')
      and (create_type__content_type <> 'content_revision') then
    select count(*) > 0 into v_temp_p
    from  acs_object_type_supertype_map
    where object_type = create_type__supertype
    and ancestor_type = 'content_revision';

    if not v_temp_p then
      raise EXCEPTION '-20000: supertype % must be a subtype of content_revision', create_type__supertype;
    end if;
  end if;

  select count(*) = 0 into v_temp_p 
    from pg_class
   where relname = lower(create_type__table_name);

  PERFORM acs_object_type__create_type (
    create_type__content_type,
    create_type__pretty_name,
    create_type__pretty_plural,
    create_type__supertype,
    create_type__table_name,
    create_type__id_column,
    null,
    'f',
    null,
    create_type__name_method,
    v_temp_p,
    'f'
  );

  PERFORM content_type__refresh_view(create_type__content_type);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__create_type(create_type__content_type character varying, create_type__supertype character varying, create_type__pretty_name character varying, create_type__pretty_plural character varying, create_type__table_name character varying, create_type__id_column character varying, create_type__name_method character varying) OWNER TO evex;

--
-- Name: content_type__drop_attribute(character varying, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__drop_attribute(drop_attribute__content_type character varying, drop_attribute__attribute_name character varying, drop_attribute__drop_column boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_attr_id                              acs_attributes.attribute_id%TYPE;
  v_table                                acs_object_types.table_name%TYPE;
BEGIN

  -- Get attribute information 
  select 
    upper(t.table_name), a.attribute_id 
  into 
    v_table, v_attr_id
  from 
    acs_object_types t, acs_attributes a
  where 
    t.object_type = drop_attribute__content_type
  and 
    a.object_type = drop_attribute__content_type
  and
    a.attribute_name = drop_attribute__attribute_name;
    
  if NOT FOUND then
    raise EXCEPTION '-20000: Attribute %:% does not exist in content_type.drop_attribute', drop_attribute__content_type, drop_attribute__attribute_name;
  end if;

  -- Drop the attribute
  PERFORM acs_attribute__drop_attribute(drop_attribute__content_type, 
                                        drop_attribute__attribute_name);

  -- FIXME: postgresql does not support drop column.
  -- Drop the column if neccessary
  if drop_attribute__drop_column then
      execute 'alter table ' || v_table || ' drop column ' ||
        drop_attribute__attribute_name || ' cascade';

  end if;  

  PERFORM content_type__refresh_view(drop_attribute__content_type);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__drop_attribute(drop_attribute__content_type character varying, drop_attribute__attribute_name character varying, drop_attribute__drop_column boolean) OWNER TO evex;

--
-- Name: content_type__drop_type(character varying, boolean, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__drop_type(drop_type__content_type character varying, drop_type__drop_children_p boolean, drop_type__drop_table_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  table_exists_p                      boolean;       
  v_table_name                      varchar;   
  is_subclassed_p                   boolean;      
  child_rec                         record;    
  attr_row                          record;
BEGIN

  -- first we'll rid ourselves of any dependent child types, if any , 
  -- along with their own dependent grandchild types

  select 
    count(*) > 0 into is_subclassed_p 
  from 
    acs_object_types 
  where supertype = drop_type__content_type;

  -- this is weak and will probably break;
  -- to remove grand child types, the process will probably
  -- require some sort of querying for drop_type 
  -- methods within the children's packages to make
  -- certain there are no additional unanticipated
  -- restraints preventing a clean drop

  if drop_type__drop_children_p and is_subclassed_p then

    for child_rec in select 
                       object_type
                     from 
                       acs_object_types
                     where
                       supertype = drop_type__content_type 
    LOOP
      PERFORM content_type__drop_type(child_rec.object_type, 't', 'f');
    end LOOP;

  end if;

  -- now drop all the attributes related to this type
  for attr_row in select
                    attribute_name
                  from
                    acs_attributes
                  where
                    object_type = drop_type__content_type 
  LOOP
    PERFORM content_type__drop_attribute(drop_type__content_type,
                                         attr_row.attribute_name,
                                         'f'
    );
  end LOOP;

  -- we'll remove the associated table if it exists
  select 
    table_exists(lower(table_name)) into table_exists_p
  from 
    acs_object_types
  where 
    object_type = drop_type__content_type;

  if table_exists_p and drop_type__drop_table_p then
    select 
      table_name into v_table_name 
    from 
      acs_object_types 
    where
      object_type = drop_type__content_type;
       
    -- drop the rule and input/output views for the type
    -- being dropped.
    -- FIXME: this did not exist in the oracle code and it needs to be
    -- tested.  Thanks to Vinod Kurup for pointing this out.
    -- The rule dropping might be redundant as the rule might be dropped
    -- when the view is dropped.

    execute 'drop rule ' || v_table_name || '_r ' || 'on ' || v_table_name || 'i';
    execute 'drop view ' || v_table_name || 'x cascade';
    execute 'drop view ' || v_table_name || 'i cascade';

    execute 'drop table ' || v_table_name;
  end if;

  PERFORM acs_object_type__drop_type(drop_type__content_type, 'f');

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__drop_type(drop_type__content_type character varying, drop_type__drop_children_p boolean, drop_type__drop_table_p boolean) OWNER TO evex;

--
-- Name: content_type__drop_type(character varying, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__drop_type(drop_type__content_type character varying, drop_type__drop_children_p boolean, drop_type__drop_table_p boolean, drop_type__drop_objects_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  table_exists_p                      boolean;       
  v_table_name                      varchar;   
  is_subclassed_p                   boolean;      
  child_rec                         record;    
  attr_row                          record;
  revision_row                      record;
  item_row                          record;
BEGIN

  -- first we'll rid ourselves of any dependent child types, if any , 
  -- along with their own dependent grandchild types

  select 
    count(*) > 0 into is_subclassed_p 
  from 
    acs_object_types 
  where supertype = drop_type__content_type;

  -- this is weak and will probably break;
  -- to remove grand child types, the process will probably
  -- require some sort of querying for drop_type 
  -- methods within the children's packages to make
  -- certain there are no additional unanticipated
  -- restraints preventing a clean drop

  if drop_type__drop_children_p and is_subclassed_p then

    for child_rec in select 
                       object_type
                     from 
                       acs_object_types
                     where
                       supertype = drop_type__content_type 
    LOOP
      PERFORM content_type__drop_type(child_rec.object_type, 't', drop_type__drop_table_p, drop_type__drop_objects_p);
    end LOOP;

  end if;

  -- now drop all the attributes related to this type
  for attr_row in select
                    attribute_name
                  from
                    acs_attributes
                  where
                    object_type = drop_type__content_type 
  LOOP
    PERFORM content_type__drop_attribute(drop_type__content_type,
                                         attr_row.attribute_name,
                                         'f'
    );
  end LOOP;

  -- we'll remove the associated table if it exists
  select 
    table_exists(lower(table_name)) into table_exists_p
  from 
    acs_object_types
  where 
    object_type = drop_type__content_type;

  if table_exists_p and drop_type__drop_table_p then
    select 
      table_name into v_table_name 
    from 
      acs_object_types 
    where
      object_type = drop_type__content_type;
       
    -- drop the rule and input/output views for the type
    -- being dropped.
    -- FIXME: this did not exist in the oracle code and it needs to be
    -- tested.  Thanks to Vinod Kurup for pointing this out.
    -- The rule dropping might be redundant as the rule might be dropped
    -- when the view is dropped.

    -- different syntax for dropping a rule in 7.2 and 7.3 so check which
    -- version is being used (olah).

    execute 'drop table ' || v_table_name || ' cascade';

  end if;

  -- If we are dealing with a revision, delete the revision with revision__delete
  -- This way the integrity constraint with live revision is dealt with correctly
  if drop_type__drop_objects_p then
    for revision_row in
      select revision_id 
      from cr_revisions, acs_objects
      where revision_id = object_id
      and object_type = drop_type__content_type
    loop
      PERFORM content_revision__delete(revision_row.revision_id);
    end loop;

    for item_row in
      select item_id 
      from cr_items
      where content_type = drop_type__content_type
    loop
      PERFORM content_item__delete(item_row.item_id);
    end loop;

  end if;

  PERFORM acs_object_type__drop_type(drop_type__content_type, drop_type__drop_objects_p);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__drop_type(drop_type__content_type character varying, drop_type__drop_children_p boolean, drop_type__drop_table_p boolean, drop_type__drop_objects_p boolean) OWNER TO evex;

--
-- Name: content_type__get_template(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__get_template(get_template__content_type character varying, get_template__use_context character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_template_id                        cr_templates.template_id%TYPE;
BEGIN
  select
    template_id
  into
    v_template_id
  from
    cr_type_template_map
  where
    content_type = get_template__content_type
  and
    use_context = get_template__use_context
  and
    is_default = 't';

  return v_template_id;
 
END;
$$;


ALTER FUNCTION public.content_type__get_template(get_template__content_type character varying, get_template__use_context character varying) OWNER TO evex;

--
-- Name: content_type__is_content_type(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__is_content_type(is_content_type__object_type character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_is_content_type                       boolean;
BEGIN

  if is_content_type__object_type = 'content_revision' then

    v_is_content_type := 't';

  else    
    select count(*) > 0 into v_is_content_type
    from acs_object_type_supertype_map
    where object_type = is_content_type__object_type 
    and ancestor_type = 'content_revision';
  end if;
  
  return v_is_content_type;
 
END;
$$;


ALTER FUNCTION public.content_type__is_content_type(is_content_type__object_type character varying) OWNER TO evex;

--
-- Name: content_type__refresh_trigger(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__refresh_trigger(refresh_trigger__content_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  rule_text                               text default '';
  function_text                           text default '';
  v_table_name                            acs_object_types.table_name%TYPE;
  type_rec                                record;
BEGIN

  -- get the table name for the content type (determines view name)
  raise NOTICE 'refresh trigger for % ', refresh_trigger__content_type;

    -- Since we allow null table name use object type if table name is null so
  -- we still can have a view.
  select coalesce(table_name,object_type)
    into v_table_name
    from acs_object_types 
   where object_type = refresh_trigger__content_type;

  --=================== start building rule code =======================

  function_text := function_text ||
             'create or replace function ' || v_table_name || '_f (p_new '|| v_table_name || 'i)
             returns void as ''
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                ';

  -- add an insert statement for each subtype in the hierarchy for this type

  for type_rec in select ot2.object_type, tree_level(ot2.tree_sortkey) as level
                  from acs_object_types ot1, acs_object_types ot2
                  where ot2.object_type <> 'acs_object'                       
                    and ot2.object_type <> 'content_revision'
                    and ot1.object_type = refresh_trigger__content_type
                    and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
                    and ot1.table_name is not null
                  order by level asc
  LOOP
    function_text := function_text || content_type__trigger_insert_statement(type_rec.object_type) || ';
    ';
  end loop;

  function_text := function_text || '
   return;
   end;'' language plpgsql; 
   ';
  -- end building the rule definition code

  -- create the new function
  execute function_text;

  rule_text := 'create rule ' || v_table_name || '_r as on insert to ' ||
               v_table_name || 'i do instead SELECT ' || v_table_name || '_f(new); ' ;
  --================== done building rule code =======================

  -- drop the old rule
  if rule_exists(v_table_name || '_r', v_table_name || 'i') then 
     execute 'drop rule ' || v_table_name || '_r ' || 'on ' || v_table_name || 'i';
  end if;

  -- create the new rule for inserts on the content type
  execute rule_text;

  return null; 

END;
$$;


ALTER FUNCTION public.content_type__refresh_trigger(refresh_trigger__content_type character varying) OWNER TO evex;

--
-- Name: content_type__refresh_view(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__refresh_view(refresh_view__content_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  cols                                 varchar default ''; 
  tabs                                 varchar default ''; 
  joins                                varchar default '';
  v_table_name                         varchar;
  join_rec                             record;
BEGIN

  for join_rec in select ot2.table_name, ot2.id_column, tree_level(ot2.tree_sortkey) as level
                  from acs_object_types ot1, acs_object_types ot2
                  where ot2.object_type <> 'acs_object'                       
                    and ot2.object_type <> 'content_revision'
                    and lower(ot2.table_name) <> 'acs_objects'     
                    and lower(ot2.table_name) <> 'cr_revisions'
                    and ot1.object_type = refresh_view__content_type
                    and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
                  order by ot2.tree_sortkey desc
  LOOP
    if join_rec.table_name is not null then
        cols := cols || ', ' || join_rec.table_name || '.*';
        tabs := tabs || ', ' || join_rec.table_name;
        joins := joins || ' and acs_objects.object_id = ' || 
                 join_rec.table_name || '.' || join_rec.id_column;
    end if;
  end loop;

  -- Since we allow null table name use object type if table name is null so
  -- we still can have a view.
  select coalesce(table_name,object_type) into v_table_name from acs_object_types
    where object_type = refresh_view__content_type;

  if length(v_table_name) > 57 then
      raise exception 'Table name cannot be longer than 57 characters, because that causes conflicting rules when we create the views.';
  end if;

  -- create the input view (includes content columns)

  if table_exists(v_table_name || 'i') then
     execute 'drop view ' || v_table_name || 'i' || ' CASCADE';
  end if;

  -- FIXME:  need to look at content_revision__get_content.  Since the CR
  -- can store data in a lob, a text field or in an external file, getting
  -- the data attribute for this view will be problematic.

  execute 'create view ' || v_table_name ||
    'i as select  acs_objects.object_id,
 acs_objects.object_type,
 acs_objects.title as object_title,
 acs_objects.package_id as object_package_id,
 acs_objects.context_id,
 acs_objects.security_inherit_p,
 acs_objects.creation_user,
 acs_objects.creation_date,
 acs_objects.creation_ip,
 acs_objects.last_modified,
 acs_objects.modifying_user,
 acs_objects.modifying_ip,
 cr.revision_id, cr.title, cr.item_id,
    content_revision__get_content(cr.revision_id) as data, 
    cr_text.text_data as text,
    cr.description, cr.publish_date, cr.mime_type, cr.nls_language' || 
    cols || 
    ' from acs_objects, cr_revisions cr, cr_text' || tabs || ' where 
    acs_objects.object_id = cr.revision_id ' || joins;

  -- create the output view (excludes content columns to enable SELECT *)

  if table_exists(v_table_name || 'x') then
     execute 'drop view ' || v_table_name || 'x cascade';
  end if;

  execute 'create view ' || v_table_name ||
    'x as select  acs_objects.object_id,
 acs_objects.object_type,
 acs_objects.title as object_title,
 acs_objects.package_id as object_package_id,
 acs_objects.context_id,
 acs_objects.security_inherit_p,
 acs_objects.creation_user,
 acs_objects.creation_date,
 acs_objects.creation_ip,
 acs_objects.last_modified,
 acs_objects.modifying_user,
 acs_objects.modifying_ip,
 cr.revision_id, cr.title, cr.item_id,
    cr.description, cr.publish_date, cr.mime_type, cr.nls_language,
    i.name, i.parent_id' || 
    cols || 
    ' from acs_objects, cr_revisions cr, cr_items i, cr_text' || tabs || 
    ' where acs_objects.object_id = cr.revision_id 
      and cr.item_id = i.item_id' || joins;

  PERFORM content_type__refresh_trigger(refresh_view__content_type);

-- exception
--   when others then
--     dbms_output.put_line('Error creating attribute view or trigger for'
--  || content_type);

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__refresh_view(refresh_view__content_type character varying) OWNER TO evex;

--
-- Name: content_type__register_child_type(character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__register_child_type(register_child_type__parent_type character varying, register_child_type__child_type character varying, register_child_type__relation_tag character varying, register_child_type__min_n integer, register_child_type__max_n integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_exists                           integer;
BEGIN

  select count(*) into v_exists 
    from cr_type_children
    where parent_type = register_child_type__parent_type
    and child_type = register_child_type__child_type
    and relation_tag = register_child_type__relation_tag;

  if v_exists = 0 then

    insert into cr_type_children (
      parent_type, child_type, relation_tag, min_n, max_n
    ) values (
      register_child_type__parent_type, register_child_type__child_type, 
      register_child_type__relation_tag, 
      register_child_type__min_n, 
      register_child_type__max_n
    );

  else

    update cr_type_children set
      min_n = register_child_type__min_n,
      max_n = register_child_type__max_n
    where 
      parent_type = register_child_type__parent_type
    and 
      child_type = register_child_type__child_type
    and
      relation_tag = register_child_type__relation_tag;

  end if;
      
  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__register_child_type(register_child_type__parent_type character varying, register_child_type__child_type character varying, register_child_type__relation_tag character varying, register_child_type__min_n integer, register_child_type__max_n integer) OWNER TO evex;

--
-- Name: content_type__register_mime_type(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__register_mime_type(register_mime_type__content_type character varying, register_mime_type__mime_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_valid_registration                       integer;       
BEGIN

  -- check if this type is already registered  
  select
    count(*) into v_valid_registration
  from 
    cr_mime_types
  where 
    not exists ( select 1
                 from
                   cr_content_mime_type_map
                 where
                   mime_type = register_mime_type__mime_type
                 and
                   content_type = register_mime_type__content_type )
  and
    mime_type = register_mime_type__mime_type;

  if v_valid_registration = 1 then    
    insert into cr_content_mime_type_map (
      content_type, mime_type
    ) values (
      register_mime_type__content_type, register_mime_type__mime_type
    );
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__register_mime_type(register_mime_type__content_type character varying, register_mime_type__mime_type character varying) OWNER TO evex;

--
-- Name: content_type__register_relation_type(character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__register_relation_type(register_relation_type__content_type character varying, register_relation_type__target_type character varying, register_relation_type__relation_tag character varying, register_relation_type__min_n integer, register_relation_type__max_n integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_exists                              integer;       
BEGIN

  -- check if the relation type exists
  select 
    count(*) into v_exists 
  from 
    cr_type_relations
  where 
    content_type = register_relation_type__content_type
  and
    target_type = register_relation_type__target_type
  and 
    relation_tag = register_relation_type__relation_tag;

  -- if the relation type does not exist, insert a row into cr_type_relations
  if v_exists = 0 then
    insert into cr_type_relations (
      content_type, target_type, relation_tag, min_n, max_n
    ) values (
      register_relation_type__content_type, 
      register_relation_type__target_type, 
      register_relation_type__relation_tag, 
      register_relation_type__min_n, register_relation_type__max_n
    );

  -- otherwise, update the row in cr_type_relations
  else
    update cr_type_relations set
      min_n = register_relation_type__min_n,
      max_n = register_relation_type__max_n
    where 
      content_type = register_relation_type__content_type
    and 
      target_type = register_relation_type__target_type
    and
      relation_tag = register_relation_type__relation_tag;
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__register_relation_type(register_relation_type__content_type character varying, register_relation_type__target_type character varying, register_relation_type__relation_tag character varying, register_relation_type__min_n integer, register_relation_type__max_n integer) OWNER TO evex;

--
-- Name: content_type__register_template(character varying, integer, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__register_template(register_template__content_type character varying, register_template__template_id integer, register_template__use_context character varying, register_template__is_default boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_template_registered                     boolean;       
BEGIN
  select 
    count(*) > 0 into v_template_registered
  from
    cr_type_template_map
  where
    content_type = register_template__content_type
  and
    use_context =  register_template__use_context
  and
    template_id =  register_template__template_id;

  -- register the template
  if NOT v_template_registered then
    insert into cr_type_template_map (
      template_id, content_type, use_context, is_default
    ) values (
      register_template__template_id, register_template__content_type, 
      register_template__use_context, register_template__is_default
    );

  -- update the registration status of the template
  else

    -- unset the default template before setting this one as the default
    if register_template__is_default then
      update cr_type_template_map
        set is_default = 'f'
        where content_type = register_template__content_type
        and use_context = register_template__use_context;
    end if;

    update cr_type_template_map
      set is_default =    register_template__is_default
      where template_id = register_template__template_id
      and content_type =  register_template__content_type
      and use_context =   register_template__use_context;
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__register_template(register_template__content_type character varying, register_template__template_id integer, register_template__use_context character varying, register_template__is_default boolean) OWNER TO evex;

--
-- Name: content_type__rotate_template(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__rotate_template(rotate_template__template_id integer, rotate_template__v_content_type character varying, rotate_template__use_context character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_template_id                           cr_templates.template_id%TYPE;
  v_items_val                             record;
BEGIN

  -- get the default template
  select
    template_id into v_template_id
  from
    cr_type_template_map
  where
    content_type = rotate_template__v_content_type
  and
    use_context = rotate_template__use_context
  and
    is_default = 't';

  if v_template_id is not null then

    -- register an item-template to all items without an item-template
    for v_items_val in select
                         item_id
                       from
                         cr_items i, cr_type_template_map m
                       where
                         i.content_type = rotate_template__v_content_type
                       and
                         m.use_context = rotate_template__use_context
                       and
                         i.content_type = m.content_type
                       and
                         not exists ( select 1
                                        from
                                          cr_item_template_map
                                        where
                                          item_id = i.item_id
                                        and
                                          use_context = rotate_template__use_context ) 
    LOOP
      PERFORM content_item__register_template ( 
         v_items_val.item_id, 
         v_template_id,
         rotate_template__use_context
      );
    end loop;
  end if;

  -- register the new template as the default template of the content type
  if v_template_id != rotate_template__template_id then
    PERFORM content_type__register_template(
        rotate_template__v_content_type,
        rotate_template__template_id,
        rotate_template__use_context,
        't'
    );
  end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__rotate_template(rotate_template__template_id integer, rotate_template__v_content_type character varying, rotate_template__use_context character varying) OWNER TO evex;

--
-- Name: content_type__set_default_template(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__set_default_template(set_default_template__content_type character varying, set_default_template__template_id integer, set_default_template__use_context character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
                                        
BEGIN

  update cr_type_template_map
    set is_default = 't'
    where template_id = set_default_template__template_id
    and content_type = set_default_template__content_type
    and use_context = set_default_template__use_context;

  -- make sure there is only one default template for
  --   any given content_type/use_context pair
  update cr_type_template_map
    set is_default = 'f'
    where template_id <> set_default_template__template_id
    and content_type = set_default_template__content_type
    and use_context = set_default_template__use_context
    and is_default = 't';

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__set_default_template(set_default_template__content_type character varying, set_default_template__template_id integer, set_default_template__use_context character varying) OWNER TO evex;

--
-- Name: content_type__trigger_insert_statement(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__trigger_insert_statement(trigger_insert_statement__content_type character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_table_name                             acs_object_types.table_name%TYPE;
  v_id_column                              acs_object_types.id_column%TYPE;
  cols                                     varchar default '';
  vals                                     varchar default '';
  attr_rec                                 record;
BEGIN
  if trigger_insert_statement__content_type is null then 
        return exception 'content_type__trigger_insert_statement called with null content_type';
  end if;

  select 
    table_name, id_column into v_table_name, v_id_column
  from 
    acs_object_types 
  where 
    object_type = trigger_insert_statement__content_type;

  for attr_rec in select
                    attribute_name
                  from
                    acs_attributes
                  where
                    object_type = trigger_insert_statement__content_type 
  LOOP
    cols := cols || ', ' || attr_rec.attribute_name;
    vals := vals || ', p_new.' || attr_rec.attribute_name;
  end LOOP;

  return 'insert into ' || v_table_name || 
    ' ( ' || v_id_column || cols || ' ) values (v_revision_id' ||
    vals || ')';
  
END;
$$;


ALTER FUNCTION public.content_type__trigger_insert_statement(trigger_insert_statement__content_type character varying) OWNER TO evex;

--
-- Name: content_type__unregister_child_type(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__unregister_child_type(unregister_child_type__parent_type character varying, unregister_child_type__child_type character varying, unregister_child_type__relation_tag character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  delete from 
    cr_type_children
  where 
    parent_type = unregister_child_type__parent_type
  and 
    child_type = unregister_child_type__child_type
  and
    relation_tag = unregister_child_type__relation_tag;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__unregister_child_type(unregister_child_type__parent_type character varying, unregister_child_type__child_type character varying, unregister_child_type__relation_tag character varying) OWNER TO evex;

--
-- Name: content_type__unregister_mime_type(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__unregister_mime_type(unregister_mime_type__content_type character varying, unregister_mime_type__mime_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  delete from cr_content_mime_type_map
    where content_type = unregister_mime_type__content_type
    and mime_type = unregister_mime_type__mime_type;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__unregister_mime_type(unregister_mime_type__content_type character varying, unregister_mime_type__mime_type character varying) OWNER TO evex;

--
-- Name: content_type__unregister_relation_type(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__unregister_relation_type(unregister_relation_type__content_type character varying, unregister_relation_type__target_type character varying, unregister_relation_type__relation_tag character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
                                        
BEGIN

  delete from 
    cr_type_relations
  where 
    content_type = unregister_relation_type__content_type
  and 
    target_type = unregister_relation_type__target_type
  and
    relation_tag = unregister_relation_type__relation_tag;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__unregister_relation_type(unregister_relation_type__content_type character varying, unregister_relation_type__target_type character varying, unregister_relation_type__relation_tag character varying) OWNER TO evex;

--
-- Name: content_type__unregister_template(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.content_type__unregister_template(unregister_template__content_type character varying, unregister_template__template_id integer, unregister_template__use_context character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  if unregister_template__use_context is null and 
     unregister_template__content_type is null then

    delete from cr_type_template_map
      where template_id = unregister_template__template_id;

  else if unregister_template__use_context is null then

    delete from cr_type_template_map
      where template_id = unregister_template__template_id
      and content_type = unregister_template__content_type;

  else if unregister_template__content_type is null then

    delete from cr_type_template_map
      where template_id = unregister_template__template_id
      and use_context = unregister_template__use_context;

  else

    delete from cr_type_template_map
      where template_id = unregister_template__template_id
      and content_type = unregister_template__content_type
      and use_context = unregister_template__use_context;

  end if; end if; end if;

  return 0; 
END;
$$;


ALTER FUNCTION public.content_type__unregister_template(unregister_template__content_type character varying, unregister_template__template_id integer, unregister_template__use_context character varying) OWNER TO evex;

--
-- Name: cr_cleanup_cr_files_del_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_cleanup_cr_files_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        
BEGIN
        insert into cr_files_to_delete
        select r.content as path, i.storage_area_key
          from cr_items i, cr_revisions r
         where i.item_id = r.item_id
           and r.revision_id = old.revision_id
           and i.storage_type = 'file'
           and r.content is not null;

        return old;
END;
$$;


ALTER FUNCTION public.cr_cleanup_cr_files_del_tr() OWNER TO evex;

--
-- Name: cr_items_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_items_get_tree_sortkey(p_item_id integer) RETURNS bit varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
  return tree_sortkey from cr_items where item_id = p_item_id;
END;
$$;


ALTER FUNCTION public.cr_items_get_tree_sortkey(p_item_id integer) OWNER TO evex;

--
-- Name: cr_items_publish_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_items_publish_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  if new.live_revision <> old.live_revision or
     new.publish_status <> old.publish_status
  then 

    insert into cr_item_publish_audit (
      item_id, old_revision, new_revision, old_status, new_status, publish_date
    ) values (
      new.item_id, old.live_revision, new.live_revision, 
      old.publish_status, new.publish_status,
      now()
    );

  end if;

  return new;

END;
$$;


ALTER FUNCTION public.cr_items_publish_update_tr() OWNER TO evex;

--
-- Name: cr_items_tree_insert_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_items_tree_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_parent_sk      	varbit default null;
    v_max_child_sortkey varbit;
    v_parent_id      	integer default null;
BEGIN
    select item_id
    into   v_parent_id
    from   cr_items
    where  item_id = new.parent_id;

    if new.parent_id = 0 then
	
	new.tree_sortkey := int_to_tree_key(new.item_id+1000);

    elsif v_parent_id is null then 

	new.tree_sortkey := int_to_tree_key(new.parent_id+1000) || int_to_tree_key(new.item_id+1000);

    else

	SELECT tree_sortkey, tree_increment_key(max_child_sortkey)
	INTO v_parent_sk, v_max_child_sortkey
	FROM cr_items
	WHERE item_id = new.parent_id 
	FOR UPDATE;

	UPDATE cr_items
	SET max_child_sortkey = v_max_child_sortkey
	WHERE item_id = new.parent_id;

	new.tree_sortkey := v_parent_sk || v_max_child_sortkey;

    end if;

    return new;
END;
$$;


ALTER FUNCTION public.cr_items_tree_insert_tr() OWNER TO evex;

--
-- Name: cr_items_tree_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_items_tree_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_sk     	varbit default null;
        v_max_child_sortkey     varbit;
        v_parent_id            	integer default null;
        v_old_parent_length	integer;
BEGIN
        if new.item_id = old.item_id and 
           ((new.parent_id = old.parent_id) or
            (new.parent_id is null and old.parent_id is null)) then

           return new;

        end if;

        select item_id
    	into   v_parent_id
	from   cr_items
	where  item_id = new.parent_id;

	-- the tree sortkey is going to change so get the new one and update it and all its
	-- children to have the new prefix...
	v_old_parent_length := length(new.tree_sortkey) + 1;

        if new.parent_id = 0 then
            v_parent_sk := int_to_tree_key(new.item_id+1000);
	elsif v_parent_id is null then 
            v_parent_sk := int_to_tree_key(new.parent_id+1000) || int_to_tree_key(new.item_id+1000);
        else
	    SELECT tree_sortkey, tree_increment_key(max_child_sortkey)
	    INTO v_parent_sk, v_max_child_sortkey
	    FROM cr_items
	    WHERE item_id = new.parent_id 
	    FOR UPDATE;

	    UPDATE cr_items
	    SET max_child_sortkey = v_max_child_sortkey
	    WHERE item_id = new.parent_id;

	    v_parent_sk := v_parent_sk || v_max_child_sortkey;
        end if;

	UPDATE cr_items
	SET tree_sortkey = v_parent_sk || substring(tree_sortkey, v_old_parent_length)
	WHERE tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);

        return new;

END;
$$;


ALTER FUNCTION public.cr_items_tree_update_tr() OWNER TO evex;

--
-- Name: cr_items_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_items_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

  if new.parent_id <> old.parent_id then
    update acs_objects set context_id = new.parent_id
    where object_id = new.item_id;
  end if;

  return new;
END;
$$;


ALTER FUNCTION public.cr_items_update_tr() OWNER TO evex;

--
-- Name: cr_keywords_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_keywords_get_tree_sortkey(p_keyword_id integer) RETURNS bit varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
  return tree_sortkey from cr_keywords where keyword_id = p_keyword_id;
END;
$$;


ALTER FUNCTION public.cr_keywords_get_tree_sortkey(p_keyword_id integer) OWNER TO evex;

--
-- Name: cr_keywords_tree_insert_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_keywords_tree_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_sk      varbit default null;
        v_max_value      integer;
BEGIN
        if new.parent_id is null then 
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
              from cr_keywords 
             where parent_id is null;
        else 
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
              from cr_keywords 
             where parent_id = new.parent_id;

            select tree_sortkey into v_parent_sk 
              from cr_keywords 
             where keyword_id = new.parent_id;
        end if;

        new.tree_sortkey := tree_next_key(v_parent_sk, v_max_value);

        return new;

END;
$$;


ALTER FUNCTION public.cr_keywords_tree_insert_tr() OWNER TO evex;

--
-- Name: cr_keywords_tree_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_keywords_tree_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_sk     varbit default null;
        v_max_value     integer;
        p_id            integer;
        v_rec           record;
        clr_keys_p      boolean default 't';
BEGIN
        if new.keyword_id = old.keyword_id and 
           ((new.parent_id = old.parent_id) or
            (new.parent_id is null and old.parent_id is null)) 
        THEN

           return new;

        end if;

        for v_rec in select keyword_id
                       from cr_keywords 
                      where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey)
                   order by tree_sortkey
        LOOP
            if clr_keys_p then
               update cr_keywords set tree_sortkey = null
               where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);
               clr_keys_p := 'f';
            end if;
            
            select parent_id into p_id
              from cr_keywords 
             where keyword_id = v_rec.keyword_id;

            if p_id is null then 
                select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
                  from cr_keywords 
                 where parent_id is null;
            else 
                select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
                  from cr_keywords 
                 where parent_id = p_id;

                select tree_sortkey into v_parent_sk 
                  from cr_keywords 
                 where keyword_id = p_id;
            end if;

            update cr_keywords 
               set tree_sortkey = tree_next_key(v_parent_sk, v_max_value)
             where keyword_id = v_rec.keyword_id;

        end LOOP;

        return new;

END;
$$;


ALTER FUNCTION public.cr_keywords_tree_update_tr() OWNER TO evex;

--
-- Name: cr_keywords_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_keywords_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  if old.parent_id <> new.parent_id then
    update acs_objects set context_id = new.parent_id
      where object_id = new.keyword_id;
  end if;

  return new;
END;
$$;


ALTER FUNCTION public.cr_keywords_update_tr() OWNER TO evex;

--
-- Name: cr_revision_latest_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_revision_latest_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  update cr_items set latest_revision = new.revision_id
  where item_id = new.item_id;
  return new;
END;
$$;


ALTER FUNCTION public.cr_revision_latest_tr() OWNER TO evex;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: acs_objects; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_objects (
    object_id integer NOT NULL,
    object_type character varying(1000) NOT NULL,
    title character varying(1000) DEFAULT NULL::character varying,
    package_id integer,
    context_id integer,
    security_inherit_p boolean DEFAULT true NOT NULL,
    creation_user integer,
    creation_date timestamp with time zone DEFAULT now() NOT NULL,
    creation_ip character varying(50),
    last_modified timestamp with time zone DEFAULT now() NOT NULL,
    modifying_user integer,
    modifying_ip character varying(50)
);


ALTER TABLE public.acs_objects OWNER TO evex;

--
-- Name: TABLE acs_objects; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_objects IS '
The root table for the acs object heirarchy.  It all starts here folks.
';


--
-- Name: COLUMN acs_objects.title; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_objects.title IS '
 Title of the object if applicable.
 Please note that in mid-term this column will replace all
 titles or object_names of package specific tables.
';


--
-- Name: COLUMN acs_objects.package_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_objects.package_id IS '
 Which package instance this object belongs to.
 Please note that in mid-term this column will replace all
 package_ids of package specific tables.
';


--
-- Name: COLUMN acs_objects.context_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_objects.context_id IS '
 The context_id column points to an object that provides a context for
 this object. Often this will reflect an observed hierarchy in a site,
 for example a bboard message would probably list a bboard topic as
 it''s context, and a bboard topic might list a sub-site as it''s
 context. Whenever we ask a question of the form "can user X perform
 action Y on object Z", the acs security model will defer to an
 object''s context if there is no information about user X''s
 permission to perform action Y on object Z.
';


--
-- Name: COLUMN acs_objects.creation_user; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_objects.creation_user IS '
 Who created the object; may be null since objects can be created by
 automated processes
';


--
-- Name: COLUMN acs_objects.modifying_user; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_objects.modifying_user IS '
 Who last modified the object
';


--
-- Name: cr_revisions; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_revisions (
    revision_id integer NOT NULL,
    item_id integer NOT NULL,
    title character varying(1000),
    description text,
    publish_date timestamp with time zone,
    mime_type character varying(200) DEFAULT 'text/plain'::character varying,
    nls_language character varying(50),
    lob integer,
    content text,
    content_length integer
);


ALTER TABLE public.cr_revisions OWNER TO evex;

--
-- Name: TABLE cr_revisions; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_revisions IS '
  Each content item may be associated with any number of revisions.
  The item_id is used to associate revisions with an item.
';


--
-- Name: COLUMN cr_revisions.nls_language; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cr_revisions.nls_language IS '
  NLS_LANGUAGE is required in the same table as the content column
  for multi-lingual searching in Intermedia.
';


--
-- Name: cr_text; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_text (
    text_data text
);


ALTER TABLE public.cr_text OWNER TO evex;

--
-- Name: TABLE cr_text; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_text IS '
  A simple placeholder table for generating input views, so that a
  complete revision may be added with a single INSERT statement.
';


--
-- Name: cr_revisionsi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.cr_revisionsi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text
  WHERE (acs_objects.object_id = cr.revision_id);


ALTER TABLE public.cr_revisionsi OWNER TO evex;

--
-- Name: cr_revisions_f(public.cr_revisionsi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_revisions_f(p_new public.cr_revisionsi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                
   return;
   end;$$;


ALTER FUNCTION public.cr_revisions_f(p_new public.cr_revisionsi) OWNER TO evex;

--
-- Name: cr_scheduled_release_exec(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_scheduled_release_exec() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  exec__last_exec             timestamptz;
  exec__this_exec             timestamptz default current_timestamp;
  exec__items_released        integer default 0;
  exec__items_expired         integer default 0;
  exec__err_num               integer;  -- sqlcode
  exec__err_msg               varchar;  -- substr(sqlerrm, 1, 500);
  item_rec                    record;
BEGIN

    select last_exec into exec__last_exec from cr_scheduled_release_job;

    for item_rec in select 
                      p.item_id, live_revision
                    from
                      cr_release_periods p, cr_items i
                    where
                      start_when between exec__last_exec and now()
                    and
                      p.item_id = i.item_id 
    LOOP
      -- update publish status
      update cr_items
	set publish_status = 'live'
      where
	item_id = item_rec.item_id;
      exec__items_released := exec__items_released + 1;
    end loop;

    for item_rec in select 
                      p.item_id, live_revision
                    from
                      cr_release_periods p, cr_items i
                    where
                      end_when between exec__last_exec and now()
                    and
                      p.item_id = i.item_id
    LOOP
      -- update publish status
      update cr_items
	set publish_status = 'expired'
      where
	item_id = item_rec.item_id;

      exec__items_expired := exec__items_expired + 1;

    end loop;

  -- exception

  --   when others then
  --    err_num := SQLCODE;
  --    err_msg := substr(SQLERRM, 1, 500);
  -- end;

  -- keep a record of the update

  insert into cr_scheduled_release_log (
    items_released, items_expired, err_num, err_msg
  ) values (
    exec__items_released, exec__items_expired, exec__err_num, 
    exec__err_msg
  );

  -- Table was growing without bound (OpenACS DanW)
  delete from cr_scheduled_release_log
  where exec_date < now() - '4 week'::interval;

  -- Reset the last time of execution to start of processing
  update cr_scheduled_release_job set last_exec = exec__this_exec;

  return 0;
END;
$$;


ALTER FUNCTION public.cr_scheduled_release_exec() OWNER TO evex;

--
-- Name: cr_scheduled_release_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_scheduled_release_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

   raise EXCEPTION '-20000: Inserts are not allowed into cr_scheduled_release_job.';

  return new;
END;
$$;


ALTER FUNCTION public.cr_scheduled_release_tr() OWNER TO evex;

--
-- Name: cr_text_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_text_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

   raise EXCEPTION '-20000: Inserts are not allowed into cr_text.';

   return new;

END;
$$;


ALTER FUNCTION public.cr_text_tr() OWNER TO evex;

--
-- Name: cr_type_template_map_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.cr_type_template_map_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

  if new.is_default = 't' then
    update
      cr_type_template_map
    set
      is_default = 'f'
    where
      content_type = new.content_type
    and
      use_context = new.use_context
    and 
      template_id <> new.template_id
    and
      is_default = 't';
  end if;

  return new;

END;
$$;


ALTER FUNCTION public.cr_type_template_map_tr() OWNER TO evex;

--
-- Name: define_function_args(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.define_function_args(p_function character varying, p_arg_list character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

  v_arg_seq             integer default 1;
  v_arg_name            varchar;
  v_arg_default         varchar;
  v_elem                varchar;
  v_pos                 integer;
BEGIN
  delete from acs_function_args where function = upper(trim(p_function));

  v_elem = split(p_arg_list, ',', v_arg_seq);
  while v_elem is not null loop
    
    v_pos = instr(v_elem, ';', 1, 1);
    if v_pos > 0 then
      v_arg_name := substr(v_elem, 1, v_pos-1);
      v_arg_default := substr(v_elem, v_pos+1, length(v_elem) - v_pos);
    else
      v_arg_name := v_elem;
      v_arg_default := NULL;
    end if;

    insert into acs_function_args (function, arg_seq, arg_name, arg_default)
	   values (upper(trim(p_function)), v_arg_seq, upper(trim(v_arg_name)), v_arg_default);

    v_arg_seq := v_arg_seq + 1;
    v_elem = split(p_arg_list, ',', v_arg_seq);
  end loop;
    
  return 1;
END;
$$;


ALTER FUNCTION public.define_function_args(p_function character varying, p_arg_list character varying) OWNER TO evex;

--
-- Name: doc__get_package_header(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.doc__get_package_header(package_name character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN

        return '';

END;
$$;


ALTER FUNCTION public.doc__get_package_header(package_name character varying) OWNER TO evex;

--
-- Name: doc__get_proc_header(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.doc__get_proc_header(proc_name character varying, package_name character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN
        return definition 
          from acs_func_headers 
         where fname = (package_name || '__' || proc_name)::name 
         limit 1;

END;
$$;


ALTER FUNCTION public.doc__get_proc_header(proc_name character varying, package_name character varying) OWNER TO evex;

--
-- Name: dow_to_int(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.dow_to_int(dow_to_int__weekday character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_dow			integer;
BEGIN
       -- Brute force (what can I say?).
       select (case trim(upper(dow_to_int__weekday))
	             when 'SUNDAY'    then 1
	             when 'SUN'       then 1
		     when 'MONDAY'    then 2
		     when 'MON'	then 2
		     when 'TUESDAY'	then 3
		     when 'TUES'	then 3
		     when 'TUE'	then 3
		     when 'WEDNESDAY' then 4
		     when 'WED'	then 4
		     when 'WEDS'	then 4
		     when 'THURSDAY'  then 5
		     when 'THURS'	then 5
		     when 'THUR'	then 5
		     when 'THU'	then 5
		     when 'FRIDAY'	then 6
		     when 'FRI'	then 6
		     when 'SATURDAY'	then 7
		     when 'SAT'	then 7
		     else -1
		end) into v_dow
       from dual;
	
       if v_dow < 0 
       then 
	   raise exception 'Day of the week unknown';
       end if;

       return v_dow;

END;
$$;


ALTER FUNCTION public.dow_to_int(dow_to_int__weekday character varying) OWNER TO evex;

--
-- Name: drop_package(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.drop_package(package_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_rec             record;
       v_drop_cmd        varchar;
       v_pkg_name        varchar;
BEGIN
        raise NOTICE 'DROP PACKAGE: %', package_name;
        v_pkg_name := package_name || '__' || '%';

        for v_rec in select proname 
                       from pg_proc 
                      where proname like v_pkg_name 
                   order by proname 
        LOOP
            raise NOTICE 'DROPPING FUNCTION: %', v_rec.proname;
            v_drop_cmd := get_func_drop_command (v_rec.proname::varchar);
            EXECUTE v_drop_cmd;
        end loop;

        if NOT FOUND then 
          raise NOTICE 'PACKAGE: % NOT FOUND', package_name;
        else
          raise NOTICE 'PACKAGE: %: DROPPED', package_name;
        end if;
        
        return null;

END;
$$;


ALTER FUNCTION public.drop_package(package_name character varying) OWNER TO evex;

--
-- Name: ec_admin_settings_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_admin_settings_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_admin_settings_audit (
        admin_setting_id, base_shipping_cost, default_shipping_per_item,
        weight_shipping_cost, add_exp_base_shipping_cost,
        add_exp_amount_per_item, add_exp_amount_by_weight,
        default_template,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.admin_setting_id, old.base_shipping_cost, 
	old.default_shipping_per_item,
        old.weight_shipping_cost, old.add_exp_base_shipping_cost,
        old.add_exp_amount_per_item, old.add_exp_amount_by_weight,
        old.default_template,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_admin_settings_audit_tr() OWNER TO evex;

--
-- Name: ec_cash_amount_to_refund(numeric, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_cash_amount_to_refund(numeric, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_amount			alias for $1;
	v_order_id			alias for $2;
        amount_paid                     numeric;
        items_amount_paid               numeric;
        order_amount_paid               numeric;
        amount_refunded                 numeric;
        curr_gc_amount                  numeric;
        max_cash_refundable             numeric;
        cash_to_refund                  numeric;
BEGIN
        -- the maximum amount of cash refundable is equal to
        -- the amount paid (in cash + certificates) for shipped items only (since
        --  money is not paid until an item actually ships)
        -- minus the amount refunded (in cash + certificates) (only occurs for shipped items)
        -- minus the current gift certificate amount applied to this order
        -- or 0 if the result is negative

        select sum(coalesce(price_charged,0)) + sum(coalesce(shipping_charged,0)) + sum(coalesce(price_tax_charged,0)) + sum(coalesce(shipping_tax_charged,0)) into items_amount_paid from ec_items where order_id=v_order_id and shipment_id is not null and item_state <> 'void';

        select coalesce(shipping_charged,0) + coalesce(shipping_tax_charged,0) into order_amount_paid from ec_orders where order_id=v_order_id;

        amount_paid := items_amount_paid + order_amount_paid;
        amount_refunded := ec_total_refund(v_order_id);
        curr_gc_amount := ec_order_gift_cert_amount(v_order_id);
        
        max_cash_refundable := amount_paid - amount_refunded - curr_gc_amount;
        cash_to_refund := least(max_cash_refundable, v_amount);

        RETURN cash_to_refund;
END;$_$;


ALTER FUNCTION public.ec_cash_amount_to_refund(numeric, integer) OWNER TO evex;

--
-- Name: ec_cat_prod_map_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_cat_prod_map_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_category_product_map_audit (
        product_id, category_id,
        publisher_favorite_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.product_id, old.category_id,
        old.publisher_favorite_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address              
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_cat_prod_map_audit_tr() OWNER TO evex;

--
-- Name: ec_categories_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_categories_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_categories_audit (
        category_id, category_name, sort_key,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.category_id, old.category_name, old.sort_key,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_categories_audit_tr() OWNER TO evex;

--
-- Name: ec_cert_unshipped_one_order(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_cert_unshipped_one_order(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_gift_certificate_id	alias for $1;	
	v_order_id		alias for $2;
        total_shipment_cost     numeric;
        earlier_certs           numeric;
        total_tied_amount       numeric;
BEGIN
        select coalesce(sum(coalesce(ec_shipment_price(shipment_id),0) + coalesce(ec_shipment_shipping(shipment_id),0) + coalesce(ec_shipment_tax(shipment_id),0)),0) into total_shipment_cost
        from ec_shipments
        where order_id=v_order_id;

        earlier_certs := ec_earlier_certs_on_one_order(v_gift_certificate_id, v_order_id);

        IF total_shipment_cost <= earlier_certs THEN
                total_tied_amount := ec_one_gift_cert_on_one_order(v_gift_certificate_id, v_order_id);
        ELSE
	    IF total_shipment_cost > earlier_certs + ec_one_gift_cert_on_one_order(v_gift_certificate_id, v_order_id) THEN
                total_tied_amount := 0;
            ELSE
                total_tied_amount := ec_one_gift_cert_on_one_order(v_gift_certificate_id, v_order_id) - (total_shipment_cost - earlier_certs);
	    END IF;
        END IF;

        RETURN total_tied_amount;               
END;$_$;


ALTER FUNCTION public.ec_cert_unshipped_one_order(integer, integer) OWNER TO evex;

--
-- Name: ec_cs_interaction_inserts(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_cs_interaction_inserts() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
 IF new.interaction_date is null THEN 
    new.interaction_date := now();
 END IF;
 return new;
end;$$;


ALTER FUNCTION public.ec_cs_interaction_inserts() OWNER TO evex;

--
-- Name: ec_cs_issue_inserts(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_cs_issue_inserts() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
 IF new.open_date is null THEN 
    new.open_date := now();
 END IF;
 return new;
end;$$;


ALTER FUNCTION public.ec_cs_issue_inserts() OWNER TO evex;

--
-- Name: ec_custom_p_f_values_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_custom_p_f_values_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_custom_p_field_values_audit (
        product_id,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.product_id,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_custom_p_f_values_audit_tr() OWNER TO evex;

--
-- Name: ec_custom_prod_fields_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_custom_prod_fields_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_custom_product_fields_audit (
        field_identifier, field_name,
        default_value, column_type,
        creation_date, active_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.field_identifier, old.field_name,
        old.default_value, old.column_type,
        old.creation_date, old.active_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address              
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_custom_prod_fields_audit_tr() OWNER TO evex;

--
-- Name: ec_earlier_certs_on_one_order(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_earlier_certs_on_one_order(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_gift_certificate_id	alias for $1;
	v_order_id		alias for $2;
        bal_amount_used         numeric;
BEGIN
        select coalesce(sum(u.amount_used),0)-coalesce(sum(u.amount_reinstated),0) into bal_amount_used
        from ec_gift_certificate_usage u, ec_gift_certificates g, ec_gift_certificates g2
        where u.gift_certificate_id=g.gift_certificate_id
        and g2.gift_certificate_id=v_gift_certificate_id
        and u.order_id=v_order_id
        and (g.expires < g2.expires or (g.expires = g2.expires and g.gift_certificate_id < g2.gift_certificate_id));

        return bal_amount_used;
END;$_$;


ALTER FUNCTION public.ec_earlier_certs_on_one_order(integer, integer) OWNER TO evex;

--
-- Name: ec_email_templates_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_email_templates_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_email_templates_audit (
        email_template_id, title,
        subject, message,
        variables, when_sent,
        issue_type_list,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.email_template_id, old.title,
        old.subject, old.message,
        old.variables, old.when_sent,
        old.issue_type_list,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_email_templates_audit_tr() OWNER TO evex;

--
-- Name: ec_gift_cert_unshipped_amount(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_gift_cert_unshipped_amount(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_gift_certificate_id		alias for $1;
        tied_but_unshipped_amount       numeric;
BEGIN
        select coalesce(sum(ec_cert_unshipped_one_order(v_gift_certificate_id,order_id)),0) into tied_but_unshipped_amount
        from ec_orders
        where order_id in (select distinct order_id from ec_gift_certificate_usage where gift_certificate_id=v_gift_certificate_id);

        return tied_but_unshipped_amount;
END;$_$;


ALTER FUNCTION public.ec_gift_cert_unshipped_amount(integer) OWNER TO evex;

--
-- Name: ec_gift_certificate_balance(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_gift_certificate_balance(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_user_id alias for $1;
	original_amount                 numeric;
	total_amount_used               numeric;
        -- these only look at unexpired gift certificates 
	-- where amount_remaining_p is t,
        -- hence the word subset in their names
BEGIN
        SELECT coalesce(sum(amount),0)
	into original_amount
        FROM ec_gift_certificates_approved
        WHERE user_id=v_user_id
        AND amount_remaining_p='t'
        AND expires > now();

        SELECT coalesce(sum(u.amount_used),0) - 
    	    coalesce(sum(u.amount_reinstated),0)
	into total_amount_used
        FROM ec_gift_certificates_approved c, ec_gift_certificate_usage u
        WHERE c.gift_certificate_id=u.gift_certificate_id
        AND c.user_id=v_user_id
        AND c.amount_remaining_p='t'
        AND c.expires > now();

        RETURN original_amount - total_amount_used;
END;$_$;


ALTER FUNCTION public.ec_gift_certificate_balance(integer) OWNER TO evex;

--
-- Name: ec_gift_certificates_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_gift_certificates_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_gift_certificates_audit (
        gift_certificate_id, amount,
        issue_date, authorized_date, issued_by, purchased_by, expires,
        user_id, claim_check, certificate_message,
        certificate_to, certificate_from,
        recipient_email, voided_date, voided_by, reason_for_void,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.gift_certificate_id, old.amount,
        old.issue_date, old.authorized_date, old.issued_by, old.purchased_by, old.expires,
        old.user_id, old.claim_check, old.certificate_message,
        old.certificate_to, old.certificate_from,
        old.recipient_email, old.voided_date, old.voided_by, old.reason_for_void,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_gift_certificates_audit_tr() OWNER TO evex;

--
-- Name: ec_offers_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_offers_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_offers_audit (
        offer_id,
        product_id, retailer_location_id,
        store_sku, retailer_premiums,
        price, shipping,
        shipping_unavailable_p, stock_status,
        special_offer_p, special_offer_html,
        offer_begins, offer_ends,
        deleted_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.offer_id,
        old.product_id, old.retailer_location_id,
        old.store_sku, old.retailer_premiums,
        old.price, old.shipping,
        old.shipping_unavailable_p, old.stock_status,
        old.special_offer_p, old.special_offer_html,
        old.offer_begins, old.offer_ends,
        old.deleted_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_offers_audit_tr() OWNER TO evex;

--
-- Name: ec_one_gift_cert_on_one_order(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_one_gift_cert_on_one_order(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_gift_certificate_id	alias for $1;
	v_order_id		alias for $2;
        bal_amount_used         numeric;
BEGIN
        select coalesce(sum(amount_used),0)-coalesce(sum(amount_reinstated),0) into bal_amount_used
        from ec_gift_certificate_usage
        where order_id=v_order_id
        and gift_certificate_id=v_gift_certificate_id;

        RETURN bal_amount_used;

END;$_$;


ALTER FUNCTION public.ec_one_gift_cert_on_one_order(integer, integer) OWNER TO evex;

--
-- Name: ec_order_amount_owed(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_order_amount_owed(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_order_id			alias for $1;
        pre_gc_amount_owed              numeric;
        gc_amount                       numeric;
BEGIN
        pre_gc_amount_owed := ec_total_price(v_order_id) + ec_total_shipping(v_order_id) + ec_total_tax(v_order_id);
        gc_amount := ec_order_gift_cert_amount(v_order_id);

        RETURN pre_gc_amount_owed - gc_amount;
END;$_$;


ALTER FUNCTION public.ec_order_amount_owed(integer) OWNER TO evex;

--
-- Name: ec_order_cost(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_order_cost(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_order_id	alias for $1;
        v_price         numeric;
        v_shipping      numeric;
        v_tax           numeric;
        v_certificate   numeric;
BEGIN
        v_price := ec_total_price(v_order_id);
        v_shipping := ec_total_shipping(v_order_id);
        v_tax := ec_total_tax(v_order_id);
        v_certificate := ec_order_gift_cert_amount(v_order_id);

        return v_price + v_shipping + v_tax - v_certificate;
END;$_$;


ALTER FUNCTION public.ec_order_cost(integer) OWNER TO evex;

--
-- Name: ec_order_gift_cert_amount(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_order_gift_cert_amount(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_order_id		alias for $1;
        gift_cert_amount        numeric;
BEGIN
        select into gift_cert_amount
        coalesce(sum(amount_used),0) - coalesce(sum(amount_reinstated),0)
        FROM ec_gift_certificate_usage
        WHERE order_id=v_order_id;

        return gift_cert_amount;
END;$_$;


ALTER FUNCTION public.ec_order_gift_cert_amount(integer) OWNER TO evex;

--
-- Name: ec_order_state_after_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_order_state_after_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        -- v_order_id              integer;
        n_items                 integer;
        n_shipped_items         integer;
        n_received_back_items   integer;
        n_void_items            integer;
        n_nonvoid_items         integer;

begin
	select count(*) into n_items from ec_items where order_id=NEW.order_id;
        select count(*) into n_shipped_items from ec_items 
	    where order_id=NEW.order_id
	    and item_state='shipped' or item_state='arrived';
        select count(*) into n_received_back_items
	    from ec_items where order_id=NEW.order_id
	    and item_state='received_back';
        select count(*) into n_void_items from ec_items 
	    where order_id=NEW.order_id and item_state='void';

        IF n_items = n_void_items THEN
            update ec_orders set order_state='void', voided_date=now()
		where order_id=NEW.order_id;
        ELSE
            n_nonvoid_items := n_items - n_void_items;
            IF n_nonvoid_items = n_received_back_items THEN
                update ec_orders set order_state='returned' 
		    where order_id=NEW.order_id;
            ELSE 
		IF n_nonvoid_items = n_received_back_items + n_shipped_items THEN
		    update ec_orders set order_state='fulfilled' 
			where order_id=NEW.order_id;
            	ELSE
		    IF n_shipped_items >= 1 or n_received_back_items >=1 THEN
			update ec_orders set order_state='partially_fulfilled'
			    where order_id=NEW.order_id;
            	    END IF;
        	END IF;
	    END IF;
	END IF;
	return new;
end;$$;


ALTER FUNCTION public.ec_order_state_after_tr() OWNER TO evex;

--
-- Name: ec_picklist_items_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_picklist_items_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_picklist_items_audit (
        picklist_item_id, picklist_item,
        picklist_name, sort_key,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.picklist_item_id, old.picklist_item,
        old.picklist_name, old.sort_key,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_picklist_items_audit_tr() OWNER TO evex;

--
-- Name: ec_product__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_product__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    delete__product_id		alias for $1;
begin
    delete from ec_products
    where product_id = delete__product_id;

    PERFORM acs_object__delete(delete__product_id);
    return 0;
end;$_$;


ALTER FUNCTION public.ec_product__delete(integer) OWNER TO evex;

--
-- Name: ec_product__new(integer, integer, integer, character varying, numeric, character varying, character varying, character varying, character varying, boolean, character, character varying, timestamp with time zone, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_product__new(integer, integer, integer, character varying, numeric, character varying, character varying, character varying, character varying, boolean, character, character varying, timestamp with time zone, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__product_id		alias for $1;  -- default null
  new__creation_user		alias for $2;  -- default null
  new__context_id		alias for $3;  -- default null (package_id)
  new__product_name  		alias for $4; 
  new__price			alias for $5;  -- default null
  new__sku			alias for $6;  -- default null
  new__one_line_description	alias for $7;  -- default null
  new__detailed_description	alias for $8;  -- default null
  new__search_keywords		alias for $9;  -- default null
  new__present_p		alias for $10; -- default t
  new__stock_status		alias for $11; -- default o
  new__dirname			alias for $12; -- default null
  new__available_date		alias for $13; -- default sysdate
  new__color_list		alias for $14; -- default null
  new__size_list		alias for $15; -- default null
  new__creation_ip		alias for $16; -- default null
  -- new__style_list		alias for $17 -- default null
  -- new__email_on_purchase_list	alias for $18 -- default null
  -- new__url			alias for $19 -- default null
  -- new__no_shipping_avail_p	alias for $20 -- default f
  -- new__shipping			alias for $21 -- default null
  -- new__shipping_additional	alias for $22 -- default null
  -- new__weight			alias for $23 -- default null
  -- new__active_p			alias for $24 -- default t
  -- new__template_id		alias for $25 -- default null
  -- new__announcements		alias for $26 -- default null
  -- new__announcements_expire	alias for $27 -- default null
  v_object_id			integer;
 begin
     v_object_id := acs_object__new (
	new__product_id,
	'ec_product',
	now(),
        new__creation_user,
	new__creation_ip,
	new__context_id
     );
     insert into ec_products 
     (product_id, creation_date, last_modified, last_modifying_user, modified_ip_address, product_name, price, sku, one_line_description, detailed_description, search_keywords, present_p, stock_status, dirname, available_date, color_list, size_list)
     values 
     (v_object_id, now(), now(), new__creation_user, new__creation_ip, new__product_name, new__price, new__sku, new__one_line_description, new__detailed_description, new__search_keywords, new__present_p, new__stock_status, new__dirname, new__available_date, new__color_list, new__size_list);

     return v_object_id;

end;$_$;


ALTER FUNCTION public.ec_product__new(integer, integer, integer, character varying, numeric, character varying, character varying, character varying, character varying, boolean, character, character varying, timestamp with time zone, character varying, character varying, character varying) OWNER TO evex;

--
-- Name: ec_product_comments_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_product_comments_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_product_comments_audit (
        comment_id, product_id, user_id,
        user_comment, one_line_summary, rating, approved_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.comment_id, old.product_id, old.user_id,
        old.user_comment, old.one_line_summary, old.rating, old.approved_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_product_comments_audit_tr() OWNER TO evex;

--
-- Name: ec_product_links_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_product_links_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_product_links_audit (
        product_a, product_b,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.product_a, old.product_b,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_product_links_audit_tr() OWNER TO evex;

--
-- Name: ec_product_recommend_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_product_recommend_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_product_recommend_audit (
        recommendation_id, product_id,
        user_class_id, recommendation_text,
        active_p, category_id,
        subcategory_id, subsubcategory_id,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.recommendation_id, old.product_id,
        old.user_class_id, old.recommendation_text,
        old.active_p, old.category_id,
        old.subcategory_id, old.subsubcategory_id,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_product_recommend_audit_tr() OWNER TO evex;

--
-- Name: ec_product_reviews_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_product_reviews_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_product_reviews_audit (
        review_id, product_id,
        author_name, publication, review_date,
        review,
        display_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.review_id, old.product_id,
        old.author_name, old.publication, old.review_date,
        old.review, 
        old.display_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_product_reviews_audit_tr() OWNER TO evex;

--
-- Name: ec_product_series_map_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_product_series_map_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_product_series_map_audit (
        series_id, component_id,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.series_id, old.component_id,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_product_series_map_audit_tr() OWNER TO evex;

--
-- Name: ec_product_u_c_prices_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_product_u_c_prices_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_product_u_c_prices_audit (
        product_id, user_class_id,
        price,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.product_id, old.user_class_id,
        old.price,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_product_u_c_prices_audit_tr() OWNER TO evex;

--
-- Name: ec_products__dtrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_products__dtrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    perform search_observer__enqueue(old.product_id,'DELETE');
    return old;
end;$$;


ALTER FUNCTION public.ec_products__dtrg() OWNER TO evex;

--
-- Name: ec_products__itrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_products__itrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    perform search_observer__enqueue(new.product_id,'INSERT');
    return new;
end;$$;


ALTER FUNCTION public.ec_products__itrg() OWNER TO evex;

--
-- Name: ec_products__utrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_products__utrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    perform search_observer__enqueue(old.product_id,'UPDATE');
    return old;
end;$$;


ALTER FUNCTION public.ec_products__utrg() OWNER TO evex;

--
-- Name: ec_products_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_products_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_products_audit (
        product_id, product_name, creation_date,
        one_line_description, detailed_description,
        search_keywords, shipping,
        shipping_additional, weight,
        dirname, present_p,
        active_p, available_date,
        announcements, announcements_expire, 
        url, template_id,
        stock_status,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.product_id, old.product_name, old.creation_date,
        old.one_line_description, old.detailed_description,
        old.search_keywords, old.shipping,
        old.shipping_additional, old.weight,
        old.dirname, old.present_p,
        old.active_p, old.available_date,
        old.announcements, old.announcements_expire, 
        old.url, old.template_id,
        old.stock_status,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_products_audit_tr() OWNER TO evex;

--
-- Name: ec_reinst_gift_cert_on_order(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_reinst_gift_cert_on_order(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_order_id	alias for $1;
BEGIN
        insert into ec_gift_certificate_usage
        (gift_certificate_id, order_id, amount_reinstated, reinstated_date)
        select gift_certificate_id, v_order_id, coalesce(sum(amount_used),0)-coalesce(sum(amount_reinstated),0), now()
        from ec_gift_certificate_usage
        where order_id=v_order_id
        group by gift_certificate_id;

	return 0;
END;$_$;


ALTER FUNCTION public.ec_reinst_gift_cert_on_order(integer) OWNER TO evex;

--
-- Name: ec_retailer_locations_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_retailer_locations_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_retailer_locations_audit (
        retailer_location_id, retailer_id, location_name,
        primary_contact_name, secondary_contact_name,
        primary_contact_info, secondary_contact_info,
        line1, line2,
        city, usps_abbrev,
        zip_code, phone,
        fax, country_code,
        url, financing_policy,
        return_policy, price_guarantee_policy,
        delivery_policy, installation_policy,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.retailer_location_id,
        old.retailer_id, old.location_name,
        old.primary_contact_name, old.secondary_contact_name,
        old.primary_contact_info, old.secondary_contact_info,
        old.line1, old.line2,
        old.city, old.usps_abbrev,
        old.zip_code, old.phone,
        old.fax, old.country_code,
        old.url, old.financing_policy,
        old.return_policy, old.price_guarantee_policy,
        old.delivery_policy, old.installation_policy,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_retailer_locations_audit_tr() OWNER TO evex;

--
-- Name: ec_retailers_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_retailers_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_retailers_audit (
        retailer_id, retailer_name,
        primary_contact_name, secondary_contact_name,
        primary_contact_info, secondary_contact_info,
        line1, line2,
        city, usps_abbrev,
        zip_code, phone,
        fax, country_code,
        reach, url,
        nexus_states, financing_policy,
        return_policy, price_guarantee_policy,
        delivery_policy, installation_policy,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.retailer_id, old.retailer_name,
        old.primary_contact_name, old.secondary_contact_name,
        old.primary_contact_info, old.secondary_contact_info,
        old.line1, old.line2,
        old.city, old.usps_abbrev,
        old.zip_code, old.phone,
        old.fax, old.country_code,
        old.reach, old.url,
        old.nexus_states, old.financing_policy,
        old.return_policy, old.price_guarantee_policy,
        old.delivery_policy, old.installation_policy,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_retailers_audit_tr() OWNER TO evex;

--
-- Name: ec_sale_prices_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_sale_prices_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_sale_prices_audit (
        sale_price_id, product_id, sale_price,
        sale_begins, sale_ends, sale_name, offer_code,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.sale_price_id, old.product_id, old.sale_price,
        old.sale_begins, old.sale_ends, old.sale_name, old.offer_code,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_sale_prices_audit_tr() OWNER TO evex;

--
-- Name: ec_sales_tax_by_state_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_sales_tax_by_state_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_sales_tax_by_state_audit (
        usps_abbrev, tax_rate,
        shipping_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.usps_abbrev, old.tax_rate,
        old.shipping_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address              
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_sales_tax_by_state_audit_tr() OWNER TO evex;

--
-- Name: ec_shipment_address_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_shipment_address_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_address_id            ec_addresses.address_id%TYPE;
begin
        select into v_address_id shipping_address 
	from ec_orders where order_id=new.order_id;
        IF new.address_id is null THEN
                new.address_id := v_address_id;
        END IF;
	return new;
end;$$;


ALTER FUNCTION public.ec_shipment_address_update_tr() OWNER TO evex;

--
-- Name: ec_shipment_cost(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_shipment_cost(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_shipment_id	alias for $1;
        v_price         numeric;
        v_shipping      numeric;
        v_certificate   numeric;
        v_tax           numeric;
BEGIN
        v_price := ec_shipment_price(v_shipment_id);
        v_shipping := ec_shipment_shipping(v_shipment_id);
        v_tax := ec_shipment_tax(v_shipment_id);
        v_certificate := ec_shipment_gift_certificate(v_shipment_id);

        return v_price + v_shipping - v_certificate + v_tax;
END;$_$;


ALTER FUNCTION public.ec_shipment_cost(integer) OWNER TO evex;

--
-- Name: ec_shipment_gift_certificate(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_shipment_gift_certificate(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_shipment_id		alias for $1;
        v_order_id              ec_orders.order_id%TYPE;
        gift_cert_amount        numeric;
        past_ship_amount        numeric;
BEGIN
        SELECT into v_order_id order_id 
	    FROM ec_shipments WHERE shipment_id=v_shipment_id;
        gift_cert_amount := ec_order_gift_cert_amount(v_order_id);
        SELECT into past_ship_amount 
	    coalesce(sum(ec_shipment_price(shipment_id)) + sum(ec_shipment_shipping(shipment_id))+sum(ec_shipment_tax(shipment_id)),0) 
	    FROM ec_shipments WHERE order_id = v_order_id and shipment_id <> v_shipment_id;

        IF past_ship_amount > gift_cert_amount THEN
                return 0;
        ELSE
                return least(gift_cert_amount - past_ship_amount, coalesce(ec_shipment_price(v_shipment_id) + ec_shipment_shipping(v_shipment_id) + ec_shipment_tax(v_shipment_id),0));
        END IF;
END;$_$;


ALTER FUNCTION public.ec_shipment_gift_certificate(integer) OWNER TO evex;

--
-- Name: ec_shipment_price(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_shipment_price(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_shipment_id		alias for $1;
        shipment_price          numeric;
BEGIN
        SELECT into shipment_price coalesce(sum(price_charged),0) - coalesce(sum(price_refunded),0)
        FROM ec_items
        WHERE shipment_id=v_shipment_id
        and item_state <> 'void';

        RETURN shipment_price;
END;$_$;


ALTER FUNCTION public.ec_shipment_price(integer) OWNER TO evex;

--
-- Name: ec_shipment_shipping(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_shipment_shipping(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_shipment_id 		alias for $1;
        item_shipping           numeric;
        base_shipping           numeric;
        v_order_id              ec_orders.order_id%TYPE;
        min_shipment_id         ec_shipments.shipment_id%TYPE;
BEGIN
        SELECT into v_order_id order_id 
	    FROM ec_shipments where shipment_id=v_shipment_id;
        SELECT into min_shipment_id min(s.shipment_id) 
	    from ec_shipments s, ec_items i, ec_products p
	    where s.order_id = v_order_id
	    and s.shipment_id = i.shipment_id
	    and i.product_id = p.product_id
	    and p.no_shipping_avail_p = 'f';
        IF v_shipment_id=min_shipment_id THEN
                SELECT into base_shipping 
		    coalesce(shipping_charged,0) - coalesce(shipping_refunded,0)
		    FROM ec_orders where order_id=v_order_id;
        ELSE
                base_shipping := 0;
        END IF;
        SELECT into item_shipping 
	    coalesce(sum(shipping_charged),0) - coalesce(sum(shipping_refunded),0) 
	    FROM ec_items where shipment_id=v_shipment_id 
	    and item_state <> 'void';
        RETURN item_shipping + base_shipping;
END;$_$;


ALTER FUNCTION public.ec_shipment_shipping(integer) OWNER TO evex;

--
-- Name: ec_shipment_tax(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_shipment_tax(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_shipment_id 		alias for $1;
        item_price_tax          numeric;
        item_shipping_tax       numeric;
        base_shipping_tax       numeric;
        v_order_id              ec_orders.order_id%TYPE;
        min_shipment_id         ec_shipments.shipment_id%TYPE;
BEGIN
        SELECT into v_order_id order_id 
	    FROM ec_shipments where shipment_id=v_shipment_id;
        SELECT into min_shipment_id min(s.shipment_id) 
	    from ec_shipments s, ec_items i, ec_products p
	    where s.order_id = v_order_id
	    and s.shipment_id = i.shipment_id
	    and i.product_id = p.product_id
	    and p.no_shipping_avail_p = 'f';
        IF v_shipment_id=min_shipment_id THEN
                SELECT into base_shipping_tax 
		coalesce(shipping_tax_charged,0) - coalesce(shipping_tax_refunded,0) 
		FROM ec_orders where order_id=v_order_id;
        ELSE
                base_shipping_tax := 0;
        END IF;
        SELECT into item_price_tax 
	coalesce(sum(price_tax_charged),0) - coalesce(sum(price_tax_refunded),0) 
	FROM ec_items where shipment_id=v_shipment_id and item_state <> 'void';
        SELECT into item_shipping_tax 
	coalesce(sum(shipping_tax_charged),0) - coalesce(sum(shipping_tax_refunded),0) 
	FROM ec_items where shipment_id=v_shipment_id and item_state <> 'void';
        RETURN item_price_tax + item_shipping_tax + base_shipping_tax;
END;$_$;


ALTER FUNCTION public.ec_shipment_tax(integer) OWNER TO evex;

--
-- Name: ec_shipments_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_shipments_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_shipments_audit (
        shipment_id, order_id, address_id,
        shipment_date, 
        expected_arrival_date,
        carrier, tracking_number,
        actual_arrival_date, actual_arrival_detail,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.shipment_id, old.order_id, old.address_id,
        old.shipment_date,
        old.expected_arrival_date,
        old.carrier, old.tracking_number,
        old.actual_arrival_date, old.actual_arrival_detail,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_shipments_audit_tr() OWNER TO evex;

--
-- Name: ec_subcat_prod_map_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_subcat_prod_map_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_subcat_prod_map_audit (
        product_id, subcategory_id,
        publisher_favorite_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.product_id, old.subcategory_id,
        old.publisher_favorite_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address              
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_subcat_prod_map_audit_tr() OWNER TO evex;

--
-- Name: ec_subcategories_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_subcategories_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_subcategories_audit (
        subcategory_id, category_id,
        subcategory_name, sort_key,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.subcategory_id, old.category_id,
        old.subcategory_name, old.sort_key,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address              
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_subcategories_audit_tr() OWNER TO evex;

--
-- Name: ec_subsubcat_prod_map_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_subsubcat_prod_map_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_subsubcat_prod_map_audit (
        product_id, subsubcategory_id,
        publisher_favorite_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.product_id, old.subsubcategory_id,
        old.publisher_favorite_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address              
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_subsubcat_prod_map_audit_tr() OWNER TO evex;

--
-- Name: ec_subsubcategories_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_subsubcategories_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_subsubcategories_audit (
        subsubcategory_id, subcategory_id,
        subsubcategory_name, sort_key,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.subsubcategory_id, old.subcategory_id,
        old.subsubcategory_name, old.sort_key,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address              
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_subsubcategories_audit_tr() OWNER TO evex;

--
-- Name: ec_tax(numeric, numeric, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_tax(numeric, numeric, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_price			alias for $1;
	v_shipping		alias for $2;
	v_order_id		alias for $3;
        taxes                   ec_sales_tax_by_state%ROWTYPE;
        v_tax_exempt            ec_orders.tax_exempt_p%TYPE;
BEGIN
        SELECT tax_exempt_p INTO v_tax_exempt
        FROM ec_orders
        WHERE order_id = v_order_id;

        IF v_tax_exempt = 't' THEN
                return 0;
        END IF; 
        
        --SELECT t.* into taxes
        --FROM ec_orders o, ec_addresses a, ec_sales_tax_by_state t
        --WHERE o.shipping_address=a.address_id
        --AND a.usps_abbrev=t.usps_abbrev(+)
        --AND o.order_id=v_order_id;

        SELECT into taxes t.* 
	FROM ec_orders o
	    JOIN 
	ec_addresses a on (o.shipping_address=a.address_id)
	    LEFT JOIN
	ec_sales_tax_by_state t using (usps_abbrev)
	WHERE o.order_id=v_order_id;
	

        IF coalesce(taxes.shipping_p,'f') = 'f' THEN
                return coalesce(taxes.tax_rate,0) * v_price;
        ELSE
                return coalesce(taxes.tax_rate,0) * (v_price + v_shipping);
        END IF;
END;$_$;


ALTER FUNCTION public.ec_tax(numeric, numeric, integer) OWNER TO evex;

--
-- Name: ec_templates_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_templates_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_templates_audit (
        template_id, template_name,
        template,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.template_id,
        old.template_name, old.template,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_templates_audit_tr() OWNER TO evex;

--
-- Name: ec_total_price(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_total_price(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_order_id	alias for $1;
        price           numeric;
BEGIN
	select into price
	    coalesce(sum(price_charged),0) - coalesce(sum(price_refunded),0)
            FROM ec_items
            WHERE order_id=v_order_id
            and item_state <> 'void';

	return price;

END;$_$;


ALTER FUNCTION public.ec_total_price(integer) OWNER TO evex;

--
-- Name: ec_total_refund(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_total_refund(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_order_id 	alias for $1;
        v_order_refund  numeric;
        v_items_refund  numeric;
BEGIN
        select into v_order_refund 
	    coalesce(shipping_refunded,0) + coalesce(shipping_tax_refunded,0) 
	    from ec_orders where order_id=v_order_id;
        select into v_items_refund 
	    sum(coalesce(price_refunded,0)) + sum(coalesce(shipping_refunded,0)) + sum(coalesce(price_tax_refunded,0)) + sum(coalesce(shipping_tax_refunded,0)) from ec_items where order_id=v_order_id;
        return v_order_refund + v_items_refund;
END;$_$;


ALTER FUNCTION public.ec_total_refund(integer) OWNER TO evex;

--
-- Name: ec_total_shipping(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_total_shipping(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_order_id		alias for $1;
        order_shipping          numeric;
        item_shipping           numeric;
BEGIN
        select into order_shipping
        coalesce(shipping_charged,0) - coalesce(shipping_refunded,0)
        FROM ec_orders
        WHERE order_id=v_order_id;

        select into item_shipping
        coalesce(sum(shipping_charged),0) - coalesce(sum(shipping_refunded),0)
        FROM ec_items
        WHERE order_id=v_order_id
        and item_state <> 'void';

        return order_shipping + item_shipping;
END;$_$;


ALTER FUNCTION public.ec_total_shipping(integer) OWNER TO evex;

--
-- Name: ec_total_tax(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_total_tax(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_order_id			alias for $1;
        order_tax               	numeric;
        item_price_tax          	numeric;
        item_shipping_tax       	numeric;
BEGIN
        select into order_tax
        coalesce(shipping_tax_charged,0) - coalesce(shipping_tax_refunded,0)
        FROM ec_orders
        WHERE order_id=v_order_id;

        select into item_price_tax
        coalesce(sum(price_tax_charged),0) - coalesce(sum(price_tax_refunded),0)
        FROM ec_items
        WHERE order_id=v_order_id
        and item_state <> 'void';

        select into item_shipping_tax
        coalesce(sum(shipping_tax_charged),0) - coalesce(sum(shipping_tax_refunded),0)
        FROM ec_items
        WHERE order_id=v_order_id;

        return order_tax + item_price_tax + item_shipping_tax;
END;$_$;


ALTER FUNCTION public.ec_total_tax(integer) OWNER TO evex;

--
-- Name: ec_user_class_user_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_user_class_user_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_user_class_user_map_audit (
        user_id, user_class_id, user_class_approved_p,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.user_id, old.user_class_id, old.user_class_approved_p,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_user_class_user_audit_tr() OWNER TO evex;

--
-- Name: ec_user_classes_audit_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_user_classes_audit_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        insert into ec_user_classes_audit (
        user_class_id, user_class_name,
        last_modified,
        last_modifying_user, modified_ip_address
        ) values (
        old.user_class_id, old.user_class_name,
        old.last_modified,
        old.last_modifying_user, old.modified_ip_address      
        );
	return new;
end;$$;


ALTER FUNCTION public.ec_user_classes_audit_tr() OWNER TO evex;

--
-- Name: ec_user_identificate_date_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ec_user_identificate_date_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        IF new.date_added is null THEN
                new.date_added := now();
        END IF;
	return new;
end;$$;


ALTER FUNCTION public.ec_user_identificate_date_tr() OWNER TO evex;

--
-- Name: ee_booking__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_booking__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
     v_item_id	    alias for $1;
     v_num_children integer;
begin
    -- check if album is empty (no rm -r *)
    select count(*) into v_num_children
    from cr_items 
    where parent_id = v_item_id;

    if v_num_children > 0 then
           raise exception 'The specified album % still contains photos.  An album must be empty before it can be deleted.', v_item_id;
    end if;
    
    -- content_item.delete takes care of all revision
    -- on delete cascades take care of rest

    PERFORM content_item__delete (v_item_id);
    return 0;
end; $_$;


ALTER FUNCTION public.ee_booking__delete(integer) OWNER TO evex;

--
-- Name: ee_booking__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_booking__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;  -- cnpj
    new__item_id        alias for $2;
    new__parent_id	alias for $3; -- default null
    new__is_live	alias for $4; -- default f
    new__content_type   alias for $5; 
    new__category_id	alias for $6; -- item_type
    new__creation_user  alias for $7; -- default null
    new__creation_ip    alias for $8; -- default null
    new__title		alias for $9; -- default null
    new__description    alias for $10; -- default null
    new__revision_id    alias for $11; -- default null
    new__creation_date  alias for $12; -- default now()
    new__locale		alias for $13; -- default null
    new__context_id	alias for $14; -- default null
    new__publish_date   alias for $15; -- default now()
    new__nls_language   alias for $16; -- default null
    
    -- if we ever need another parameter space creation_date is the best bet
    -- new__creation_date	timestamp default now();
    new_relation_tag	varchar default null;
    new__mime_type	varchar default null;

    v_item_id       integer;
    v_revision_id   integer;

  begin
    v_item_id := content_item__new (
      new__name,
      new__parent_id,
      new__item_id,
      new__locale,
      new__creation_date,
      new__creation_user,	
      new__context_id,
      new__creation_ip,
      'content_item',
      new__content_type,
      null,
      null,
      null,
      null,
      null
    );

      -- not needed in the new call to content_item__new
      -- new__relation_tag,

    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      v_item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip,
      new__parent_id
    );

    INSERT into ee_services (booking_id) VALUES (v_revision_id);
   


    return v_item_id;
end; $_$;


ALTER FUNCTION public.ee_booking__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying) OWNER TO evex;

--
-- Name: ee_bookings; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_bookings (
    booking_id integer NOT NULL,
    product_id integer
);


ALTER TABLE public.ee_bookings OWNER TO evex;

--
-- Name: ee_bookingsi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_bookingsi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    ee_bookings.booking_id,
    ee_bookings.product_id
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.ee_bookings
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = ee_bookings.booking_id));


ALTER TABLE public.ee_bookingsi OWNER TO evex;

--
-- Name: ee_bookings_f(public.ee_bookingsi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_bookings_f(p_new public.ee_bookingsi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into ee_bookings ( booking_id, product_id ) values (v_revision_id, p_new.product_id);
    
   return;
   end;$$;


ALTER FUNCTION public.ee_bookings_f(p_new public.ee_bookingsi) OWNER TO evex;

--
-- Name: ee_item__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_item__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
     v_item_id	    alias for $1;
     v_num_children integer;
begin
    -- check if album is empty (no rm -r *)
    select count(*) into v_num_children
    from cr_items 
    where parent_id = v_item_id;

    if v_num_children > 0 then
           raise exception 'The specified album % still contains photos.  An album must be empty before it can be deleted.', v_item_id;
    end if;
    
    -- content_item.delete takes care of all revision
    -- on delete cascades take care of rest

    PERFORM content_item__delete (v_item_id);
    return 0;
end; $_$;


ALTER FUNCTION public.ee_item__delete(integer) OWNER TO evex;

--
-- Name: ee_item__delete_revision(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_item__delete_revision(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    revision_id		alias for $1;
  -- do not need to delete from the pa_albums
  -- the on delete cascade will take care of this
  -- during the content_revision.delete
begin
    PERFORM content_revision__delete (revision_id);
    return 0;    
end; $_$;


ALTER FUNCTION public.ee_item__delete_revision(integer) OWNER TO evex;

--
-- Name: ee_item__edit(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_item__edit(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;  -- cnpj
    new__item_id        alias for $2;
    new__parent_id	alias for $3; -- default null
    new__is_live	alias for $4; -- default f
    new__content_type   alias for $5; 
    new__category_id	alias for $6; -- item_type
    new__creation_user  alias for $7; -- default null
    new__creation_ip    alias for $8; -- default null
    new__title		alias for $9; -- default null
    new__description    alias for $10; -- default null
    new__revision_id    alias for $11; -- default null
    new__creation_date  alias for $12; -- default now()
    new__locale		alias for $13; -- default null
    new__context_id	alias for $14; -- default null
    new__publish_date   alias for $15; -- default now()
    new__nls_language   alias for $16; -- default null
    
    v_revision_id   integer;
    cur__revision_id integer;

    -- if we ever need another parameter space creation_date is the best bet
    -- new__creation_date	timestamp default now();
    new__mime_type	varchar default null;

  begin
    
    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      new__item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip,
      new__parent_id
    );

    IF new__content_type = 'ee_venue' THEN

       SELECT object_id INTO cur__revision_id FROM ee_venuesx WHERE item_id = new__item_id;

       UPDATE ee_venues SET venue_id = v_revision_id, cnpj = new__name, category_id = new__category_id WHERE venue_id = cur__revison_id;
    END IF;

    IF new__content_type = 'ee_service' THEN

       SELECT object_id INTO cur__revision_id FROM ee_servicesx WHERE item_id = new__item_id;

       UPDATE ee_services SET service_id = v_revision_id, cnpj = new__name, category_id = new__category_id WHERE service_id = cur__revision_id;
    END IF;



    IF new__is_live = 't' THEN
       PERFORM content_item__set_live_revision (v_revision_id);
    END IF;



    perform acs_object__update_last_modified(new__item_id, new__creation_user, new__creation_ip);



    return v_revision_id;

END; $_$;


ALTER FUNCTION public.ee_item__edit(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying) OWNER TO evex;

--
-- Name: ee_item__edit(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_item__edit(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;  -- cnpj
    new__item_id        alias for $2;
    new__parent_id	alias for $3; -- default null
    new__is_live	alias for $4; -- default f
    new__content_type   alias for $5; 
    new__category_id	alias for $6; -- item_type
    new__creation_user  alias for $7; -- default null
    new__creation_ip    alias for $8; -- default null
    new__title		alias for $9; -- default null
    new__description    alias for $10; -- default null
    new__revision_id    alias for $11; -- default null
    new__creation_date  alias for $12; -- default now()
    new__locale		alias for $13; -- default null
    new__context_id	alias for $14; -- default null
    new__publish_date   alias for $15; -- default now()
    new__nls_language   alias for $16; -- default null
    new__cnpj		alias for $17;

    v_revision_id   integer;
    cur__revision_id integer;

    -- if we ever need another parameter space creation_date is the best bet
    -- new__creation_date	timestamp default now();
    new__mime_type	varchar default null;

  begin
    
    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      new__item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip,
      new__parent_id
    );

    IF new__content_type = 'ee_venue' THEN

       SELECT object_id INTO cur__revision_id FROM ee_venuesx WHERE item_id = new__item_id;

       UPDATE ee_venues SET venue_id = v_revision_id, cnpj = new__cnpj, category_id = new__category_id, url = new__name WHERE venue_id = cur__revision_id;
    END IF;

    IF new__content_type = 'ee_service' THEN

       SELECT object_id INTO cur__revision_id FROM ee_servicesx WHERE item_id = new__item_id;

       UPDATE ee_services SET service_id = v_revision_id, cnpj = new__cnpj, category_id = new__category_id, url = new__name WHERE service_id = cur__revision_id;
    END IF;



    IF new__is_live = 't' THEN
       PERFORM content_item__set_live_revision (v_revision_id);
    END IF;



    perform acs_object__update_last_modified(new__item_id, new__creation_user, new__creation_ip);



    return v_revision_id;

END; $_$;


ALTER FUNCTION public.ee_item__edit(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying) OWNER TO evex;

--
-- Name: ee_item__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_item__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;  -- cnpj
    new__item_id        alias for $2;
    new__parent_id	alias for $3; -- default null
    new__is_live	alias for $4; -- default f
    new__content_type   alias for $5; 
    new__category_id	alias for $6; -- item_type
    new__creation_user  alias for $7; -- default null
    new__creation_ip    alias for $8; -- default null
    new__title		alias for $9; -- default null
    new__description    alias for $10; -- default null
    new__revision_id    alias for $11; -- default null
    new__creation_date  alias for $12; -- default now()
    new__locale		alias for $13; -- default null
    new__context_id	alias for $14; -- default null
    new__publish_date   alias for $15; -- default now()
    new__nls_language   alias for $16; -- default null
    
    -- if we ever need another parameter space creation_date is the best bet
    -- new__creation_date	timestamp default now();
    new_relation_tag	varchar default null;
    new__mime_type	varchar default null;

    v_item_id       integer;
    v_revision_id   integer;

  begin
    v_item_id := content_item__new (
      new__name,
      new__parent_id,
      new__item_id,
      new__locale,
      new__creation_date,
      new__creation_user,	
      new__context_id,
      new__creation_ip,
      'content_item',
      new__content_type,
      null,
      null,
      null,
      null,
      null
    );

      -- not needed in the new call to content_item__new
      -- new__relation_tag,

    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      v_item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip,
      new__parent_id
    );

    INSERT into ee_venues (ee_item_id, cnpj, category_id) VALUES (v_revision_id, new__name, new__category_id);



    if new__is_live = 't' then
       PERFORM content_item__set_live_revision (v_revision_id);
    end if;

    return v_item_id;
end; $_$;


ALTER FUNCTION public.ee_item__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying) OWNER TO evex;

--
-- Name: ee_item__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_item__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;  -- name
    new__item_id        alias for $2;
    new__parent_id	alias for $3; -- default null
    new__is_live	alias for $4; -- default f
    new__content_type   alias for $5; 
    new__category_id	alias for $6; -- item_type
    new__creation_user  alias for $7; -- default null
    new__creation_ip    alias for $8; -- default null
    new__title		alias for $9; -- default null
    new__description    alias for $10; -- default null
    new__revision_id    alias for $11; -- default null
    new__creation_date  alias for $12; -- default now()
    new__locale		alias for $13; -- default null
    new__context_id	alias for $14; -- default null
    new__publish_date   alias for $15; -- default now()
    new__nls_language   alias for $16; -- default null
    new__cnpj   	alias for $17; -- 
    
    -- if we ever need another parameter space creation_date is the best bet
    -- new__creation_date	timestamp default now();
    new_relation_tag	varchar default null;
    new__mime_type	varchar default null;

    v_item_id       integer;
    v_revision_id   integer;

  begin
    v_item_id := content_item__new (
      new__name || '-' || new__item_id,
      new__parent_id,
      new__item_id,
      new__locale,
      new__creation_date,
      new__creation_user,	
      new__context_id,
      new__creation_ip,
      'content_item',
      new__content_type,
      null,
      null,
      null,
      null,
      null
    );

      -- not needed in the new call to content_item__new
      -- new__relation_tag,

    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      v_item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip,
      new__parent_id
    );

    IF new__content_type = 'ee_venue' THEN 
       INSERT into ee_venues (venue_id, cnpj, category_id, url) VALUES (v_revision_id, new__cnpj, new__category_id, new__name);
    END IF;

    IF new__content_type = 'ee_service' THEN
       INSERT into ee_services (service_id, cnpj, category_id, url) VALUES (v_revision_id, new__cnpj, new__category_id, new__name);
    END IF;



    if new__is_live = 't' then
       PERFORM content_item__set_live_revision (v_revision_id);
    end if;

    return v_item_id;
end; $_$;


ALTER FUNCTION public.ee_item__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying) OWNER TO evex;

--
-- Name: ee_items; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_items (
    ee_item_id integer NOT NULL,
    cnpj text,
    category_id integer,
    contract_p boolean,
    url text,
    approved_p boolean,
    contract_date timestamp without time zone,
    contract_ip text,
    contract_cpf text,
    contract_user integer,
    phonenumber text,
    purchase_plan text,
    contact_person text,
    contact_email text,
    promocode text
);


ALTER TABLE public.ee_items OWNER TO evex;

--
-- Name: ee_itemsi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_itemsi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    ee_items.ee_item_id,
    ee_items.cnpj,
    ee_items.category_id,
    ee_items.contract_p,
    ee_items.url,
    ee_items.approved_p,
    ee_items.contract_date,
    ee_items.contract_ip,
    ee_items.contract_cpf,
    ee_items.contract_user,
    ee_items.phonenumber,
    ee_items.purchase_plan,
    ee_items.contact_person,
    ee_items.contact_email,
    ee_items.promocode
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.ee_items
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = ee_items.ee_item_id));


ALTER TABLE public.ee_itemsi OWNER TO evex;

--
-- Name: ee_items_f(public.ee_itemsi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_items_f(p_new public.ee_itemsi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into ee_items ( ee_item_id, cnpj, category_id, contract_p, url, approved_p, contract_date, contract_ip, contract_cpf, contract_user, phonenumber, purchase_plan, contact_person, contact_email, promocode ) values (v_revision_id, p_new.cnpj, p_new.category_id, p_new.contract_p, p_new.url, p_new.approved_p, p_new.contract_date, p_new.contract_ip, p_new.contract_cpf, p_new.contract_user, p_new.phonenumber, p_new.purchase_plan, p_new.contact_person, p_new.contact_email, p_new.promocode);
    
   return;
   end;$$;


ALTER FUNCTION public.ee_items_f(p_new public.ee_itemsi) OWNER TO evex;

--
-- Name: ee_lead__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_lead__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    p__lead_id	ALIAS FOR $1;

  BEGIN

    DELETE FROM ee_leads WHERE lead_id = p__lead_id;

    RETURN 0;

  END;$_$;


ALTER FUNCTION public.ee_lead__delete(integer) OWNER TO evex;

--
-- Name: ee_lead__new(integer, integer, timestamp with time zone, character varying, integer, bigint); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_lead__new(integer, integer, timestamp with time zone, character varying, integer, bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    new__lead_id	ALIAS FOR $1;
    new__object_id	ALIAS FOR $2;
    new__creation_date	ALIAS FOR $3;
    new__creation_ip	ALIAS FOR $4;
    new__creation_user	ALIAS FOR $5;
    new__value		ALIAS FOR $6;

  BEGIN

    INSERT INTO ee_leads (
      lead_id, object_id, creation_date, creation_ip, creation_user, counter
    ) VALUES (
      new__lead_id, new__object_id, new__creation_date, new__creation_ip, new__creation_user, new__value 
    );

    RETURN 0;

  END;$_$;


ALTER FUNCTION public.ee_lead__new(integer, integer, timestamp with time zone, character varying, integer, bigint) OWNER TO evex;

--
-- Name: ee_lead__update(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_lead__update(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    p__object_id	ALIAS FOR $1;

  BEGIN

    UPDATE ee_leads SET COUNTER = COUNTER + 1 WHERE object_id = p__object_id;

    RETURN 0;

  END;$_$;


ALTER FUNCTION public.ee_lead__update(integer) OWNER TO evex;

--
-- Name: ee_proposal__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_proposal__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    p__proposal_id	ALIAS FOR $1;

  BEGIN

    DELETE FROM ee_proposals WHERE proposal_id = p__proposal_id;

    RETURN 0;

  END;$_$;


ALTER FUNCTION public.ee_proposal__delete(integer) OWNER TO evex;

--
-- Name: ee_proposal__new(integer, integer, integer, timestamp with time zone, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_proposal__new(integer, integer, integer, timestamp with time zone, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    new__proposal_id	ALIAS FOR $1;
    new__event_id	ALIAS FOR $2;
    new__product_id	ALIAS FOR $3;
    new__creation_date	ALIAS FOR $4;
    new__creation_ip	ALIAS FOR $5;
    new__creation_user	ALIAS FOR $6;

  BEGIN

    

    INSERT INTO ee_proposals (
      proposal_id, event_id, product_id, creation_date, creation_ip, creation_user
    ) VALUES (
      new__proposal_id, new__event_id, new__product_id, new__creation_date, new__creation_ip, new__creation_user
    );

    RETURN 0;

  END;$_$;


ALTER FUNCTION public.ee_proposal__new(integer, integer, integer, timestamp with time zone, character varying, integer) OWNER TO evex;

--
-- Name: ee_proposal__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_proposal__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;  -- name
    new__item_id        alias for $2;
    new__parent_id	alias for $3; -- default null
    new__is_live	alias for $4; -- default f
    new__content_type   alias for $5; 
    new__category_id	alias for $6; -- item_type
    new__creation_user  alias for $7; -- default null
    new__creation_ip    alias for $8; -- default null
    new__title		alias for $9; -- default null
    new__description    alias for $10; -- default null
    new__revision_id    alias for $11; -- default null
    new__creation_date  alias for $12; -- default now()
    new__locale		alias for $13; -- default null
    new__context_id	alias for $14; -- default null
    new__publish_date   alias for $15; -- default now()
    new__nls_language   alias for $16; -- default null
    new__cnpj   	alias for $17; -- 
    
    -- if we ever need another parameter space creation_date is the best bet
    -- new__creation_date	timestamp default now();
    new_relation_tag	varchar default null;
    new__mime_type	varchar default null;

    v_item_id       integer;
    v_revision_id   integer;

  begin
    v_item_id := content_item__new (
      new__name || '-' || new__item_id,
      new__parent_id,
      new__item_id,
      new__locale,
      new__creation_date,
      new__creation_user,	
      new__context_id,
      new__creation_ip,
      'content_item',
      new__content_type,
      null,
      null,
      null,
      null,
      null
    );

      -- not needed in the new call to content_item__new
      -- new__relation_tag,

    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      v_item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip,
      new__parent_id
    );

    insert into ee_proposalsi (item_id, revision_id, title, proposal_id, product_id, event_id) 
    values (new__item_id, new__revision_id, new__title, new__product_id, new__event_id );

    if new__is_live = 't' then
       PERFORM content_item__set_live_revision (v_revision_id);
    end if;

    return v_item_id;
end; $_$;


ALTER FUNCTION public.ee_proposal__new(character varying, integer, integer, boolean, character varying, integer, integer, character varying, character varying, text, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying, character varying) OWNER TO evex;

--
-- Name: ee_proposals; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_proposals (
    proposal_id integer NOT NULL,
    event_id integer,
    product_id integer,
    status text,
    budget text,
    attachment integer
);


ALTER TABLE public.ee_proposals OWNER TO evex;

--
-- Name: ee_proposalsi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_proposalsi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    ee_proposals.proposal_id,
    ee_proposals.event_id,
    ee_proposals.product_id,
    ee_proposals.status,
    ee_proposals.budget,
    ee_proposals.attachment
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.ee_proposals
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = ee_proposals.proposal_id));


ALTER TABLE public.ee_proposalsi OWNER TO evex;

--
-- Name: ee_proposals_f(public.ee_proposalsi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_proposals_f(p_new public.ee_proposalsi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into ee_proposals ( proposal_id, event_id, product_id, status, budget, attachment ) values (v_revision_id, p_new.event_id, p_new.product_id, p_new.status, p_new.budget, p_new.attachment);
    
   return;
   end;$$;


ALTER FUNCTION public.ee_proposals_f(p_new public.ee_proposalsi) OWNER TO evex;

--
-- Name: ee_qa_item_category_score__new(integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_qa_item_category_score__new(integer, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    new__item_id	ALIAS FOR $1;
    new__category_id	ALIAS FOR $2;
    new__score		ALIAS FOR $3;

    -- new__id integer;
    v__item_id ee_qa_item_category_score.item_id%TYPE;

  BEGIN

    SELECT item_id INTO v__item_id FROM ee_qa_item_category_score WHERE item_id = new__item_id AND category_id = new__category_id;  

    IF v__item_id IS NULL THEN 

      INSERT INTO ee_qa_item_category_score (
        item_id, category_id, score
      ) VALUES (
        new__item_id, new__category_id, new__score
      );

      RETURN 0;
    END IF;

    RETURN 1;

  END$_$;


ALTER FUNCTION public.ee_qa_item_category_score__new(integer, integer, numeric) OWNER TO evex;

--
-- Name: ee_qa_item_category_score__update(integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_qa_item_category_score__update(integer, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    p__item_id		ALIAS FOR $1;
    p__category_id	ALIAS FOR $2;
    p__score		ALIAS FOR $3;

    -- new__id integer;
    v__item_id ee_qa_item_category_score.item_id%TYPE;

  BEGIN

    SELECT item_id INTO v__item_id FROM ee_qa_item_category_score WHERE item_id = p__item_id AND category_id = p__category_id;  

    IF v__item_id IS NOT NULL THEN 

      UPDATE ee_qa_item_category_score 
      SET score = p__score
      WHERE item_id = p__item_id AND category_id = p__category_id;
     
      RETURN 0;
    END IF;

    RETURN 1;

  END$_$;


ALTER FUNCTION public.ee_qa_item_category_score__update(integer, integer, numeric) OWNER TO evex;

--
-- Name: ee_qa_item_info__new(integer, integer, numeric, numeric, numeric, numeric, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_qa_item_info__new(integer, integer, numeric, numeric, numeric, numeric, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    new__item_id	ALIAS FOR $1;
    new__category_id	ALIAS FOR $2;
    new__cost		ALIAS FOR $3;
    new__vas		ALIAS FOR $4;
    new__score		ALIAS FOR $5;
    new__seg_ver	ALIAS FOR $6;
    new__price_p	ALIAS FOR $7;

    -- v_id integer;
    v_id ee_qa_item_info.item_id%TYPE;

  BEGIN

    SELECT item_id INTO v_id FROM ee_qa_item_info WHERE item_id = new__item_id;  

    IF v_id IS NULL THEN 

      INSERT INTO ee_qa_item_info (
        item_id, category_id, cost, vas, seg_ver, price_p, score
      ) VALUES (
        new__item_id, new__category_id, new__cost, new__vas, new__seg_ver, new__price_p, new__score
      );
      
      RETURN 0;

    END IF;

    RETURN 1;

  END$_$;


ALTER FUNCTION public.ee_qa_item_info__new(integer, integer, numeric, numeric, numeric, numeric, boolean) OWNER TO evex;

--
-- Name: ee_qa_item_info__update(integer, integer, numeric, numeric, numeric, numeric, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_qa_item_info__update(integer, integer, numeric, numeric, numeric, numeric, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    p__item_id		ALIAS FOR $1;
    p__category_id	ALIAS FOR $2;
    p__cost		ALIAS FOR $3;
    p__vas		ALIAS FOR $4;
    p__score		ALIAS FOR $5;
    p__seg_ver		ALIAS FOR $6;
    p__price_p		ALIAS FOR $7;

    -- v_item_id integer
    v_id ee_qa_item_info.item_id%TYPE;

  BEGIN

    SELECT item_id INTO v_id FROM ee_qa_item_info WHERE item_id = p__item_id;  

    IF v_id IS NOT NULL THEN 
       UPDATE ee_qa_item_info 
       SET 
             item_id =      p__item_id,
	     category_id =  p__category_id,
	     cost = 	    p__cost,
	     vas = 	    p__vas,
	     seg_ver = 	    p__seg_ver, 
	     price_p = 	    p__price_p, 
	     score =  	    p__score
	WHERE item_id = p__item_id;

       	RETURN 0;       
    END IF;

    RETURN 1;

  END$_$;


ALTER FUNCTION public.ee_qa_item_info__update(integer, integer, numeric, numeric, numeric, numeric, boolean) OWNER TO evex;

--
-- Name: ee_services; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_services (
    service_id integer NOT NULL,
    cnpj text,
    category_id integer,
    contract_p boolean,
    contract_date timestamp without time zone,
    contract_ip character varying,
    contract_cpf character varying,
    contract_user integer,
    url text,
    phonenumber text,
    contact_person text,
    contact_email text,
    purchase_plan text
);


ALTER TABLE public.ee_services OWNER TO evex;

--
-- Name: ee_servicesi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_servicesi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    ee_services.service_id,
    ee_services.cnpj,
    ee_services.category_id,
    ee_services.contract_p,
    ee_services.contract_date,
    ee_services.contract_ip,
    ee_services.contract_cpf,
    ee_services.contract_user,
    ee_services.url,
    ee_services.phonenumber,
    ee_services.contact_person,
    ee_services.contact_email,
    ee_services.purchase_plan
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.ee_services
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = ee_services.service_id));


ALTER TABLE public.ee_servicesi OWNER TO evex;

--
-- Name: ee_services_f(public.ee_servicesi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_services_f(p_new public.ee_servicesi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into ee_services ( service_id, cnpj, category_id, contract_p, url, phonenumber, contact_person, contact_email, purchase_plan ) values (v_revision_id, p_new.cnpj, p_new.category_id, p_new.contract_p, p_new.url, p_new.phonenumber, p_new.contact_person, p_new.contact_email, p_new.purchase_plan);
    
   return;
   end;$$;


ALTER FUNCTION public.ee_services_f(p_new public.ee_servicesi) OWNER TO evex;

--
-- Name: ee_venues; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_venues (
    venue_id integer NOT NULL,
    cnpj text,
    category_id integer,
    contract_p boolean,
    contract_date timestamp without time zone,
    contract_ip character varying,
    contract_cpf character varying,
    contract_user integer,
    url text,
    phonenumber text,
    contact_person text,
    contact_email text,
    purchase_plan text
);


ALTER TABLE public.ee_venues OWNER TO evex;

--
-- Name: ee_venuesi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_venuesi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    ee_venues.venue_id,
    ee_venues.cnpj,
    ee_venues.category_id,
    ee_venues.contract_p,
    ee_venues.contract_date,
    ee_venues.contract_ip,
    ee_venues.contract_cpf,
    ee_venues.contract_user,
    ee_venues.url,
    ee_venues.phonenumber,
    ee_venues.contact_person,
    ee_venues.contact_email,
    ee_venues.purchase_plan
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.ee_venues
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = ee_venues.venue_id));


ALTER TABLE public.ee_venuesi OWNER TO evex;

--
-- Name: ee_venues_f(public.ee_venuesi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.ee_venues_f(p_new public.ee_venuesi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into ee_venues ( venue_id, cnpj, category_id, contract_p, url, phonenumber, contact_person, contact_email, purchase_plan ) values (v_revision_id, p_new.cnpj, p_new.category_id, p_new.contract_p, p_new.url, p_new.phonenumber, p_new.contact_person, p_new.contact_email, p_new.purchase_plan);
    
   return;
   end;$$;


ALTER FUNCTION public.ee_venues_f(p_new public.ee_venuesi) OWNER TO evex;

--
-- Name: empty_lob(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.empty_lob() RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
	return nextval('lob_sequence');
END;
$$;


ALTER FUNCTION public.empty_lob() OWNER TO evex;

--
-- Name: faq__clone(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq__clone(p_new_package_id integer, p_old_package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
 v_faq_id 		faqs.faq_id%TYPE;
 one_faq		record;
 entry			record;

BEGIN
            -- get all the faqs belonging to the old package,
            -- and create new faqs for the new package
            for one_faq in select *
                            from acs_objects o, faqs f
                            where o.object_id = f.faq_id
                            and o.context_id = p_old_package_id
            loop
               v_faq_id := faq__new_faq (
                    			one_faq.faq_name,
                    			one_faq.separate_p,
                    			p_new_package_id
               	);

           	for entry in select * from faq_q_and_as
                                   where faq_id = one_faq.faq_id
           	loop

           		perform  faq__new_q_and_a (
                       		entry.faq_id,
                       		v_faq_id,
                       		entry.question,
                       		entry.answer,
                       		entry.sort_key
           	);
               end loop;
           end loop;
 return 0;
 END;

$$;


ALTER FUNCTION public.faq__clone(p_new_package_id integer, p_old_package_id integer) OWNER TO evex;

--
-- Name: faq__delete_faq(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq__delete_faq(p_faq_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	del_rec record;
BEGIN
	   	-- Because q_and_as are objects, we need to
    	-- loop through a list of them, and call an explicit
    	-- delete function for each one. (i.e. each
    	-- entry_id)
	for del_rec in select entry_id from faq_q_and_as
		where faq_id = p_faq_id
  loop
		PERFORM faq__delete_q_and_a(del_rec.entry_id);
	end loop;

	delete from faqs where faq_id = p_faq_id;

	PERFORM  acs_object__delete(p_faq_id);

	return 0;

END;
$$;


ALTER FUNCTION public.faq__delete_faq(p_faq_id integer) OWNER TO evex;

--
-- Name: faq__delete_q_and_a(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq__delete_q_and_a(p_entry_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	delete from faq_q_and_as where entry_id =  p_entry_id;
	raise NOTICE 'Deleting FAQ_Q_and_A...';
	PERFORM acs_object__delete(p_entry_id);

	return 0;
END;
$$;


ALTER FUNCTION public.faq__delete_q_and_a(p_entry_id integer) OWNER TO evex;

--
-- Name: faq__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq__name(p_faq_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE 
    v_faq_name    faqs.faq_name%TYPE;
BEGIN
	select faq_name  into v_faq_name
		from faqs
		where faq_id = p_faq_id;

    return v_faq_name;
END;

$$;


ALTER FUNCTION public.faq__name(p_faq_id integer) OWNER TO evex;

--
-- Name: faq__new_faq(integer, character varying, boolean, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq__new_faq(p_faq_id integer, p_faq_name character varying, p_separate_p boolean, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_faq_id 				faqs.faq_id%TYPE;
BEGIN

	v_faq_id := acs_object__new (
		p_faq_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id,
                't',
                p_faq_name,
                p_context_id );

	insert into faqs
		(faq_id, faq_name,separate_p)
	values
		(v_faq_id, p_faq_name,p_separate_p);

return v_faq_id;

END;
$$;


ALTER FUNCTION public.faq__new_faq(p_faq_id integer, p_faq_name character varying, p_separate_p boolean, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: faq__new_q_and_a(integer, integer, character varying, character varying, integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq__new_q_and_a(p_entry_id integer, p_faq_id integer, p_question character varying, p_answer character varying, p_sort_key integer, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_entry_id 			faq_q_and_as.entry_id%TYPE;
	v_package_id 			acs_objects.package_id%TYPE;
BEGIN
        select package_id into v_package_id from acs_objects where object_id = p_faq_id;

	v_entry_id := acs_object__new (
		p_entry_id,
		p_object_type,		
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id,
                't',
                p_question,
                v_package_id
  		);
	insert into faq_q_and_as
		(entry_id, faq_id, question, answer, sort_key)
	values
		(v_entry_id, p_faq_id, p_question, p_answer, p_sort_key);

  return v_entry_id;
END;
$$;


ALTER FUNCTION public.faq__new_q_and_a(p_entry_id integer, p_faq_id integer, p_question character varying, p_answer character varying, p_sort_key integer, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: faq_sc__dtrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq_sc__dtrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    perform search_observer__enqueue(old.entry_id,'DELETE'); 
    return old;
end;
$$;


ALTER FUNCTION public.faq_sc__dtrg() OWNER TO evex;

--
-- Name: faq_sc__itrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq_sc__itrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    perform search_observer__enqueue(new.entry_id,'INSERT'); 
    return new;
end; 
$$;


ALTER FUNCTION public.faq_sc__itrg() OWNER TO evex;

--
-- Name: faq_sc__utrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.faq_sc__utrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    perform search_observer__enqueue(old.entry_id,'UPDATE'); 
    return old;
end; 
$$;


ALTER FUNCTION public.faq_sc__utrg() OWNER TO evex;

--
-- Name: file_storage__copy_file(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__copy_file(copy_file__file_id integer, copy_file__target_folder_id integer, copy_file__creation_user integer, copy_file__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_name                       cr_items.name%TYPE;
        v_live_revision              cr_items.live_revision%TYPE;
        v_filename                   cr_revisions.title%TYPE;
        v_description                cr_revisions.description%TYPE;
        v_mime_type                  cr_revisions.mime_type%TYPE;
        v_content_length             cr_revisions.content_length%TYPE;
        v_lob_id                     cr_revisions.lob%TYPE;
        v_new_lob_id                 cr_revisions.lob%TYPE;
        v_file_path                  cr_revisions.content%TYPE;
        v_new_file_id                cr_items.item_id%TYPE;
        v_new_version_id                     cr_revisions.revision_id%TYPE;
        v_indb_p                     boolean;
        v_isurl                      boolean;
        v_content_type               cr_items.content_type%TYPE;
        v_package_id                 apm_packages.package_id%TYPE;
BEGIN

        v_isurl:= false;
        select content_type into v_content_type from cr_items where item_id = copy_file__file_id;
        if v_content_type = 'content_extlink'
        then
          v_isurl:= true;
        end if;

        -- We copy only the title from the file being copied, and attributes of the live revision
        if v_isurl = false
        then
          select i.name,i.live_revision,r.title,r.description,r.mime_type,r.content_length,
               (case when i.storage_type = 'lob'
                     then true
                     else false
                end)
               into v_name,v_live_revision,v_filename,v_description,v_mime_type,v_content_length,v_indb_p
          from cr_items i, cr_revisions r
          where r.item_id = i.item_id
          and   r.revision_id = i.live_revision
          and   i.item_id = copy_file__file_id;

          select package_id into v_package_id from acs_objects where object_id = copy_file__file_id;

          v_new_file_id := file_storage__new_file(
                             v_name,                     -- name
                             copy_file__target_folder_id, -- folder_id
                             copy_file__creation_user,    -- creation_user
                             copy_file__creation_ip,      -- creation_ip
                             v_indb_p,                    -- indb_p
                             v_package_id                 -- package_id
                             );

          v_new_version_id := file_storage__new_version (
                             v_filename,                  -- title
                             v_description,               -- description
                             v_mime_type,                 -- mime_type
                             v_new_file_id,               -- item_id
                             copy_file__creation_user,    -- creation_user
                             copy_file__creation_ip       -- creation_ip
                             );

          if v_indb_p
          then

                -- Lob to copy from
                select lob into v_lob_id
                from cr_revisions
                where revision_id = v_live_revision;

                -- New lob id
                v_new_lob_id := empty_lob();

                -- copy the blob
                perform lob_copy(v_lob_id,v_new_lob_id);

                -- Update the lob id on the new version
                update cr_revisions
                set lob = v_new_lob_id,
                    content_length = v_content_length
                where revision_id = v_new_version_id;

          else
               -- For now, we simply copy the file name
                select content into v_file_path
                from cr_revisions
                where revision_id = v_live_revision;

                -- Update the file path
                update cr_revisions
                set content = v_file_path,
                    content_length = v_content_length
                where revision_id = v_new_version_id;

          end if;
          perform acs_object__update_last_modified(copy_file__target_folder_id,copy_file__creation_user,copy_file__creation_ip);
          return v_new_version_id;
        else
          perform content_extlink__copy (copy_file__file_id, copy_file__target_folder_id, copy_file__creation_user,copy_file__creation_ip,v_name);
          return 0;
        end if;

END;
$$;


ALTER FUNCTION public.file_storage__copy_file(copy_file__file_id integer, copy_file__target_folder_id integer, copy_file__creation_user integer, copy_file__creation_ip character varying) OWNER TO evex;

--
-- Name: file_storage__delete_file(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__delete_file(delete_file__file_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

        return content_item__delete(delete_file__file_id);

END;
$$;


ALTER FUNCTION public.file_storage__delete_file(delete_file__file_id integer) OWNER TO evex;

--
-- Name: file_storage__delete_folder(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__delete_folder(delete_folder__folder_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return file_storage__delete_folder(
                    delete_folder__folder_id,  -- folder_id
                    'f');

END;
$$;


ALTER FUNCTION public.file_storage__delete_folder(delete_folder__folder_id integer) OWNER TO evex;

--
-- Name: file_storage__delete_folder(integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__delete_folder(delete_folder__folder_id integer, delete_folder__cascade_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return content_folder__delete(
                    delete_folder__folder_id,  -- folder_id
                    delete_folder__cascade_p
                    );

END;
$$;


ALTER FUNCTION public.file_storage__delete_folder(delete_folder__folder_id integer, delete_folder__cascade_p boolean) OWNER TO evex;

--
-- Name: file_storage__delete_version(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__delete_version(delete_version__file_id integer, delete_version__version_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_id                     cr_items.parent_id%TYPE;
        v_deleted_last_version_p        boolean;
BEGIN

        if delete_version__version_id = content_item__get_live_revision(delete_version__file_id) 
        then
            PERFORM content_revision__delete(delete_version__version_id);
            PERFORM content_item__set_live_revision(
                        content_item__get_latest_revision(delete_version__file_id)
                        );
        else
            PERFORM content_revision__delete(delete_version__version_id);
        end if;

        -- If the live revision is null, we have deleted the last version above
        select (case when live_revision is null
                     then parent_id
                     else 0
                end)
          into v_parent_id 
        from cr_items
        where item_id = delete_version__file_id;

        -- Unfortunately, due to PostgreSQL behavior with regards referential integrity,
        -- we cannot delete the content_item entry if there are no more revisions.
        return v_parent_id;

END;
$$;


ALTER FUNCTION public.file_storage__delete_version(delete_version__file_id integer, delete_version__version_id integer) OWNER TO evex;

--
-- Name: file_storage__get_content_type(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__get_content_type(get_content_type__file_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return content_item__get_content_type(
                          get_content_type__file_id
                          );

END;
$$;


ALTER FUNCTION public.file_storage__get_content_type(get_content_type__file_id integer) OWNER TO evex;

--
-- Name: file_storage__get_folder_name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__get_folder_name(get_folder_name__folder_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return content_folder__get_label(get_folder_name__folder_id);
END;
$$;


ALTER FUNCTION public.file_storage__get_folder_name(get_folder_name__folder_id integer) OWNER TO evex;

--
-- Name: file_storage__get_package_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__get_package_id(get_package_id__item_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_package_id                fs_root_folders.package_id%TYPE;
    v_tree_sortkey              cr_items.tree_sortkey%TYPE;
BEGIN

    select fs_root_folders.package_id
    into v_package_id
    from fs_root_folders,
        (select cr_items.item_id 
           from (select tree_ancestor_keys(cr_items_get_tree_sortkey(get_package_id__item_id)) as tree_sortkey) parents,
             cr_items
          where cr_items.tree_sortkey = parents.tree_sortkey) this
    where fs_root_folders.folder_id = this.item_id;

    if NOT FOUND then
        return null;
    else
        return v_package_id;
    end if;

END;
$$;


ALTER FUNCTION public.file_storage__get_package_id(get_package_id__item_id integer) OWNER TO evex;

--
-- Name: file_storage__get_parent_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__get_parent_id(get_parent_id__item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
     declare 
         v_parent_id          cr_items.item_id%TYPE;
     begin

         select parent_id
         into v_parent_id
         from cr_items
         where item_id = get_parent_id__item_id;

       return v_parent_id;
END;
$$;


ALTER FUNCTION public.file_storage__get_parent_id(get_parent_id__item_id integer) OWNER TO evex;

--
-- Name: file_storage__get_root_folder(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__get_root_folder(get_root_folder__package_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
        v_folder_id  fs_root_folders.folder_id%TYPE;
BEGIN
        select folder_id into v_folder_id 
        from fs_root_folders
        where package_id = get_root_folder__package_id;

        return v_folder_id;

END;
$$;


ALTER FUNCTION public.file_storage__get_root_folder(get_root_folder__package_id integer) OWNER TO evex;

--
-- Name: file_storage__get_title(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__get_title(get_title__item_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_title                            cr_revisions.title%TYPE;
  v_content_type                     cr_items.content_type%TYPE;
BEGIN
  
  select content_type into v_content_type 
  from cr_items 
  where item_id = get_title__item_id;

  if v_content_type = 'content_folder' 
  then
      select label into v_title 
      from cr_folders 
      where folder_id = get_title__item_id;
  else if v_content_type = 'content_symlink' 
       then
         select label into v_title from cr_symlinks 
         where symlink_id = get_title__item_id;
       else
         select title into v_title
         from cr_revisions, cr_items
         where revision_id=live_revision
     and cr_items.item_id=get_title__item_id;
       end if;
  end if;

  return v_title;
END;
$$;


ALTER FUNCTION public.file_storage__get_title(get_title__item_id integer) OWNER TO evex;

--
-- Name: file_storage__move_file(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__move_file(move_file__file_id integer, move_file__target_folder_id integer, move_file__creation_user integer, move_file__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

        perform content_item__move(
               move_file__file_id,              -- item_id
               move_file__target_folder_id      -- target_folder_id
               );

        perform acs_object__update_last_modified(move_file__target_folder_id,move_file__creation_user,move_file__creation_ip);

        return 0;
END;
$$;


ALTER FUNCTION public.file_storage__move_file(move_file__file_id integer, move_file__target_folder_id integer, move_file__creation_user integer, move_file__creation_ip character varying) OWNER TO evex;

--
-- Name: file_storage__new_file(character varying, integer, integer, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__new_file(new_file__name character varying, new_file__folder_id integer, new_file__user_id integer, new_file__creation_ip character varying, new_file__indb_p boolean, new_file__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return file_storage__new_file(
             new_file__name,            -- name
             new_file__folder_id,       -- parent_id
             new_file__user_id,         -- creation_user
             new_file__creation_ip,     -- creation_ip
             new_file__indb_p,          -- storage_type
             null,                      -- item_id
             new_file__package_id       -- pacakge_id
        );

END;
$$;


ALTER FUNCTION public.file_storage__new_file(new_file__name character varying, new_file__folder_id integer, new_file__user_id integer, new_file__creation_ip character varying, new_file__indb_p boolean, new_file__package_id integer) OWNER TO evex;

--
-- Name: file_storage__new_file(character varying, integer, integer, character varying, boolean, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__new_file(new_file__name character varying, new_file__folder_id integer, new_file__user_id integer, new_file__creation_ip character varying, new_file__indb_p boolean, new_file__item_id integer, new_file__package_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_item_id                       integer;
BEGIN
        if new_file__indb_p
        then 
            v_item_id := content_item__new (
                        new_file__name,            -- name
                        new_file__folder_id,      -- parent_id
                        new_file__item_id,        -- item_id (default)
                        null,                       -- locale (default)
                        now(),              -- creation_date (default)
                        new_file__user_id,        -- creation_user
                        new_file__folder_id,      -- context_id
                        new_file__creation_ip,    -- creation_ip
                        'content_item',         -- item_subtype (default)
                        'file_storage_object',  -- content_type (needed by site-wide search)
                        null,                       -- title (default)
                        null,                       -- description
                        'text/plain',     -- mime_type (default)
                        null,                       -- nls_language (default)
                        null,                       -- data (default)
                        new_file__package_id        -- package_id
                    );
        else
            v_item_id := content_item__new (
                        new_file__name,            -- name
                        new_file__folder_id,        -- parent_id
                        new_file__item_id,          -- item_id (default)
                        null,                       -- locale (default)
                        now(),              -- creation_date (default)
                        new_file__user_id,          -- creation_user
                        new_file__folder_id,        -- context_id
                        new_file__creation_ip,    -- creation_ip
                        'content_item',         -- item_subtype (default)
                        'file_storage_object',  -- content_type (needed by site-wide search)
                        null,                       -- title (default)
                        null,                       -- description
                        'text/plain',     -- mime_type (default)
                        null,                       -- nls_language (default)
                        null,                       -- text (default)
                        'file',                   -- storage_type
                        new_file__package_id        -- package_id
                    );

        end if;

        perform acs_object__update_last_modified(new_file__folder_id,new_file__user_id,new_file__creation_ip);

        return v_item_id;

END;
$$;


ALTER FUNCTION public.file_storage__new_file(new_file__name character varying, new_file__folder_id integer, new_file__user_id integer, new_file__creation_ip character varying, new_file__indb_p boolean, new_file__item_id integer, new_file__package_id integer) OWNER TO evex;

--
-- Name: file_storage__new_folder(character varying, character varying, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__new_folder(new_folder__name character varying, new_folder__folder_name character varying, new_folder__parent_id integer, new_folder__creation_user integer, new_folder__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_folder_id                   cr_folders.folder_id%TYPE;
        v_package_id                  acs_objects.package_id%TYPE;
BEGIN
        v_package_id := file_storage__get_package_id(new_folder__parent_id);

        -- Create a new folder
        v_folder_id := content_folder__new (
                            new_folder__name,           -- name
                            new_folder__folder_name,    -- label
                            null,                       -- description
                            new_folder__parent_id,      -- parent_id
                            null,                       -- context_id (default)
                            null,                       -- folder_id (default)
                            now(),                      -- creation_date
                            new_folder__creation_user,  -- creation_user
                            new_folder__creation_ip,    -- creation_ip
                            v_package_id                -- package_id
                            );

        --                
        -- Register the needed content types
        --
        -- maybe, when someone decides to really implement the half-cooked
        -- "image" content type, it should go in here as well
    
        PERFORM content_folder__register_content_type(
                        v_folder_id,             -- folder_id
                        'file_storage_object',   -- content_type
                        't');                    -- include_subtypes (default)
    
        PERFORM content_folder__register_content_type(
                        v_folder_id,        -- folder_id
                        'content_folder',       -- content_type
                        't');                   -- include_subtypes (default)

        PERFORM content_folder__register_content_type(
                    v_folder_id,            -- folder_id
                'content_extlink',        -- content_types
            't');                   -- include_subtypes 

--        PERFORM content_folder__register_content_type(
--            v_folder_id,            -- folder_id
--                    'content_symlink',    -- content_types
--                    't');                   -- include_subtypes 

        -- Give the creator admin privileges on the folder
        PERFORM acs_permission__grant_permission (
                     v_folder_id,                -- object_id
                     new_folder__creation_user,  -- grantee_id
                     'admin'                   -- privilege
                     );

        return v_folder_id;

END;
$$;


ALTER FUNCTION public.file_storage__new_folder(new_folder__name character varying, new_folder__folder_name character varying, new_folder__parent_id integer, new_folder__creation_user integer, new_folder__creation_ip character varying) OWNER TO evex;

--
-- Name: file_storage__new_root_folder(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__new_root_folder(new_root_folder__package_id integer, new_root_folder__folder_name character varying, new_root_folder__url character varying, new_root_folder__description character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_folder_id                         fs_root_folders.folder_id%TYPE;
BEGIN
        v_folder_id := content_folder__new (
            new_root_folder__url, -- name
            new_root_folder__folder_name, -- label
            new_root_folder__description, -- description
            null,  -- parent_id (default)
            new_root_folder__package_id, --context_id
            null, --folder_id
            null, --creation_date
            null, --creation_user
            null, --creation_ip
            new_root_folder__package_id --package_id
        );

        insert into fs_root_folders (package_id, folder_id)
        values (new_root_folder__package_id, v_folder_id);

        --                
        -- Register the needed content types
        --
        -- GN: Maybe, when someone decides to really implement the half-cooked
        -- "image" content type, it should go in here as well.
    
        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'file_storage_object',  -- content_types
                'f');                   -- include_subtypes 
        
        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_folder',    -- content_types
                't');                   -- include_subtypes 

        PERFORM content_folder__register_content_type(
                v_folder_id,            -- folder_id
                'content_extlink',    -- content_types
                't');                   -- include_subtypes 

--        PERFORM content_folder__register_content_type(
--                v_folder_id,            -- folder_id
--                'content_symlink',      -- content_types
--                't');                   -- include_subtypes 
--                );

        return v_folder_id;
END;
$$;


ALTER FUNCTION public.file_storage__new_root_folder(new_root_folder__package_id integer, new_root_folder__folder_name character varying, new_root_folder__url character varying, new_root_folder__description character varying) OWNER TO evex;

--
-- Name: file_storage__new_version(character varying, character varying, character varying, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__new_version(new_version__filename character varying, new_version__description character varying, new_version__mime_type character varying, new_version__item_id integer, new_version__creation_user integer, new_version__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_revision_id                   cr_revisions.revision_id%TYPE;
        v_folder_id                     cr_items.parent_id%TYPE;
BEGIN
        -- Create a revision
        v_revision_id := content_revision__new (
                          new_version__filename,        -- title
                          new_version__description,     -- description
                          now(),                        -- publish_date
                          new_version__mime_type,       -- mime_type
                          null,                         -- nls_language
                          null,                         -- data (default)
                          new_version__item_id,         -- item_id
                          null,                         -- revision_id
                          now(),                        -- creation_date
                          new_version__creation_user,   -- creation_user
                          new_version__creation_ip      -- creation_ip
                          );

        -- Make live the newly created revision
        perform content_item__set_live_revision(v_revision_id);

        select cr_items.parent_id
        into v_folder_id
        from cr_items
        where cr_items.item_id = new_version__item_id;

        perform acs_object__update_last_modified(v_folder_id,new_version__creation_user,new_version__creation_ip);
        perform acs_object__update_last_modified(new_version__item_id,new_version__creation_user,new_version__creation_ip);

        return v_revision_id;

END;
$$;


ALTER FUNCTION public.file_storage__new_version(new_version__filename character varying, new_version__description character varying, new_version__mime_type character varying, new_version__item_id integer, new_version__creation_user integer, new_version__creation_ip character varying) OWNER TO evex;

--
-- Name: file_storage__rename_file(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage__rename_file(rename_file__file_id integer, rename_file__name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

        return content_item__edit_name(
               rename_file__file_id,  -- item_id
               rename_file__name     -- name
               );

END;
$$;


ALTER FUNCTION public.file_storage__rename_file(rename_file__file_id integer, rename_file__name character varying) OWNER TO evex;

--
-- Name: file_storage_object_t; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.file_storage_object_t (
    file_storage_object_id integer NOT NULL
);


ALTER TABLE public.file_storage_object_t OWNER TO evex;

--
-- Name: file_storage_object_ti; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.file_storage_object_ti AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    file_storage_object_t.file_storage_object_id
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.file_storage_object_t
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = file_storage_object_t.file_storage_object_id));


ALTER TABLE public.file_storage_object_ti OWNER TO evex;

--
-- Name: file_storage_object_t_f(public.file_storage_object_ti); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.file_storage_object_t_f(p_new public.file_storage_object_ti) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into file_storage_object_t ( file_storage_object_id ) values (v_revision_id);
    
   return;
   end;$$;


ALTER FUNCTION public.file_storage_object_t_f(p_new public.file_storage_object_ti) OWNER TO evex;

--
-- Name: fin_trans_ccard_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.fin_trans_ccard_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
        v_creditcard_id         ec_creditcards.creditcard_id%TYPE;
begin
        IF new.order_id is not null THEN
                select into v_creditcard_id creditcard_id 
		    from ec_orders where order_id=new.order_id;
                IF new.creditcard_id is null THEN
                        new.creditcard_id := v_creditcard_id;
                END IF;
        END IF;
	return new;
end;$$;


ALTER FUNCTION public.fin_trans_ccard_update_tr() OWNER TO evex;

--
-- Name: fs_package_items_delete_trig(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.fs_package_items_delete_trig() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_rec   record;
BEGIN

        for v_rec in
        
                -- We want to delete all cr_items entries, starting from the leaves all
                --  the way up the root folder (old.folder_id).
                select c1.item_id, c1.content_type
                from cr_items c1, cr_items c2
                where c2.item_id = old.folder_id
                  and c1.tree_sortkey between c2.tree_sortkey and tree_right(c2.tree_sortkey)
                  and c1.item_id <> old.folder_id
                order by c1.tree_sortkey desc
        loop

                -- DRB: Why can't we just use object delete here?


                -- We delete the item. On delete cascade should take care
                -- of deletion of revisions.
                if v_rec.content_type = 'file_storage_object'
                then
                    raise notice 'Deleting item_id = %',v_rec.item_id;
                    PERFORM content_item__delete(v_rec.item_id);
                end if;

                -- Instead of doing an if-else, we make sure we are deleting a folder.
                if v_rec.content_type = 'content_folder'
                then
                    raise notice 'Deleting folder_id = %',v_rec.item_id;
                    PERFORM content_folder__delete(v_rec.item_id);
                end if;

                -- Instead of doing an if-else, we make sure we are deleting a folder.
                if v_rec.content_type = 'content_symlink'
                then
                    raise notice 'Deleting symlink_id = %',v_rec.item_id;
                    PERFORM content_symlink__delete(v_rec.item_id);
                end if;

                -- Instead of doing an if-else, we make sure we are deleting a folder.
                if v_rec.content_type = 'content_extlink'
                then
                    raise notice 'Deleting folder_id = %',v_rec.item_id;
                    PERFORM content_extlink__delete(v_rec.item_id);
                end if;

        end loop;

        -- We need to return something for the trigger to be activated
        return old;

END;
$$;


ALTER FUNCTION public.fs_package_items_delete_trig() OWNER TO evex;

--
-- Name: fs_root_folder_delete_trig(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.fs_root_folder_delete_trig() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
        PERFORM content_folder__delete(old.folder_id);
        return null;

END;
$$;


ALTER FUNCTION public.fs_root_folder_delete_trig() OWNER TO evex;

--
-- Name: get_func_definition(character varying, oidvector); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.get_func_definition(fname character varying, args oidvector) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
        v_funcdef       text default '';
        v_args          varchar;
        v_nargs         integer;
        v_src           text;
        v_rettype       varchar;
BEGIN
        select pg_get_function_arguments(oid), pronargs, prosrc, -- was number_src(prosrc)
               (select typname from pg_type where oid = p.prorettype::integer)
          into v_args, v_nargs, v_src, v_rettype
          from pg_proc p 
         where proname = fname::name
           and proargtypes = args;

         v_funcdef :=
	 	   E'--\n-- ' || fname || '/' || v_nargs || E'\n--' 
         	   || E'\ncreate or replace function ' || fname || E'(\n  '
                   || replace(v_args, ', ', E',\n  ')
	           || E'\n) returns ' || v_rettype
		   || E' as $$\n' || v_src || '$$ language plpgsql;';

        return v_funcdef;
END;
$_$;


ALTER FUNCTION public.get_func_definition(fname character varying, args oidvector) OWNER TO evex;

--
-- Name: get_func_drop_command(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.get_func_drop_command(fname character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
        nargs           integer default 0;
        v_pos           integer;
        v_funcdef       text;
        v_args          varchar;
        v_one_arg       varchar;
        v_one_type      varchar;
        v_nargs         integer;
BEGIN
        v_funcdef := 'drop function ' || fname || '(';

        select proargtypes, pronargs
          into v_args, v_nargs
          from pg_proc 
         where proname = fname::name;

        v_pos := position(' ' in v_args);
        
        while nargs < v_nargs loop
              nargs := nargs + 1;
              if nargs = v_nargs then 
                 v_one_arg := v_args;
                 v_args    := '';
              else
                 v_one_arg := substr(v_args, 1, v_pos - 1);
                 v_args    := substr(v_args, v_pos + 1);
                 v_pos     := position(' ' in v_args);            
              end if;
              select case when nargs = 1 
                            then typname 
                            else ',' || typname 
                          end into v_one_type 
                from pg_type 
               where oid = v_one_arg::integer;
              v_funcdef := v_funcdef || v_one_type;            
        end loop;
        v_funcdef := v_funcdef || ') CASCADE';

        return v_funcdef;

END;
$$;


ALTER FUNCTION public.get_func_drop_command(fname character varying) OWNER TO evex;

--
-- Name: get_func_header(character varying, oidvector); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.get_func_header(fname character varying, args oidvector) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
        v_src   text;
        pos     integer;
BEGIN
        v_src := get_func_definition(fname,args);
        pos := position('begin' in lower(v_src));

        return substr(v_src, 1, pos + 4);

END;
$$;


ALTER FUNCTION public.get_func_header(fname character varying, args oidvector) OWNER TO evex;

--
-- Name: gift_certificate_amount_left(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.gift_certificate_amount_left(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_gift_certificate_id 	alias for $1;
        original_amount         numeric;
        total_amount_used       numeric;
BEGIN
        SELECT coalesce(sum(amount_used),0) - coalesce(sum(amount_reinstated),0)
	into total_amount_used
        FROM ec_gift_certificate_usage
        WHERE gift_certificate_id = v_gift_certificate_id;

        SELECT amount
	into original_amount
        FROM ec_gift_certificates
        WHERE gift_certificate_id = v_gift_certificate_id;

        RETURN original_amount - total_amount_used;
END;$_$;


ALTER FUNCTION public.gift_certificate_amount_left(integer) OWNER TO evex;

--
-- Name: group_contains_p(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.group_contains_p(group_contains_p__group_id integer, group_contains_p__component_id integer, group_contains_p__rel_id integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE 
        map                               record;
BEGIN
  if group_contains_p__group_id = group_contains_p__component_id then
    return 't';
  else
    if group_contains_p__rel_id is null then
      for map in  select *
                  from group_component_map
                  where component_id = group_contains_p__component_id
                  and group_id = container_id 
      LOOP
        if group_contains_p(group_contains_p__group_id, map.group_id, null) = 't' then
          return 't';
        end if;
      end loop;
    else
      for map in  select *
                  from group_component_map
                  where component_id = group_contains_p__component_id
                  and rel_id = group_contains_p__rel_id
                  and group_id = container_id 
      LOOP
        if group_contains_p(group_contains_p__group_id, map.group_id, null) = 't' then
          return 't';
        end if;
      end loop;
    end if;
    return 'f';
  end if;
END;
$$;


ALTER FUNCTION public.group_contains_p(group_contains_p__group_id integer, group_contains_p__component_id integer, group_contains_p__rel_id integer) OWNER TO evex;

--
-- Name: im_biz_object__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	object_id	alias for $1;
	v_object_id	integer;
begin
	-- Erase the im_biz_objects item associated with the id
	delete from 	im_biz_objects
	where		object_id = del.object_id;

	PERFORM acs_object.del(del.object_id);
	return 0;
end; $_$;


ALTER FUNCTION public.im_biz_object__delete(integer) OWNER TO evex;

--
-- Name: im_biz_object__get_status_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object__get_status_id(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id		alias for $1;

	v_object_type		varchar;
	v_supertype		varchar;

	v_status_table		varchar;
	v_status_column		varchar;
	v_status_table_id_col	varchar;

	v_query			varchar;
	row			RECORD;
	v_result_id		integer;
BEGIN
	-- Get information from SQL metadata system
	select	ot.object_type, ot.supertype, ot.status_type_table, ot.status_column
	into	v_object_type, v_supertype, v_status_table, v_status_column
	from	acs_objects o, acs_object_types ot
	where	o.object_id = p_object_id and o.object_type = ot.object_type;

	-- In the case that the information about should not be set up correctly:
	-- Check if the object has a supertype and update table and id_column if necessary
	WHILE v_status_table is null AND 'acs_object' != v_supertype AND 'im_biz_object' != v_supertype LOOP
		select	ot.supertype, ot.status_type_table, ot.id_column
		into	v_supertype, v_status_table, v_status_table_id_col
		from	acs_object_types ot
		where	ot.object_type = v_supertype;
	END LOOP;

	-- Get the id_column for the v_status_table (not the objects main table...)
	select	distinct aott.id_column into v_status_table_id_col from acs_object_type_tables aott
	where	aott.object_type = v_object_type and aott.table_name = v_status_table;

	-- Avoid reporting an error. However, this may make it more difficult diagnosing errors.
	IF v_status_table is null OR v_status_table_id_col is null OR v_status_column is null THEN
		return 0;
	END IF;

	-- Funny way, but this is the only option to get a value from an EXECUTE in PG 8.0 and below.
	v_query := ' select ' || v_status_column || ' as result_id ' || ' from ' || v_status_table || 
		' where ' || v_status_table_id_col || ' = ' || p_object_id;
	FOR row IN EXECUTE v_query
	LOOP
		v_result_id := row.result_id;
		EXIT;
	END LOOP;

	return v_result_id;
END; $_$;


ALTER FUNCTION public.im_biz_object__get_status_id(integer) OWNER TO evex;

--
-- Name: im_biz_object__get_type_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object__get_type_id(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id		alias for $1;

	v_query			varchar;
	v_object_type		varchar;
	v_supertype		varchar;
	v_table			varchar;
	v_id_column		varchar;
	v_type_column		varchar;

	row			RECORD;
	v_result_id		integer;
BEGIN
	-- Get information from SQL metadata system
	select	ot.object_type, ot.supertype, ot.status_type_table, ot.type_column
	into	v_object_type, v_supertype, v_table, v_type_column
	from	acs_objects o, acs_object_types ot
	where	o.object_id = p_object_id
		and o.object_type = ot.object_type;

	-- Check if the object has a supertype and update table necessary
	WHILE v_table is null AND 'acs_object' != v_supertype AND 'im_biz_object' != v_supertype LOOP
		select	ot.supertype, ot.table_name
		into	v_supertype, v_table
		from	acs_object_types ot
		where	ot.object_type = v_supertype;
	END LOOP;

	-- Get the id_column for v_table
	select	aott.id_column into v_id_column from acs_object_type_tables aott
	where	aott.object_type = v_object_type and aott.table_name = v_table;

	IF v_table is null OR v_id_column is null OR v_type_column is null THEN
		return 0;
	END IF;

	-- Funny way, but this is the only option to EXECUTE in PG 8.0 and below.
	v_query := ' select ' || v_type_column || ' as result_id ' || ' from ' || v_table || 
		' where ' || v_id_column || ' = ' || p_object_id;
	FOR row IN EXECUTE v_query
	LOOP
		v_result_id := row.result_id;
		EXIT;
	END LOOP;

	return v_result_id;
END; $_$;


ALTER FUNCTION public.im_biz_object__get_type_id(integer) OWNER TO evex;

--
-- Name: im_biz_object__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
	object_id	alias for $1;
begin
	return "undefined for im_biz_object";
end; $_$;


ALTER FUNCTION public.im_biz_object__name(integer) OWNER TO evex;

--
-- Name: im_biz_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_object_id	alias for $1;
	p_object_type	alias for $2;
	p_creation_date	alias for $3;
	p_creation_user	alias for $4;
	p_creation_ip	alias for $5;
	p_context_id	alias for $6;

	v_object_id	integer;
begin
	v_object_id := acs_object__new (
		p_object_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);
	insert into im_biz_objects (object_id) values (v_object_id);
	return v_object_id;

end; $_$;


ALTER FUNCTION public.im_biz_object__new(integer, character varying, timestamp with time zone, integer, character varying, integer) OWNER TO evex;

--
-- Name: im_biz_object__set_status_id(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object__set_status_id(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id		alias for $1;
	p_status_id		alias for $2;
	v_object_type		varchar;
	v_supertype		varchar;	v_table			varchar;
	v_id_column		varchar;	v_column		varchar;
	row			RECORD;
BEGIN
	-- Get information from SQL metadata system
	select	ot.object_type, ot.supertype, ot.table_name, ot.id_column, ot.status_column
	into	v_object_type, v_supertype, v_table, v_id_column, v_column
	from	acs_objects o, acs_object_types ot
	where	o.object_id = p_object_id
		and o.object_type = ot.object_type;

	-- Check if the object has a supertype and update table and id_column if necessary
	WHILE 'acs_object' != v_supertype AND 'im_biz_object' != v_supertype LOOP
		select	ot.supertype, ot.table_name, ot.id_column
		into	v_supertype, v_table, v_id_column
		from	acs_object_types ot
		where	ot.object_type = v_supertype;
	END LOOP;

	IF v_table is null OR v_id_column is null OR v_column is null THEN
		RAISE NOTICE 'im_biz_object__set_status_id: Bad metadata: Null value for %',v_object_type;
		return 0;
	END IF;

	update	acs_objects
	set	last_modified = now()
	where	object_id = p_object_id;

	EXECUTE 'update '||v_table||' set '||v_column||'='||p_status_id||
		' where '||v_id_column||'='||p_object_id;

	return 0;
END; $_$;


ALTER FUNCTION public.im_biz_object__set_status_id(integer, integer) OWNER TO evex;

--
-- Name: im_biz_object__set_status_id(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object__set_status_id(integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id		alias for $1;
	p_dummy			alias for $2;
	p_status_id		alias for $3;
BEGIN
	return im_biz_object__set_status_id (p_object_id, p_status_id::integer);
END; $_$;


ALTER FUNCTION public.im_biz_object__set_status_id(integer, character varying, integer) OWNER TO evex;

--
-- Name: im_biz_object__type(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object__type(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_object_id		alias for $1;
	v_object_type		varchar;
	v_biz_object_type_id	integer;
begin

	-- get the object type
	select	object_type
	into	v_object_type
	from	acs_objects
	where	object_id = p_object_id;

	-- Initialize the return value
	v_biz_object_type_id = null;

	IF 'im_project' = v_object_type THEN

		select	project_type_id
		into	v_biz_object_type_id
		from	im_projects
		where	project_id = p_object_id;

	ELSIF 'im_company' = v_object_type THEN

		select	company_type_id
		into	v_biz_object_type_id
		from	im_companies
		where	company_id = p_object_id;

	END IF;

	return v_biz_object_type_id;

end; $_$;


ALTER FUNCTION public.im_biz_object__type(integer) OWNER TO evex;

--
-- Name: im_biz_object_group__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object_group__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_group_id	alias for $1;
begin
	delete from im_biz_object_groups where group_id = p_group_id;
	perform acs_group__delete( p_group_id );
	return 1;
end;$_$;


ALTER FUNCTION public.im_biz_object_group__delete(integer) OWNER TO evex;

--
-- Name: im_biz_object_group__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object_group__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
	p_group_id	alias for $1;
	v_name		varchar;
begin
	select	group_name into v_name from groups
	where	group_id = p_group_id;
	return v_name;
end;$_$;


ALTER FUNCTION public.im_biz_object_group__name(integer) OWNER TO evex;

--
-- Name: im_biz_object_group__new(integer, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, integer, integer, timestamp with time zone, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object_group__new(integer, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, integer, integer, timestamp with time zone, character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_group_id		alias for $1;
	p_group_name		alias for $2;
	p_email			alias for $3;
	p_url			alias for $4;
	p_last_modified		alias for $5;
	p_modifying_ip		alias for $6;

	p_object_type		alias for $7;
	p_context_id		alias for $8;
	p_creation_user		alias for $9;
	p_creation_date		alias for $10;
	p_creation_ip		alias for $11;
	p_join_policy		alias for $12;
	p_biz_object_id		alias for $13;

	v_group_id 		im_biz_object_groups.group_id%TYPE;
begin
	v_group_id := acs_group__new (
		p_group_id, p_object_type, 
		p_creation_date, p_creation_user, 
		p_creation_ip, p_email, 
		p_url, p_group_name, 
		p_join_policy, p_context_id
	);
	insert into im_biz_object_groups (group_id, biz_object_id) values (v_group_id, p_biz_object_id);
	return v_group_id;
end;$_$;


ALTER FUNCTION public.im_biz_object_group__new(integer, character varying, character varying, character varying, timestamp with time zone, character varying, character varying, integer, integer, timestamp with time zone, character varying, character varying, integer) OWNER TO evex;

--
-- Name: im_biz_object_member__delete(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object_member__delete(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id	alias for $1;
	p_user_id	alias for $2;

	v_rel_id	integer;
	v_skill_profile_rel_id_exists_p	integer;
BEGIN
	select	rel_id
	into	v_rel_id
	from	acs_rels
	where	object_id_one = p_object_id
		and object_id_two = p_user_id;

	-- Other rels can reference a rel...
	select count(*) into v_skill_profile_rel_id_exists_p
	from information_schema.columns 
	where table_name = 'im_biz_object_members' and column_name = 'skill_profile_rel_id';
	IF v_skill_profile_rel_id_exists_p > 0 THEN 
		update im_biz_object_members
		set skill_profile_rel_id = null
		where skill_profile_rel_id = v_rel_id;			   
	END IF;

	delete	from im_biz_object_members
	where	object_role_id = v_rel_id;

	PERFORM acs_rel__delete(v_rel_id);
	return 0;
end; $_$;


ALTER FUNCTION public.im_biz_object_member__delete(integer, integer) OWNER TO evex;

--
-- Name: im_biz_object_member__list(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object_member__list(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id	alias for $1;
	v_members	varchar;
	row		record;
BEGIN
	v_members := '';
	FOR row IN 
		select	r.rel_id,
			r.object_id_two as party_id,
			coalesce(bom.object_role_id::varchar, '""') as role_id,
			coalesce(bom.percentage::varchar, '""') as percentage
		from	acs_rels r,
			im_biz_object_members bom
		where	r.rel_id = bom.rel_id and
			r.object_id_one = p_object_id
		order by party_id
	LOOP
		IF '' != v_members THEN v_members := v_members || ' '; END IF;
		v_members := v_members || '{' || row.party_id || ' ' || row.role_id || ' ' || row.percentage || ' ' || row.rel_id || '}';
	END LOOP;

	return v_members;
end;$_$;


ALTER FUNCTION public.im_biz_object_member__list(integer) OWNER TO evex;

--
-- Name: im_biz_object_member__new(integer, character varying, integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object_member__new(integer, character varying, integer, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_rel_id		alias for $1;	-- null
	p_rel_type		alias for $2;	-- im_biz_object_member
	p_object_id		alias for $3;	-- object_id_one
	p_user_id		alias for $4;	-- object_id_two
	p_object_role_id	alias for $5;	-- type of relationship
	p_creation_user		alias for $6;	-- null
	p_creation_ip		alias for $7;	-- null
BEGIN
	return im_biz_object_member__new (
		p_rel_id, 
		p_rel_type, 
		p_object_id, 
		p_user_id, 
		p_object_role_id, 
		null, 
		p_creation_user, 
		p_creation_ip
	);
end; $_$;


ALTER FUNCTION public.im_biz_object_member__new(integer, character varying, integer, integer, integer, integer, character varying) OWNER TO evex;

--
-- Name: im_biz_object_member__new(integer, character varying, integer, integer, integer, numeric, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object_member__new(integer, character varying, integer, integer, integer, numeric, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_rel_id		alias for $1;	-- null
	p_rel_type		alias for $2;	-- im_biz_object_member
	p_object_id		alias for $3;	-- object_id_one
	p_user_id		alias for $4;	-- object_id_two
	p_object_role_id	alias for $5;	-- type of relationship
	p_percentage		alias for $6;	-- percentage of assignation
	p_creation_user		alias for $7;	-- null
	p_creation_ip		alias for $8;	-- null

	v_rel_id		integer;
	v_count			integer;
BEGIN
	select	count(*) into v_count from acs_rels
	where	object_id_one = p_object_id
		and object_id_two = p_user_id;

	IF v_count > 0 THEN 
		-- Return the lowest rel_id (might be several?)
		select	min(rel_id) into v_rel_id
		from	acs_rels
		where	object_id_one = p_object_id
			and object_id_two = p_user_id;

		return v_rel_id;
	END IF;

	v_rel_id := acs_rel__new (
		p_rel_id,
		p_rel_type,	
		p_object_id,
		p_user_id,
		p_object_id,
		p_creation_user,
		p_creation_ip
	);

	insert into im_biz_object_members (
		rel_id, object_role_id, percentage
	) values (
		v_rel_id, p_object_role_id, p_percentage
	);

	return v_rel_id;
end; $_$;


ALTER FUNCTION public.im_biz_object_member__new(integer, character varying, integer, integer, integer, numeric, integer, character varying) OWNER TO evex;

--
-- Name: im_biz_object_pm__list(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_biz_object_pm__list(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id	alias for $1;
	v_members	varchar;
	row		record;
BEGIN
	v_members := '';
	FOR row IN 
		select	r.rel_id,
			r.object_id_two as party_id,
			coalesce(bom.object_role_id::varchar, '""') as role_id,
			coalesce(bom.percentage::varchar, '""') as percentage
		from	acs_rels r,
			im_biz_object_members bom
		where	r.rel_id = bom.rel_id and
			r.object_id_one = p_object_id and
			bom.object_role_id = 1301
		order by party_id
	LOOP
		IF '' != v_members THEN v_members := v_members || ' '; END IF;
		v_members := v_members || '{' || row.party_id || ' ' || row.role_id || ' ' || row.percentage || ' ' || row.rel_id || '}';
	END LOOP;

	return v_members;
end;$_$;


ALTER FUNCTION public.im_biz_object_pm__list(integer) OWNER TO evex;

--
-- Name: im_boolean_from_id(boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_boolean_from_id(boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_boolean	alias for $1;
	v_result	varchar;
BEGIN
	v_result := p_boolean;
	IF true = p_boolean THEN v_result := 'true'; END IF;
	IF false = p_boolean THEN v_result := 'false'; END IF;
	return v_result;
END;$_$;


ALTER FUNCTION public.im_boolean_from_id(boolean) OWNER TO evex;

--
-- Name: im_boolean_from_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_boolean_from_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_boolean	alias for $1;
	v_result	varchar;
BEGIN
	v_result := p_boolean;
	IF 1 = p_boolean THEN v_result := 'true'; END IF;
	IF 0 = p_boolean THEN v_result := 'false'; END IF;
	return v_result;
END;$_$;


ALTER FUNCTION public.im_boolean_from_id(integer) OWNER TO evex;

--
-- Name: im_boolean_from_id(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_boolean_from_id(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_boolean	alias for $1;
	v_result	varchar;
BEGIN
	v_result := p_boolean;
	IF 't' = lower(p_boolean) THEN v_result := 'true'; END IF;
	IF 'f' = lower(p_boolean) THEN v_result := 'false'; END IF;
	IF '1' = lower(p_boolean) THEN v_result := 'true'; END IF;
	IF '0' = lower(p_boolean) THEN v_result := 'false'; END IF;
	return v_result;
END;$_$;


ALTER FUNCTION public.im_boolean_from_id(character varying) OWNER TO evex;

--
-- Name: im_category__new(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category__new(integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_category_id           alias for $1;
        p_category              alias for $2;
        p_category_type         alias for $3;
        p_description           alias for $4;
BEGIN
        RETURN im_category_new(p_category_id, p_category, p_category_type, p_description);
end;$_$;


ALTER FUNCTION public.im_category__new(integer, character varying, character varying, character varying) OWNER TO evex;

--
-- Name: im_category_find_next_free_id_in_sequence(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_find_next_free_id_in_sequence(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        p_start_seq_id          alias for $1;
        p_stop_seq_id        	alias for $2;
	v_count			integer;
	v_category_id		integer;
begin

	-- how many in sequence
	select count(*) into v_count from im_categories where category_id > p_start_seq_id and category_id <= p_stop_seq_id; 

	-- none used, return seq_start 
        IF 0 = v_count THEN return p_start_seq_id; END IF;

	-- none available in sequence, return 0 
	IF v_count = (p_stop_seq_id-p_start_seq_id +1) THEN return 0; END IF; 
	
	-- there should be at least one free id in sequence, find it: 
	FOR i IN p_start_seq_id .. p_stop_seq_id LOOP
		select count(*) into v_category_id from im_categories where category_id = i; 
		IF v_category_id = 0 THEN return i; END IF; 
	END LOOP; 
 
end;$_$;


ALTER FUNCTION public.im_category_find_next_free_id_in_sequence(integer, integer) OWNER TO evex;

--
-- Name: im_category_from_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_from_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_category_id	alias for $1;
	v_category	varchar(50);
BEGIN
	select category
	into v_category
	from im_categories
	where category_id = p_category_id;

	return v_category;
end;$_$;


ALTER FUNCTION public.im_category_from_id(integer) OWNER TO evex;

--
-- Name: im_category_hierarchy_new(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_hierarchy_new(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_child_id		alias for $1;
	p_parent_id		alias for $2;

	row			RECORD;
	v_count			integer;
BEGIN
	IF p_child_id is null THEN 
		RAISE NOTICE 'im_category_hierarchy_new: bad category 1: "%" ',p_child_id;
		return 0;
	END IF;

	IF p_parent_id is null THEN 
		RAISE NOTICE 'im_category_hierarchy_new: bad category 2: "%" ',p_parent_id; 
		return 0;
	END IF;
	IF p_child_id = p_parent_id THEN return 0; END IF;

	select	count(*) into v_count from im_category_hierarchy
	where	child_id = p_child_id and parent_id = p_parent_id;
	IF v_count = 0 THEN
		insert into im_category_hierarchy(child_id, parent_id)
		values (p_child_id, p_parent_id);
	END IF;

	-- Loop through the parents of the parent
	FOR row IN
		select	parent_id
		from	im_category_hierarchy
		where	child_id = p_parent_id
	LOOP
		PERFORM im_category_hierarchy_new (p_child_id, row.parent_id);
	END LOOP;

	RETURN 0;
end;$_$;


ALTER FUNCTION public.im_category_hierarchy_new(integer, integer) OWNER TO evex;

--
-- Name: im_category_hierarchy_new(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_hierarchy_new(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_child			alias for $1;
	p_parent		alias for $2;
	p_cat_type		alias for $3;

	v_child_id		integer;
	v_parent_id		integer;
BEGIN
	select	category_id into v_child_id from im_categories
	where	category = p_child and category_type = p_cat_type;
	IF v_child_id is null THEN 
		RAISE NOTICE 'im_category_hierarchy_new: bad category 1: "%" ',p_child; 
		return 0;
	END IF;

	select	category_id into v_parent_id from im_categories
	where	category = p_parent and category_type = p_cat_type;
	IF v_parent_id is null THEN 
		RAISE NOTICE 'im_category_hierarchy_new: bad category 2: "%" ',p_parent; 
		return 0;
	END IF;

	return im_category_hierarchy_new (v_child_id, v_parent_id);
end;$_$;


ALTER FUNCTION public.im_category_hierarchy_new(character varying, character varying, character varying) OWNER TO evex;

--
-- Name: im_category_min_parent(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_min_parent(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_cat			alias for $1;
	v_cat			integer;
BEGIN
	select	min(c.category_id) into v_cat
	from	im_categories c,
		im_category_hierarchy h
	where	c.category_id = h.parent_id and
		h.child_id = p_cat and
		(c.enabled_p = 't' OR c.enabled_p is NULL);

	RETURN v_cat;
end;$_$;


ALTER FUNCTION public.im_category_min_parent(integer) OWNER TO evex;

--
-- Name: im_category_new(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_new(integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_category_id		alias for $1;
	p_category		alias for $2;
	p_category_type		alias for $3;
BEGIN
	RETURN im_category_new(p_category_id, p_category, p_category_type, NULL);
end;$_$;


ALTER FUNCTION public.im_category_new(integer, character varying, character varying) OWNER TO evex;

--
-- Name: im_category_new(integer, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_new(integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_category_id		alias for $1;
	p_category		alias for $2;
	p_category_type		alias for $3;
	p_description		alias for $4;

	v_count			integer;
BEGIN
	select	count(*) into v_count from im_categories
	where	(category = p_category and category_type = p_category_type) OR
		category_id = p_category_id;
	IF v_count > 0 THEN return 0; END IF;

	insert into im_categories(category_id, category, category_type, category_description)
	values (p_category_id, p_category, p_category_type, p_description);

	RETURN 0;
end;$_$;


ALTER FUNCTION public.im_category_new(integer, character varying, character varying, character varying) OWNER TO evex;

--
-- Name: im_category_parents(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_parents(integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_cat			alias for $1;
	v_cat			integer;
	row			RECORD;
BEGIN
	FOR row IN
		select	c.category_id
		from	im_categories c,
			im_category_hierarchy h
		where	c.category_id = h.parent_id and
			h.child_id = p_cat and
			(c.enabled_p = 't' OR c.enabled_p is NULL)
	LOOP
		RETURN NEXT row.category_id;
	END LOOP;
	RETURN;
end;$_$;


ALTER FUNCTION public.im_category_parents(integer) OWNER TO evex;

--
-- Name: im_category_path_to_category(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_path_to_category(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN im_category_path_to_category($1,0);
END;$_$;


ALTER FUNCTION public.im_category_path_to_category(integer) OWNER TO evex;

--
-- Name: im_category_path_to_category(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_category_path_to_category(integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
	p_cat_id		alias for $1;
	p_loop			alias for $2;
	v_cat			varchar;
	v_path			varchar;
	v_longest_path		varchar;
	row			RECORD;
BEGIN
	-- Avoid infinite loops...
	IF p_loop > 5 THEN return ''; END IF;

	-- Add leading zeros until code has 8 digits.
	-- This way all category codes have the same length.
	v_cat := p_cat_id;
	WHILE length(v_cat) < 8 LOOP v_cat := '0'||v_cat; END LOOP;

	-- Look out for the parent with the longest path
	v_longest_path := '';
	FOR row IN
		-- Get all (enabled) parents
		select	ch.parent_id
		from	im_category_hierarchy ch,
			im_categories c
		where	ch.child_id = p_cat_id and
			ch.parent_id = c.category_id and
			ch.parent_id != p_cat_id and
			(c.enabled_p is null or c.enabled_p = 't')
	LOOP
		v_path = im_category_path_to_category(row.parent_id, p_loop+1);
		IF v_longest_path = '' THEN v_longest_path := v_path; END IF;
		IF length(v_path) > length(v_longest_path) THEN v_longest_path := v_path; END IF;
	END LOOP;

	RETURN v_longest_path || v_cat;
end;$_$;


ALTER FUNCTION public.im_category_path_to_category(integer, integer) OWNER TO evex;

--
-- Name: im_company__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_company__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_company_id	     alias for $1;

	v_office_id	     integer;
BEGIN
	-- make sure to remove links from all offices to this company.
	update im_offices
	set company_id = null
	where company_id = p_company_id;

	-- Erase the im_companies item associated with the id
	delete from im_companies
	where company_id = p_company_id;

	-- Delete entry from parties
	delete from parties where party_id = p_company_id;

	-- Erase all the priviledges
	delete from 	acs_permissions
	where		object_id = p_company_id;

	-- Delete context references to this company
	update acs_objects set
		context_id = null
	where
		context_id = p_company_id;

	-- Delete the acs_object
	PERFORM acs_object__delete(p_company_id);

	return 0;
end;$_$;


ALTER FUNCTION public.im_company__delete(integer) OWNER TO evex;

--
-- Name: im_company__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_company__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_company_id	alias for $1;
	v_name		varchar;
BEGIN
	select	company_name
	into	v_name
	from	im_companies
	where	company_id = p_company_id;

	return v_name;
end;$_$;


ALTER FUNCTION public.im_company__name(integer) OWNER TO evex;

--
-- Name: im_company__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_company__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_company_id      alias for $1;
	p_object_type     alias for $2;
	p_creation_date   alias for $3;
	p_creation_user   alias for $4;
	p_creation_ip     alias for $5;
	p_context_id      alias for $6;

	p_company_name	      alias for $7;
	p_company_path	      alias for $8;
	p_main_office_id      alias for $9;
	p_company_type_id     alias for $10;
	p_company_status_id   alias for $11;

	v_company_id	      integer;
BEGIN
	v_company_id := acs_object__new (
		p_company_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

	insert into im_companies (
		company_id, company_name, company_path, 
		company_type_id, company_status_id, main_office_id
	) values (
		v_company_id, p_company_name, p_company_path, 
		p_company_type_id, p_company_status_id, p_main_office_id
	);

	-- Make a party - required for contacts
	insert into parties (party_id) values (v_company_id);
	insert into im_biz_objects (object_id) values (v_company_id);

	-- Set the link back from the office to the company
	update	im_offices
	set	company_id = v_company_id
	where	office_id = p_main_office_id;

	return v_company_id;
end;$_$;


ALTER FUNCTION public.im_company__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, integer) OWNER TO evex;

--
-- Name: im_company_employee_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_company_employee_rel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_rel_id	alias for $1;
BEGIN
	delete	from im_company_employee_rels
	where	rel_id = p_rel_id;

	PERFORM acs_rel__delete(p_rel_id);
	return 0;
end;$_$;


ALTER FUNCTION public.im_company_employee_rel__delete(integer) OWNER TO evex;

--
-- Name: im_company_employee_rel__new(integer, character varying, integer, integer, integer, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_company_employee_rel__new(integer, character varying, integer, integer, integer, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_rel_id		alias for $1;	-- null
	p_rel_type		alias for $2;	-- im_company_employee_rel
	p_object_id_one		alias for $3;
	p_object_id_two		alias for $4;
	p_context_id		alias for $5;
	p_creation_user		alias for $6;	-- null
	p_creation_ip		alias for $7;	-- null

	v_rel_id	integer;
BEGIN
	v_rel_id := acs_rel__new (
		p_rel_id,
		p_rel_type,
		p_object_id_one,
		p_object_id_two,
		p_context_id,
		p_creation_user,
		p_creation_ip
	);

	insert into im_company_employee_rels (
	       rel_id, sort_order
	) values (
	       v_rel_id, p_sort_order
	);

	return v_rel_id;
end;$_$;


ALTER FUNCTION public.im_company_employee_rel__new(integer, character varying, integer, integer, integer, integer, character varying, integer) OWNER TO evex;

--
-- Name: im_company_list_for_user_html(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_company_list_for_user_html(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_user_id	alias for $1;

	v_html		varchar;
	row		RECORD;
BEGIN
	v_html := '';
	FOR row IN
		select	c.company_id
		from	im_companies c,
			acs_rels r
		where	r.object_id_one = c.company_id and
			r.object_id_two = p_user_id
		order by
			lower(c.company_name)
	LOOP
		IF '' != v_html THEN v_html := v_html || ' '; END IF;
		v_html := v_html || row.company_id;
	END LOOP;

	return v_html;
end;$_$;


ALTER FUNCTION public.im_company_list_for_user_html(integer) OWNER TO evex;

--
-- Name: im_component_plugin__del_module(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_component_plugin__del_module(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_module_name	alias for $1;
	row		RECORD;
BEGIN
	for row in 
		select plugin_id
		from im_component_plugins
		where package_name = p_module_name
	loop
		delete from im_component_plugin_user_map
		where plugin_id = row.plugin_id;

		PERFORM im_component_plugin__delete(row.plugin_id);
	end loop;

	return 0;
end;$_$;


ALTER FUNCTION public.im_component_plugin__del_module(character varying) OWNER TO evex;

--
-- Name: im_component_plugin__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_component_plugin__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_plugin_id	alias for $1;
BEGIN
	-- Delete references to object per user
	delete from	im_component_plugin_user_map
	where		plugin_id = p_plugin_id;

	-- Erase the im_component_plugins item associated with the id
	delete from 	im_component_plugins
	where		plugin_id = p_plugin_id;

	-- Erase all the priviledges
	delete from 	acs_permissions
	where		object_id = p_plugin_id;

	PERFORM acs_object__delete(p_plugin_id);

	return 0;
end;$_$;


ALTER FUNCTION public.im_component_plugin__delete(integer) OWNER TO evex;

--
-- Name: im_component_plugin__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_component_plugin__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_plugin_id	alias for $1;
	v_name		varchar(200);
BEGIN
	select	page_url || '.' || location
	into	v_name
	from	im_component_plugins
	where	plugin_id = p_plugin_id;

	return v_name;
end;$_$;


ALTER FUNCTION public.im_component_plugin__name(integer) OWNER TO evex;

--
-- Name: im_component_plugin__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_component_plugin__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_plugin_id	alias for $1;	-- default null
	p_object_type	alias for $2;	-- default 'im_component_plugin'
	p_creation_date	alias for $3;	-- default now()
	p_creation_user	alias for $4;	-- default null
	p_creation_ip	alias for $5;	-- default null
	p_context_id	alias for $6;	-- default null
	p_plugin_name	alias for $7;
	p_package_name	alias for $8;
	p_location	alias for $9;
	p_page_url	alias for $10;
	p_view_name	alias for $11;
	p_sort_order	alias for $12;
	p_component_tcl	alias for $13;

	v_plugin_id	integer;
begin
	v_plugin_id := im_component_plugin__new (
		p_plugin_id, p_object_type, p_creation_date,
		p_creation_user, p_creation_ip, p_context_id,
		p_plugin_name, p_package_name,
		p_location, p_page_url,
		p_view_name, p_sort_order,
		p_component_tcl, null
	);
	return v_plugin_id;
end;$_$;


ALTER FUNCTION public.im_component_plugin__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, integer, character varying) OWNER TO evex;

--
-- Name: im_component_plugin__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_component_plugin__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_plugin_id	alias for $1;		-- default null
	p_object_type	alias for $2;		-- default 'im_component_plugin'
	p_creation_date	alias for $3;		-- default now()
	p_creation_user	alias for $4;		-- default null
	p_creation_ip	alias for $5;		-- default null
	p_context_id	alias for $6;		-- default null

	p_plugin_name	alias for $7;
	p_package_name	alias for $8;
	p_location	alias for $9;
	p_page_url	alias for $10;
	p_view_name	alias for $11;		-- default null
	p_sort_order	alias for $12;
	p_component_tcl	alias for $13;
	p_title_tcl	alias for $14;

	v_plugin_id	im_component_plugins.plugin_id%TYPE;
	v_count		integer;
begin
	select count(*) into v_count from im_component_plugins
	where plugin_name = p_plugin_name;
	IF v_count > 0 THEN return 0; END IF;

	v_plugin_id := acs_object__new (
		p_plugin_id,			-- object_id
		p_object_type,			-- object_type
		p_creation_date,		-- creation_date
		p_creation_user,		-- creation_user
		p_creation_ip,			-- creation_ip
		p_context_id			-- context_id
	);

	insert into im_component_plugins (
		plugin_id, plugin_name, package_name, sort_order, 
		view_name, page_url, location, 
		component_tcl, title_tcl
	) values (
		v_plugin_id, p_plugin_name, p_package_name, p_sort_order, 
		p_view_name, p_page_url, p_location, 
		p_component_tcl, p_title_tcl
	);

	return v_plugin_id;
end;$_$;


ALTER FUNCTION public.im_component_plugin__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying) OWNER TO evex;

--
-- Name: im_country_from_code(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_country_from_code(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_cc		alias for $1;
        v_country	varchar;
BEGIN
    select country_name
    into v_country
    from country_codes
    where iso = p_cc;

    return v_country;
END;$_$;


ALTER FUNCTION public.im_country_from_code(character varying) OWNER TO evex;

--
-- Name: im_create_profile(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_create_profile(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_pretty_name	alias for $1;
	v_profile_gif	alias for $2;

	v_group_id	integer;
	v_rel_id	integer;
	n_groups	integer;
	v_category_id   integer;
BEGIN
	-- Check that the group does not exist before
	select	count(*) into n_groups from groups where group_name = v_pretty_name;

	-- only add the group if it did not exist before...
	IF n_groups = 0 THEN
		v_group_id := im_profile__new(v_pretty_name, v_profile_gif);
	
		v_rel_id := composition_rel__new (
			null,				-- rel_id
			'composition_rel',		-- rel_type
			-2,				-- object_id_one
			v_group_id,			-- object_id_two
			0,				-- creation_user
			null				-- creation_ip
		);
		
		select nextval('t_acs_object_id_seq') into v_category_id from dual;
	
		-- Add the group to the Intranet User Type categories
		perform im_category_new (
			v_category_id,			-- category_id
			v_pretty_name, 			-- category
			'Intranet User Type',		-- category_type
			null	   			-- description
		);
	
		update im_categories set aux_int1 = v_group_id where category_id = v_category_id;

	END IF;
	return 0;
end;$_$;


ALTER FUNCTION public.im_create_profile(character varying, character varying) OWNER TO evex;

--
-- Name: im_day_enumerator(date, date); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_day_enumerator(date, date) RETURNS SETOF date
    LANGUAGE plpgsql
    AS $_$
declare
	p_start_date		alias for $1;
	p_end_date		alias for $2;
	v_date			date;
BEGIN
	v_date := p_start_date;
	WHILE (v_date < p_end_date) LOOP
		RETURN NEXT v_date;
		v_date := v_date + 1;
	END LOOP;
	RETURN;
end;$_$;


ALTER FUNCTION public.im_day_enumerator(date, date) OWNER TO evex;

--
-- Name: im_day_enumerator_weekdays(date, date); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_day_enumerator_weekdays(date, date) RETURNS SETOF date
    LANGUAGE plpgsql
    AS $_$
declare
	p_start_date		alias for $1;
	p_end_date		alias for $2;
	v_date			date;
	v_weekday		integer;
BEGIN
	v_date := p_start_date;
	WHILE (v_date < p_end_date) LOOP

		v_weekday := to_char(v_date, 'D');
		IF v_weekday != 1 AND v_weekday != 7 THEN
			RETURN NEXT v_date;
		END IF;
		v_date := v_date + 1;
	END LOOP;
	RETURN;
end;$_$;


ALTER FUNCTION public.im_day_enumerator_weekdays(date, date) OWNER TO evex;

--
-- Name: im_drop_profile(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_drop_profile(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	row		RECORD;
	v_pretty_name	alias for $1;
	v_group_id	integer;
BEGIN
	-- Check that the group does not exist before
	select	group_id
	into	v_group_id
	from	groups
	where	group_name = v_pretty_name;

	-- First we need to remove this dependency ...
	delete from im_profiles where profile_id = v_group_id;
	delete from acs_permissions where grantee_id=v_group_id;
	-- the acs_group package takes care of segments referred
	-- to by rel_constraints__rel_segment. We delete the ones
	-- references by rel_constraints__required_rel_segment here.
	for row in
		select	cons.constraint_id
		from	rel_constraints cons, rel_segments segs
		where	segs.segment_id = cons.required_rel_segment
			and segs.group_id = v_group_id
	loop
		PERFORM rel_segment__delete(row.constraint_id);
	end loop;

	-- delete the actual group
	PERFORM im_profile__delete(v_group_id);

	-- now delete the category
	delete from im_categories where category = v_pretty_name and category_type = 'Intranet User Type';

	return 0;
end;$_$;


ALTER FUNCTION public.im_drop_profile(character varying) OWNER TO evex;

--
-- Name: im_dynfield_attribute__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_attribute_id		alias for $1;

	v_acs_attribute_id	integer;
	v_acs_attribute_name	varchar;
	v_object_type		varchar;
BEGIN
	-- get the acs_attribute_id and object_type
	select
		fa.acs_attribute_id, 
		aa.object_type,
		aa.attribute_name
	into 
		v_acs_attribute_id, 
		v_object_type,
		v_acs_attribute_name
	from
		im_dynfield_attributes fa,
		acs_attributes aa
	where
		aa.attribute_id = fa.acs_attribute_id
		and fa.attribute_id = p_attribute_id;

	-- Erase the im_dynfield_attributes item associated with the id
	delete from im_dynfield_layout
	where attribute_id = p_attribute_id;

	-- Erase values for the im_dynfield_attribute item associated with the id
	delete from im_dynfield_attr_multi_value
	where attribute_id = p_attribute_id;

	delete from im_dynfield_attributes
	where attribute_id = p_attribute_id;

	PERFORM acs_attribute__drop_attribute(v_object_type, v_acs_attribute_name);
	return 0;
end;$_$;


ALTER FUNCTION public.im_dynfield_attribute__del(integer) OWNER TO evex;

--
-- Name: im_dynfield_attribute__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_attribute_id		alias for $1;
BEGIN
	-- Erase the mapping of im_dynfield_attributes to object sub-types
	delete from im_dynfield_type_attribute_map
	where attribute_id = p_attribute_id;

	-- Erase all the privileges
	delete from acs_permissions
	where object_id = p_attribute_id;

	-- Erase im_dynfield_layout
	delete from im_dynfield_layout
	where attribute_id = p_attribute_id;

	delete from im_dynfield_attributes
	where attribute_id = p_attribute_id;

	PERFORM acs_object__delete(p_attribute_id);
	return 0;
end;$_$;


ALTER FUNCTION public.im_dynfield_attribute__delete(integer) OWNER TO evex;

--
-- Name: im_dynfield_attribute__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_attribute_id		alias for $1;
	v_name			varchar;
	v_acs_attribute_id	integer;
BEGIN
	-- get the acs_attribute_id
	select	acs_attribute_id
	into	v_acs_attribute_id
	from	im_dynfield_attributes
	where	attribute_id = p_attribute_id;

	select	attribute_name
	into	v_name
	from	acs_attributes
	where	attribute_id = v_acs_attribute_id;

	return v_name;
end;$_$;


ALTER FUNCTION public.im_dynfield_attribute__name(integer) OWNER TO evex;

--
-- Name: im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, integer, character varying, character, character); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, integer, character varying, character, character) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_attribute_id		alias for $1;
	p_object_type		alias for $2;
	p_creation_date 	alias for $3;
	p_creation_user 	alias for $4;
	p_creation_ip		alias for $5;
	p_context_id		alias for $6;

	p_acs_attribute_id	alias for $7;
	p_widget_name		alias for $8;
	p_deprecated_p		alias for $9;
	p_already_existed_p	alias for $10;

	v_attribute_id		integer;
BEGIN
	v_attribute_id := acs_object__new (
		p_attribute_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

	insert into im_dynfield_attributes (
		attribute_id, acs_attribute_id, widget_name,
		deprecated_p, already_existed_p
	) values (
		v_attribute_id, p_acs_attribute_id, p_widget_name,
		p_deprecated_p, p_already_existed_p
	);
	return v_attribute_id;
end;$_$;


ALTER FUNCTION public.im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, integer, character varying, character, character) OWNER TO evex;

--
-- Name: im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, integer, character varying, character, character, integer, character varying, character, character); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, integer, character varying, character, character, integer, character varying, character, character) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_attribute_id		alias for $1;
	p_object_type		alias for $2;
	p_creation_date		alias for $3;
	p_creation_user		alias for $4;
	p_creation_ip		alias for $5;
	p_context_id		alias for $6;

	p_acs_attribute_id	alias for $7;
	p_widget_name		alias for $8;
	p_deprecated_p		alias for $9;
	p_already_existed_p	alias for $10;
	p_pos_y			alias for $11;
	p_label_style		alias for $12;
	p_also_hard_coded_p	alias for $13;
	p_include_in_search_p	alias for $14;

	v_attribute_id		integer;
	v_count			integer;
	v_type_category		varchar;
	row			RECORD;
BEGIN
	v_attribute_id := acs_object__new (
		p_attribute_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

	insert into im_dynfield_attributes (
		attribute_id, acs_attribute_id, widget_name, also_hard_coded_p,
		deprecated_p, already_existed_p, include_in_search_p
	) values (
		v_attribute_id, p_acs_attribute_id, p_widget_name, p_also_hard_coded_p,
		p_deprecated_p, p_already_existed_p, p_include_in_search_p
	);

	insert into im_dynfield_layout (
		attribute_id, page_url, pos_y, label_style
	) values (
		v_attribute_id, 'default', p_pos_y, p_label_style
	);

	-- set all im_dynfield_type_attribute_map to "edit"
	select type_category_type into v_type_category from acs_object_types
	where object_type = p_object_type;
	FOR row IN
		select	category_id
		from	im_categories
		where	category_type = v_type_category
	LOOP
		select	count(*) into v_count from im_dynfield_type_attribute_map
		where	object_type_id = row.category_id and attribute_id = v_attribute_id;
		IF 0 = v_count THEN
			insert into im_dynfield_type_attribute_map (
				attribute_id, object_type_id, display_mode
			) values (
				v_attribute_id, row.category_id, 'edit'
			);
		END IF;
	END LOOP;

	PERFORM acs_permission__grant_permission(v_attribute_id, (select group_id from groups where group_name='Employees'), 'read');
	PERFORM acs_permission__grant_permission(v_attribute_id, (select group_id from groups where group_name='Employees'), 'write');
	PERFORM acs_permission__grant_permission(v_attribute_id, (select group_id from groups where group_name='Customers'), 'read');
	PERFORM acs_permission__grant_permission(v_attribute_id, (select group_id from groups where group_name='Customers'), 'write');
	PERFORM acs_permission__grant_permission(v_attribute_id, (select group_id from groups where group_name='Freelancers'), 'read');
	PERFORM acs_permission__grant_permission(v_attribute_id, (select group_id from groups where group_name='Freelancers'), 'write');

	return v_attribute_id;
end;$_$;


ALTER FUNCTION public.im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, integer, character varying, character, character, integer, character varying, character, character) OWNER TO evex;

--
-- Name: im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, character varying, character varying, character varying, character varying, character varying, character, character); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, character varying, character varying, character varying, character varying, character varying, character, character) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_attribute_id		alias for $1;
	p_object_type		alias for $2;
	p_creation_date 	alias for $3;
	p_creation_user 	alias for $4;
	p_creation_ip		alias for $5;
	p_context_id		alias for $6;

	p_attribute_object_type	alias for $7;
	p_attribute_name	alias for $8;
	p_min_n_values		alias for $9;
	p_max_n_values		alias for $10;
	p_default_value		alias for $11;

	p_datatype		alias for $12;
	p_pretty_name		alias for $13;
	p_pretty_plural		alias for $14;
	p_widget_name		alias for $15;
	p_deprecated_p		alias for $16;
	p_already_existed_p	alias for $17;

	v_table_name		varchar;
BEGIN
	select table_name into v_table_name
	from acs_object_types where object_type = p_attribute_object_type;

	return im_dynfield_attribute__new (
		p_attribute_id, p_object_type, p_creation_date, p_creation_user, p_creation_ip, p_context_id,
		p_attribute_object_type, p_attribute_name, p_min_n_values, p_max_n_values, p_default_value,
		p_datatype, p_pretty_name, p_pretty_plural, p_widget_name, p_deprecated_p, p_already_existed_p, v_table_name
	);

end;$_$;


ALTER FUNCTION public.im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, character varying, character varying, character varying, character varying, character varying, character, character) OWNER TO evex;

--
-- Name: im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_attribute_id		alias for $1;
	p_object_type		alias for $2;
	p_creation_date 	alias for $3;
	p_creation_user 	alias for $4;
	p_creation_ip		alias for $5;
	p_context_id		alias for $6;

	p_attribute_object_type	alias for $7;
	p_attribute_name	alias for $8;
	p_min_n_values		alias for $9;
	p_max_n_values		alias for $10;
	p_default_value		alias for $11;

	p_datatype		alias for $12;
	p_pretty_name		alias for $13;
	p_pretty_plural		alias for $14;
	p_widget_name		alias for $15;
	p_deprecated_p		alias for $16;
	p_already_existed_p	alias for $17;
	p_table_name		alias for $18;

	v_acs_attribute_id	integer;
	v_attribute_id		integer;
BEGIN
	-- Check for a duplicate acs_attributes + im_dynfield_attributes pair
	select	da.attribute_id into v_attribute_id
	from	acs_attributes aa, im_dynfield_attributes da 
	where	aa.attribute_id = da.acs_attribute_id and
		aa.attribute_name = p_attribute_name and aa.object_type = p_attribute_object_type;
	IF v_attribute_id is not null THEN RETURN v_attribute_id; END IF;

	-- Make sure the acs_attribute is present.
	-- Avoid errors with strange rests of acs_attributes in the DB
	select	attribute_id into v_acs_attribute_id
	from	acs_attributes
	where	object_type = p_attribute_object_type and
		attribute_name = p_attribute_name;
	IF v_acs_attribute_id is null THEN
		v_acs_attribute_id := acs_attribute__create_attribute (
			p_attribute_object_type,
			p_attribute_name,
			p_datatype,
			p_pretty_name,
			p_pretty_plural,
			p_table_name,		-- table_name
			null,			-- column_name
			p_default_value,
			p_min_n_values,
			p_max_n_values,
			null,			-- sort order
			'type_specific',	-- storage
			'f'			-- static_p
		);
	END IF;

	v_attribute_id := acs_object__new (
		p_attribute_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

	insert into im_dynfield_attributes (
		attribute_id, acs_attribute_id, widget_name,
		deprecated_p, already_existed_p
	) values (
		v_attribute_id, v_acs_attribute_id, p_widget_name,
		p_deprecated_p, p_already_existed_p
	);

	-- By default show the field for all object types
	insert into im_dynfield_type_attribute_map (attribute_id, object_type_id, display_mode)
	select	ida.attribute_id,
		c.category_id,
		'edit'
	from	im_dynfield_attributes ida,
		acs_attributes aa,
		acs_object_types aot,
		im_categories c
	where	ida.acs_attribute_id = aa.attribute_id and
		aa.object_type = aot.object_type and
		aot.type_category_type = c.category_type and
		aot.object_type = p_attribute_object_type and
		aa.attribute_name = p_attribute_name;

	return v_attribute_id;
end;$_$;


ALTER FUNCTION public.im_dynfield_attribute__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, character varying, character varying, character varying, character varying, character varying, character, character, character varying) OWNER TO evex;

--
-- Name: im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN im_dynfield_attribute_new($1,$2,$3,$4,$5,$6,null,'f');
END;$_$;


ALTER FUNCTION public.im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character) OWNER TO evex;

--
-- Name: im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character, integer, character); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character, integer, character) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_type		alias for $1;
	p_column_name		alias for $2;
	p_pretty_name		alias for $3;
	p_widget_name		alias for $4;
	p_datatype		alias for $5;
	p_required_p		alias for $6;
	p_pos_y			alias for $7;
	p_also_hard_coded_p	alias for $8;

	v_table_name		varchar;
BEGIN
	select table_name into v_table_name
	from acs_object_types where object_type = p_object_type;
	RETURN im_dynfield_attribute_new($1,$2,$3,$4,$5,$6,$7,$8,v_table_name);
END;$_$;


ALTER FUNCTION public.im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character, integer, character) OWNER TO evex;

--
-- Name: im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character, integer, character, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character, integer, character, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_type		alias for $1;
	p_column_name		alias for $2;
	p_pretty_name		alias for $3;
	p_widget_name		alias for $4;
	p_datatype		alias for $5;
	p_required_p		alias for $6;
	p_pos_y			alias for $7;
	p_also_hard_coded_p	alias for $8;
	p_table_name		alias for $9;

	v_dynfield_id		integer;
	v_widget_id		integer;
	v_type_category		varchar;
	row			RECORD;
	v_count			integer;
	v_min_n_value		integer;
BEGIN
	-- Make sure the specified widget is available
	select	widget_id into v_widget_id from im_dynfield_widgets
	where	widget_name = p_widget_name;
	IF v_widget_id is null THEN return 1; END IF;

	select	count(*) from im_dynfield_attributes into v_count
	where	acs_attribute_id in (
			select	attribute_id 
			from	acs_attributes 
			where	attribute_name = p_column_name and
				object_type = p_object_type
		);
	IF v_count > 0 THEN return 1; END IF;

	v_min_n_value := 0;
	IF p_required_p = 't' THEN v_min_n_value := 1; END IF;

	v_dynfield_id := im_dynfield_attribute__new (
		null, 'im_dynfield_attribute', now(), 0, '0.0.0.0', null,
		p_object_type, p_column_name, v_min_n_value, 1, null,
		p_datatype, p_pretty_name, p_pretty_name, p_widget_name,
		'f', 'f', p_table_name
	);

	update im_dynfield_attributes set also_hard_coded_p = p_also_hard_coded_p
	where attribute_id = v_dynfield_id;

	-- Insert a layout entry into the default page
	select	count(*) into v_count
	from	im_dynfield_layout
	where	attribute_id = v_dynfield_id and page_url = 'default';

	IF 0 = v_count THEN
		insert into im_dynfield_layout (
			attribute_id, page_url, pos_y, label_style
		) values (
			v_dynfield_id, 'default', p_pos_y, 'plain'
		);
	END IF;


	-- set all im_dynfield_type_attribute_map to "edit"
	select type_category_type into v_type_category from acs_object_types
	where object_type = p_object_type;
	FOR row IN
		select	category_id
		from	im_categories
		where	category_type = v_type_category
	LOOP
		select	count(*) into v_count from im_dynfield_type_attribute_map
		where	object_type_id = row.category_id and attribute_id = v_dynfield_id;
		IF 0 = v_count THEN
			insert into im_dynfield_type_attribute_map (
				attribute_id, object_type_id, display_mode
			) values (
				v_dynfield_id, row.category_id, 'edit'
			);
		END IF;
	END LOOP;

	PERFORM acs_permission__grant_permission(v_dynfield_id, (select group_id from groups where group_name='Employees'), 'read');
	PERFORM acs_permission__grant_permission(v_dynfield_id, (select group_id from groups where group_name='Employees'), 'write');
	PERFORM acs_permission__grant_permission(v_dynfield_id, (select group_id from groups where group_name='Customers'), 'read');
	PERFORM acs_permission__grant_permission(v_dynfield_id, (select group_id from groups where group_name='Customers'), 'write');
	PERFORM acs_permission__grant_permission(v_dynfield_id, (select group_id from groups where group_name='Freelancers'), 'read');
	PERFORM acs_permission__grant_permission(v_dynfield_id, (select group_id from groups where group_name='Freelancers'), 'write');

	RETURN v_dynfield_id;
END;$_$;


ALTER FUNCTION public.im_dynfield_attribute_new(character varying, character varying, character varying, character varying, character varying, character, integer, character, character varying) OWNER TO evex;

--
-- Name: im_dynfield_multimap_val_to_str(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_multimap_val_to_str(integer, integer, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_attr_id		alias for $1;
	p_obj_id		alias for $2;
	p_widget_type		alias for $3;

	v_ret_string		varchar;
	v_value			im_dynfield_attr_multi_value.value%TYPE;
	v_cat_name		varchar;
	row			RECORD;
BEGIN
	v_ret_string := null;
	FOR row IN
		SELECT	v_value
		FROM	im_dynfield_attr_multi_value
		WHERE	attribute_id = p_attr_id
			AND object_id = p_obj_id
			AND value is not null
	LOOP 
		if v_ret_string is not null then 
			v_ret_string := v_ret_string || ', ';
		end if; 
	
		if widget_type = 'category_tree' then
			select category.name(row.v_value) into v_cat_name from dual;
			v_ret_string := v_ret_string || v_cat_name;
		else
			v_ret_string := v_ret_string || row.v_value;
		end if;
	END LOOP;
		
	return v_ret_string;
end;$_$;


ALTER FUNCTION public.im_dynfield_multimap_val_to_str(integer, integer, character varying) OWNER TO evex;

--
-- Name: im_dynfield_widget__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_widget__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_widget_id		alias for $1;
BEGIN
	-- Erase the im_dynfield_widgets item associated with the id
	delete from im_dynfield_widgets
	where widget_id = p_widget_id;

	-- Erase all the privileges
	delete from acs_permissions
	where object_id = p_widget_id;

	PERFORM acs_object__delete(p_widget_id);
	return 0;
end;$_$;


ALTER FUNCTION public.im_dynfield_widget__delete(integer) OWNER TO evex;

--
-- Name: im_dynfield_widget__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_widget__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_widget_id		alias for $1;
	v_name			varchar;
BEGIN
	select	widget_name
	into	v_name
	from	im_dynfield_widgets
	where	widget_id = p_widget_id;

	return v_name;
end;$_$;


ALTER FUNCTION public.im_dynfield_widget__name(integer) OWNER TO evex;

--
-- Name: im_dynfield_widget__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_widget__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_widget_id		alias for $1;
	p_object_type		alias for $2;
	p_creation_date 	alias for $3;
	p_creation_user 	alias for $4;
	p_creation_ip		alias for $5;
	p_context_id		alias for $6;

	p_widget_name		alias for $7;
	p_pretty_name		alias for $8;
	p_pretty_plural		alias for $9;
	p_storage_type_id	alias for $10;
	p_acs_datatype		alias for $11;
	p_widget		alias for $12;
	p_sql_datatype		alias for $13;
	p_parameters		alias for $14;

	v_widget_id		integer;
BEGIN
	select widget_id into v_widget_id from im_dynfield_widgets
	where widget_name = p_widget_name;
	if v_widget_id is not null then return v_widget_id; end if;

	v_widget_id := acs_object__new (
		p_widget_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

	insert into im_dynfield_widgets (
		widget_id, widget_name, pretty_name, pretty_plural,
		storage_type_id, acs_datatype, widget, sql_datatype, parameters
	) values (
		v_widget_id, p_widget_name, p_pretty_name, p_pretty_plural,
		p_storage_type_id, p_acs_datatype, p_widget, p_sql_datatype, p_parameters
	);
	return v_widget_id;
end;$_$;


ALTER FUNCTION public.im_dynfield_widget__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, character varying, character varying, character varying, character varying) OWNER TO evex;

--
-- Name: im_dynfield_widget__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_dynfield_widget__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_widget_id			alias for $1;
	p_object_type			alias for $2;
	p_creation_date			alias for $3;
	p_creation_user			alias for $4;
	p_creation_ip			alias for $5;
	p_context_id			alias for $6;

	p_widget_name			alias for $7;
	p_pretty_name			alias for $8;
	p_pretty_plural			alias for $9;
	p_storage_type_id		alias for $10;
	p_acs_datatype			alias for $11;
	p_widget			alias for $12;
	p_sql_datatype			alias for $13;
	p_parameters			alias for $14;
	p_deref_plpgsql_function	alias for $15;

	v_widget_id			integer;
BEGIN
	select widget_id into v_widget_id from im_dynfield_widgets
	where widget_name = p_widget_name;
	if v_widget_id is not null then return v_widget_id; end if;

	v_widget_id := acs_object__new (
		p_widget_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

	insert into im_dynfield_widgets (
		widget_id, widget_name, pretty_name, pretty_plural,
		storage_type_id, acs_datatype, widget, sql_datatype, parameters, deref_plpgsql_function
	) values (
		v_widget_id, p_widget_name, p_pretty_name, p_pretty_plural,
		p_storage_type_id, p_acs_datatype, p_widget, p_sql_datatype, p_parameters, p_deref_plpgsql_function
	);
	return v_widget_id;
end;$_$;


ALTER FUNCTION public.im_dynfield_widget__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, character varying, character varying, character varying, character varying, character varying) OWNER TO evex;

--
-- Name: im_email_from_user_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_email_from_user_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_user_id	alias for $1;
	v_email varchar(100);
BEGIN
	select email
	into v_email
	from parties
	where party_id = v_user_id;

	return v_email;
END;$_$;


ALTER FUNCTION public.im_email_from_user_id(integer) OWNER TO evex;

--
-- Name: im_first_letter_default_to_a(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_first_letter_default_to_a(character varying) RETURNS character
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_string	alias for $1;
	v_initial	char(1);
BEGIN
	v_initial := substr(upper(p_string),1,1);

	IF v_initial IN (
		'A','B','C','D','E','F','G','H','I','J','K','L','M',
		'N','O','P','Q','R','S','T','U','V','W','X','Y','Z'
	) THEN
		RETURN v_initial;
	END IF;
	
	RETURN 'A';
end;$_$;


ALTER FUNCTION public.im_first_letter_default_to_a(character varying) OWNER TO evex;

--
-- Name: im_grant_permission(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_grant_permission(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id	alias for $1;
	p_party_id	alias for $2;
	p_privilege	alias for $3;
BEGIN
	PERFORM acs_permission__grant_permission(p_object_id, p_party_id, p_privilege);
	return 0;
END;$_$;


ALTER FUNCTION public.im_grant_permission(integer, integer, character varying) OWNER TO evex;

--
-- Name: im_initials_from_user_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_initials_from_user_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_user_id	alias for $1;
	v_initials	varchar(2);
BEGIN
	select substr(first_names,1,1) || substr(last_name,1,1) into v_initials
	from persons
	where person_id = v_user_id;
	return v_initials;
END;$_$;


ALTER FUNCTION public.im_initials_from_user_id(integer) OWNER TO evex;

--
-- Name: im_insert_acs_object_type_tables(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_insert_acs_object_type_tables(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_type		alias for $1;
	p_table_name		alias for $2;
	p_id_column		alias for $3;

	v_count			integer;
BEGIN
	-- Check for duplicates
	select	count(*) into v_count
	from	acs_object_type_tables
	where	object_type = p_object_type and
		table_name = p_table_name;
	IF v_count > 0 THEN return 1; END IF;

	-- Make sure the object_type exists
	select	count(*) into v_count
	from	acs_object_types
	where	object_type = p_object_type;
	IF v_count = 0 THEN return 2; END IF;

	insert into acs_object_type_tables (object_type, table_name, id_column)
	values (p_object_type, p_table_name, p_id_column);

	return 0;
end;$_$;


ALTER FUNCTION public.im_insert_acs_object_type_tables(character varying, character varying, character varying) OWNER TO evex;

--
-- Name: im_integer_from_id(double precision); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_integer_from_id(double precision) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_result	alias for $1;
BEGIN
	return v_result::varchar;
END;$_$;


ALTER FUNCTION public.im_integer_from_id(double precision) OWNER TO evex;

--
-- Name: im_integer_from_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_integer_from_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_result	alias for $1;
BEGIN
	return v_result::varchar;
END;$_$;


ALTER FUNCTION public.im_integer_from_id(integer) OWNER TO evex;

--
-- Name: im_integer_from_id(numeric); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_integer_from_id(numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_result	alias for $1;
BEGIN
	return v_result::varchar;
END;$_$;


ALTER FUNCTION public.im_integer_from_id(numeric) OWNER TO evex;

--
-- Name: im_integer_from_id(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_integer_from_id(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_result	alias for $1;
BEGIN
	return v_result;
END;$_$;


ALTER FUNCTION public.im_integer_from_id(character varying) OWNER TO evex;

--
-- Name: im_key_account_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_key_account_rel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_rel_id	alias for $1;
BEGIN
	delete	from im_key_account_rels
	where	rel_id = p_rel_id;

	PERFORM acs_rel__delete(p_rel_id);
	return 0;
end;$_$;


ALTER FUNCTION public.im_key_account_rel__delete(integer) OWNER TO evex;

--
-- Name: im_key_account_rel__new(integer, character varying, integer, integer, integer, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_key_account_rel__new(integer, character varying, integer, integer, integer, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_rel_id		alias for $1;	-- null
	p_rel_type		alias for $2;	-- im_key_account_rel
	p_object_id_one		alias for $3;
	p_object_id_two		alias for $4;
	p_context_id		alias for $5;
	p_creation_user		alias for $6;	-- null
	p_creation_ip		alias for $7;	-- null

	v_rel_id	integer;
BEGIN
	v_rel_id := acs_rel__new (
		p_rel_id,
		p_rel_type,
		p_object_id_one,
		p_object_id_two,
		p_context_id,
		p_creation_user,
		p_creation_ip
	);

	insert into im_key_account_rels (
	       rel_id, sort_order
	) values (
	       v_rel_id, p_sort_order
	);

	return v_rel_id;
end;$_$;


ALTER FUNCTION public.im_key_account_rel__new(integer, character varying, integer, integer, integer, integer, character varying, integer) OWNER TO evex;

--
-- Name: im_lang_add_message(text, text, text, text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_lang_add_message(text, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_locale	alias for $1;
	p_package_key	alias for $2;
	p_message_key	alias for $3;
	p_message	alias for $4;

	v_count		integer;
BEGIN
	-- Do not insert strings for packages that do not exist
	--
	select	count(*) into v_count from apm_packages
	where	package_key = p_package_key;
	IF 0 = v_count THEN return 0; END IF;

	-- Make sure there is an entry in lang_message_keys
	--
	select	count(*) into v_count from lang_message_keys
	where	package_key = p_package_key and message_key = p_message_key;
	IF 0 = v_count THEN
		insert into lang_message_keys (
			message_key, package_key
		) values (
			p_message_key, p_package_key
		);
	END IF;

	-- Create the translation entry
	--
	select	count(*) into v_count from lang_messages
	where	locale = p_locale and package_key = p_package_key and message_key = p_message_key;
	IF 0 = v_count THEN
		insert into lang_messages (
			message_key, package_key, locale, message, sync_time, upgrade_status
		) values (
			p_message_key, p_package_key, p_locale, p_message, now(), 'added'
		);
	END IF;

	return 1;
END;$_$;


ALTER FUNCTION public.im_lang_add_message(text, text, text, text) OWNER TO evex;

--
-- Name: im_link_from_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_link_from_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_object_id     alias for $1;
        v_name          varchar;
        v_url           varchar;
BEGIN
        select  im_name_from_id (p_object_id)
        into    v_name;

        select url into v_url
        from im_biz_object_urls ibou, acs_objects ao
        where ibou.object_type = ao.object_type
        and ao.object_id = p_object_id;

        return '<a href=' || v_url || p_object_id || '>' || v_name || '</a>';
end;$_$;


ALTER FUNCTION public.im_link_from_id(integer) OWNER TO evex;

--
-- Name: im_menu__del_module(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_menu__del_module(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_module_name	alias for $1;
	row		RECORD;
BEGIN
	-- First we have to delete the references to parent menus...
	for row in 
		select menu_id
		from im_menus
		where package_name = p_module_name
	loop

		update im_menus 
		set parent_menu_id = null
		where menu_id = row.menu_id;

	end loop;

	-- ... then we can delete the menus themseves
	for row in 
		select menu_id
		from im_menus
		where package_name = p_module_name
	loop

		PERFORM im_menu__delete(row.menu_id);

	end loop;

	return 0;
end;$_$;


ALTER FUNCTION public.im_menu__del_module(character varying) OWNER TO evex;

--
-- Name: im_menu__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_menu__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_menu_id	alias for $1;
BEGIN
	-- Erase the im_menus item associated with the id
	delete from 	im_menus
	where		menu_id = p_menu_id;

	-- Erase all the priviledges
	delete from 	acs_permissions
	where		object_id = p_menu_id;
	
	PERFORM acs_object__delete(p_menu_id);
	return 0;
end;$_$;


ALTER FUNCTION public.im_menu__delete(integer) OWNER TO evex;

--
-- Name: im_menu__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_menu__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_menu_id	alias for $1;
	v_name		im_menus.name%TYPE;
BEGIN
	select	name into v_name from im_menus
	where	menu_id = p_menu_id;

	return v_name;
end;$_$;


ALTER FUNCTION public.im_menu__name(integer) OWNER TO evex;

--
-- Name: im_menu__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_menu__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_menu_id		alias for $1;	-- default null
	p_object_type		alias for $2;	-- default acs_object
	p_creation_date		alias for $3;	-- default now()
	p_creation_user		alias for $4;	-- default null
	p_creation_ip		alias for $5;	-- default null
	p_context_id		alias for $6;	-- default null

	p_package_name		alias for $7;
	p_label			alias for $8;
	p_name			alias for $9;
	p_url			alias for $10;
	p_sort_order		alias for $11;
	p_parent_menu_id	alias for $12;
	p_visible_tcl		alias for $13;  -- default null

	v_menu_id		im_menus.menu_id%TYPE;
begin
	select	menu_id into v_menu_id
	from	im_menus m where m.label = p_label;
	IF v_menu_id is not null THEN return v_menu_id; END IF;

	v_menu_id := acs_object__new (
		p_menu_id,		-- object_id
		p_object_type,		-- object_type
		p_creation_date,	-- creation_date
		p_creation_user,	-- creation_user
		p_creation_ip,  	-- creation_ip
		p_context_id		-- context_id
	);

	insert into im_menus (
		menu_id, package_name, label, name, 
		url, sort_order, parent_menu_id, visible_tcl
	) values (
		v_menu_id, p_package_name, p_label, p_name, p_url, 
		p_sort_order, p_parent_menu_id, p_visible_tcl
	);
	return v_menu_id;
end;$_$;


ALTER FUNCTION public.im_menu__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, integer, integer, character varying) OWNER TO evex;

--
-- Name: im_name_from_id(double precision); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_name_from_id(double precision) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_result	alias for $1;
BEGIN
	return v_result::varchar;
END;$_$;


ALTER FUNCTION public.im_name_from_id(double precision) OWNER TO evex;

--
-- Name: im_name_from_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_name_from_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_integer	alias for $1;
	v_result	varchar;
BEGIN
	-- Try with category - probably the fastest
	select category into v_result from im_categories
	where category_id = v_integer;

	IF v_result is not null THEN return v_result; END IF;

	-- Try with ACS_OBJECT
	select acs_object__name(v_integer)
	into v_result;

	return v_result;
END;$_$;


ALTER FUNCTION public.im_name_from_id(integer) OWNER TO evex;

--
-- Name: im_name_from_id(numeric); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_name_from_id(numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_result	alias for $1;
BEGIN
	return v_result::varchar;
END;$_$;


ALTER FUNCTION public.im_name_from_id(numeric) OWNER TO evex;

--
-- Name: im_name_from_id(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_name_from_id(timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_timestamp	alias for $1;
BEGIN
	return to_char(v_timestamp, 'YYYY-MM-DD');
END;$_$;


ALTER FUNCTION public.im_name_from_id(timestamp with time zone) OWNER TO evex;

--
-- Name: im_name_from_id(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_name_from_id(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_result	alias for $1;
BEGIN
	return v_result;
END;$_$;


ALTER FUNCTION public.im_name_from_id(character varying) OWNER TO evex;

--
-- Name: im_name_from_user_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_name_from_user_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_user_id	alias for $1;
	v_full_name	text;
BEGIN
	select first_names || ' ' || last_name into v_full_name 
	from persons
	where person_id = v_user_id;

	return v_full_name;
END;$_$;


ALTER FUNCTION public.im_name_from_user_id(integer) OWNER TO evex;

--
-- Name: im_name_from_user_id(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_name_from_user_id(integer, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_user_id	alias for $1;
	v_name_order	alias for $2;
	v_full_name	varchar(8000);
BEGIN
	IF 2 = v_name_order THEN
		select 	last_name || ' ' || first_names
		into 	v_full_name 
		from 	persons 
		where person_id = v_user_id;
	ELSEIF 3 = v_name_order THEN
		select 	last_name || ', ' || first_names 
		into 	v_full_name 
		from 	persons 
		where person_id = v_user_id;
	ELSE
		select 	first_names || ' ' || last_name 
		into 	v_full_name 
		from 	persons 
		where person_id = v_user_id;
	END IF;
	return v_full_name;
END;$_$;


ALTER FUNCTION public.im_name_from_user_id(integer, integer) OWNER TO evex;

--
-- Name: im_new_menu(character varying, character varying, character varying, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_new_menu(character varying, character varying, character varying, character varying, integer, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_package_name		alias for $1;
	p_label			alias for $2;
	p_name			alias for $3;
	p_url			alias for $4;
	p_sort_order		alias for $5;
	p_parent_menu_label	alias for $6;
	p_visible_tcl		alias for $7;

	v_menu_id		integer;
	v_parent_menu_id	integer;
begin
	-- Check for duplicates
	select	menu_id into v_menu_id
	from	im_menus m where m.label = p_label;
	IF v_menu_id is not null THEN return v_menu_id; END IF;

	-- Get parent menu
	select	menu_id into v_parent_menu_id
	from	im_menus m where m.label = p_parent_menu_label;

	v_menu_id := im_menu__new (
		null,					-- p_menu_id
		'im_menu',				-- object_type
		now(),					-- creation_date
		null,					-- creation_user
		null,					-- creation_ip
		null,					-- context_id
		p_package_name,
		p_label,
		p_name,
		p_url,
		p_sort_order,
		v_parent_menu_id,
		p_visible_tcl
	);

	return v_menu_id;
end;$_$;


ALTER FUNCTION public.im_new_menu(character varying, character varying, character varying, character varying, integer, character varying, character varying) OWNER TO evex;

--
-- Name: im_new_menu_perms(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_new_menu_perms(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_label			alias for $1;
	p_group			alias for $2;
	v_menu_id		integer;
	v_group_id		integer;
begin
	select	menu_id into v_menu_id
	from	im_menus where label = p_label;

	select	group_id into v_group_id
	from	groups where lower(group_name) = lower(p_group);

	PERFORM acs_permission__grant_permission(v_menu_id, v_group_id, 'read');
	return v_menu_id;
end;$_$;


ALTER FUNCTION public.im_new_menu_perms(character varying, character varying) OWNER TO evex;

--
-- Name: im_object_permission_p(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_object_permission_p(integer, integer, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id	alias for $1;
	p_user_id	alias for $2;
	p_privilege	alias for $3;
BEGIN
	return acs_permission__permission_p(p_object_id, p_user_id, p_privilege);
END;$_$;


ALTER FUNCTION public.im_object_permission_p(integer, integer, character varying) OWNER TO evex;

--
-- Name: im_office__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_office__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_office_id		alias for $1;
BEGIN
	-- Erase the im_offices item associated with the id
	delete from im_offices
	where office_id = v_office_id;

	-- Delete entry from parties
	delete from parties where party_id = v_office_id;

	-- Erase all the priviledges
	delete from 	acs_permissions
	where		object_id = v_office_id;

	PERFORM	acs_object__delete(v_office_id);

	return 0;
end;$_$;


ALTER FUNCTION public.im_office__delete(integer) OWNER TO evex;

--
-- Name: im_office__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_office__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_office_id	alias for $1;
	v_name	im_offices.office_name%TYPE;
BEGIN
	select	office_name
	into	v_name
	from	im_offices
	where	office_id = p_office_id;

	return v_name;
end;$_$;


ALTER FUNCTION public.im_office__name(integer) OWNER TO evex;

--
-- Name: im_office__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_office__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_office_id		alias for $1;
	p_object_type		alias for $2;
	p_creation_date		alias for $3;
	p_creation_user		alias for $4;
	p_creation_ip		alias for $5;
	p_context_id		alias for $6;

	p_office_name		alias for $7;
	p_office_path		alias for $8;
	p_office_type_id	alias for $9;
	p_office_status_id	alias for $10;
	p_company_id		alias for $11;

	v_object_id	integer;
begin
	v_object_id := acs_object__new (
		p_office_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);
	insert into im_offices (
		office_id, office_name, office_path, 
		office_type_id, office_status_id, company_id
	) values (
		v_object_id, p_office_name, p_office_path, 
		p_office_type_id, p_office_status_id, p_company_id
	);

	-- make a party - required by contacts
	insert into parties (party_id) values (v_object_id);
	insert into im_biz_objects (object_id) values (v_object_id);

	return v_object_id;
end;$_$;


ALTER FUNCTION public.im_office__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, integer, integer, integer) OWNER TO evex;

--
-- Name: im_priv_create(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_priv_create(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_priv_name		alias for $1;
	p_profile_name		alias for $2;

	v_profile_id		integer;
	v_object_id		integer;
	v_count			integer;
BEGIN
	-- Get the group_id from group_name
	select group_id into v_profile_id from groups
	where group_name = p_profile_name;

	-- Get the Main Site id, used as the global identified for permissions
	select package_id into v_object_id from apm_packages 
	where package_key='acs-subsite';

	select count(*) into v_count from acs_permissions
	where object_id = v_object_id and grantee_id = v_profile_id and privilege = p_priv_name;

	IF NULL != v_profile_id AND 0 = v_count THEN
		PERFORM acs_permission__grant_permission(v_object_id, v_profile_id, p_priv_name);
	END IF;

	return 0;
end;$_$;


ALTER FUNCTION public.im_priv_create(character varying, character varying) OWNER TO evex;

--
-- Name: im_profile__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_profile__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_profile_id		alias for $1;
BEGIN
	delete from im_profiles
	where profile_id=v_profile_id;

	PERFORM acs_group__delete( v_profile_id );

	return 0;
end;$_$;


ALTER FUNCTION public.im_profile__delete(integer) OWNER TO evex;

--
-- Name: im_profile__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_profile__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_profile_id		alias for $1;
	
	v_profile_name		varchar;
BEGIN
	select	group_name
	into	v_profile_name
	from	groups
	where	group_id = p_profile_id;

	return v_profile_name;
END;$_$;


ALTER FUNCTION public.im_profile__name(integer) OWNER TO evex;

--
-- Name: im_profile__new(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_profile__new(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	pretty_name	alias for $1;
	profile_gif	alias for $2;
BEGIN
	return im_profile__new (
		null,
		'im_profile',
		now(),
		0,
		null,
		null,

		null,
		null,
		pretty_name,
		'closed',
		profile_gif
	);
END;$_$;


ALTER FUNCTION public.im_profile__new(character varying, character varying) OWNER TO evex;

--
-- Name: im_profile__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_profile__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_profile_id	alias for $1;
	p_object_type	alias for $2;
	p_creation_date	alias for $3;
	p_creation_user	alias for $4;
	p_creation_ip	alias for $5;
	p_context_id	alias for $6;

	p_email		alias for $7;
	p_url		alias for $8;
	p_group_name	alias for $9;
	p_join_policy	alias for $10;
	p_profile_gif	alias for $11;

	v_group_id integer;
BEGIN
	v_group_id := acs_group__new (
			p_profile_id,
			p_object_type,
			p_creation_date,
			p_creation_user,
			p_creation_ip,
			p_email,
			p_url,
			p_group_name,
			p_join_policy,
			p_context_id
	);

	insert into im_profiles (
		profile_id, 
		profile_gif
	) values (
		v_group_id, 
		p_profile_gif
	);

	return v_group_id;
end;$_$;


ALTER FUNCTION public.im_profile__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying) OWNER TO evex;

--
-- Name: im_profile_add_user(character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_profile_add_user(character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
        p_group_name    alias for $1;
        p_grantee_id    alias for $2;

        v_group_id      integer;
        v_rel_id        integer;
        v_count         integer;
BEGIN
        -- Get the group_id from group_name
        select group_id into v_group_id from groups
        where lower(group_name) = lower(p_group_name);
        IF v_group_id is null THEN RETURN 0; END IF;

        -- skip if the relationship already exists
        select  count(*) into v_count from acs_rels
        where   object_id_one = v_group_id
                and object_id_two = p_grantee_id
                and rel_type = 'membership_rel';
        IF v_count > 0 THEN RETURN 0; END IF;

        v_rel_id := membership_rel__new(v_group_id, p_grantee_id);

        RETURN v_rel_id;
end;$_$;


ALTER FUNCTION public.im_profile_add_user(character varying, integer) OWNER TO evex;

--
-- Name: im_profiles_from_user_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_profiles_from_user_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_user_id	alias for $1;
	v_profiles	varchar;
	row		RECORD;
BEGIN
	v_profiles := '';
	FOR row IN
		select	group_name
		from	groups g,
			im_profiles p,
			group_distinct_member_map m
		where	m.member_id = v_user_id
			and g.group_id = m.group_id
			and g.group_id = p.profile_id
	LOOP
	    IF '' != v_profiles THEN v_profiles := v_profiles || ', '; END IF;
	    v_profiles := v_profiles || row.group_name;
	END LOOP;

	return v_profiles;
END;$_$;


ALTER FUNCTION public.im_profiles_from_user_id(integer) OWNER TO evex;

--
-- Name: im_proj_url_from_type(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_proj_url_from_type(integer, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_project_id	alias for $1;
	v_url_type	alias for $2;
	v_url 		varchar;
BEGIN
	begin
	select url 
	into v_url 
	from 	im_url_types, 
		im_project_url_map
	where	project_id=v_project_id
		and im_url_types.url_type_id=v_url_type
		and url_type=v_url_type;
	
	end;
	return v_url;
end;$_$;


ALTER FUNCTION public.im_proj_url_from_type(integer, character varying) OWNER TO evex;

--
-- Name: im_project__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_project_id		alias for $1;
BEGIN
	-- Erase the im_projects item associated with the id
	delete from 	im_projects
	where		project_id = v_project_id;

	-- Erase all the priviledges
	delete from 	acs_permissions
	where		object_id = v_project_id;

	PERFORM	acs_object__delete(v_project_id);

	return 0;
end;$_$;


ALTER FUNCTION public.im_project__delete(integer) OWNER TO evex;

--
-- Name: im_project__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_project_id	alias for $1;
	v_name		varchar;
BEGIN
	select	project_name
	into	v_name
	from	im_projects
	where	project_id = v_project_id;

	return v_name;
end;$_$;


ALTER FUNCTION public.im_project__name(integer) OWNER TO evex;

--
-- Name: im_project__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_project_id	alias for $1;
	p_object_type	alias for $2;
	p_creation_date   alias for $3;
	p_creation_user   alias for $4;
	p_creation_ip	alias for $5;
	p_context_id	alias for $6;

	p_project_name	alias for $7;
	p_project_nr	alias for $8;
	p_project_path	alias for $9;
	p_parent_id	alias for $10;
	p_company_id	alias for $11;
	p_project_type_id	alias for $12;
	p_project_status_id alias for $13;

	v_project_id	integer;
BEGIN
	v_project_id := acs_object__new (
		p_project_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

	insert into im_biz_objects (object_id) values (v_project_id);

	insert into im_projects (
		project_id, project_name, project_nr, 
		project_path, parent_id, company_id, project_type_id, 
		project_status_id 
	) values (
		v_project_id, p_project_name, p_project_nr, 
		p_project_path, p_parent_id, p_company_id, p_project_type_id, 
		p_project_status_id
	);
	return v_project_id;
end;$_$;


ALTER FUNCTION public.im_project__new(integer, character varying, timestamp with time zone, integer, character varying, integer, character varying, character varying, character varying, integer, integer, integer, integer) OWNER TO evex;

--
-- Name: im_project_change_company_id_of_childs(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_change_company_id_of_childs(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

declare
        v_project_id            alias for $1;
        v_company_id_root_node  integer;
        r                       record;
begin
        -- get company_id from root node
        select company_id into v_company_id_root_node from im_projects where project_id = v_project_id;

        -- Set company_id of all childs of root node to company_id of root node
        FOR r IN
                select
                    p_child.project_id
                from
                    im_projects p_parent,
                    im_projects p_child
                where
                    p_child.tree_sortkey between p_parent.tree_sortkey and tree_right(p_parent.tree_sortkey)
                    and p_parent.project_id = v_project_id
        LOOP
                update im_projects
                        set company_id = v_company_id_root_node
                where project_id = r.project_id;
        END LOOP;
        return 0;
end;$_$;


ALTER FUNCTION public.im_project_change_company_id_of_childs(integer) OWNER TO evex;

--
-- Name: im_project_change_company_id_of_childs_all(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_change_company_id_of_childs_all() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
        r                       record;
begin
        -- Set company_id of all childs of root node to company_id of root node
        FOR r IN

        select distinct
                parent.project_id
        from
                im_projects parent,
                im_projects child,
                im_companies parent_cust,
                im_companies child_cust
        where
                parent.company_id != child.company_id and
                child.tree_sortkey between parent.tree_sortkey and tree_right(parent.tree_sortkey) and
                parent.parent_id is null and
                child.parent_id is not null and
                parent.company_id = parent_cust.company_id and
                child.company_id = child_cust.company_id
        LOOP
                perform im_project_change_company_id_of_childs(r.project_id);
        END LOOP;
        return 0;
end;$$;


ALTER FUNCTION public.im_project_change_company_id_of_childs_all() OWNER TO evex;

--
-- Name: im_project_id_parent_list(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_id_parent_list(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_project_id		alias for $1;
BEGIN
	RETURN im_project_id_parent_list(p_project_id, '', 0);
END;$_$;


ALTER FUNCTION public.im_project_id_parent_list(integer) OWNER TO evex;

--
-- Name: im_project_id_parent_list(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_id_parent_list(integer, character varying, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
    DECLARE
	p_project_id		alias for $1;
    	p_parent_id_list      	alias for $2;
	p_counter		alias for $3; 
    
	v_result		varchar;
    	v_parent_id		integer;
	v_counter		integer;
	v_parent_id_list	varchar; 

    BEGIN
   
	-- Avoid infinite loops
   	IF p_counter > 50 THEN RETURN 'Infinite loop with project_id=' || p_project_id; END IF;
   
	-- Get parent_id
   	select p.parent_id
   	into   v_parent_id
   	from   im_projects p 
   	where  p.project_id = p_project_id;

	-- RAISE NOTICE 'im_project_id_parent_list found parent_id: %', v_parent_id;

    	IF v_parent_id is null THEN 
	   RETURN p_parent_id_list; 
	ELSE   	
	   v_parent_id_list := p_parent_id_list || ' ' || v_parent_id;
	   v_result = im_project_id_parent_list(v_parent_id, v_parent_id_list, p_counter+1);	   
	   RETURN v_result;
	END IF;
END;$_$;


ALTER FUNCTION public.im_project_id_parent_list(integer, character varying, integer) OWNER TO evex;

--
-- Name: im_project_insert_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
	v_max_child_sortkey		im_projects.max_child_sortkey%TYPE;
	v_parent_sortkey		im_projects.tree_sortkey%TYPE;
begin

	if new.parent_id is null
	then
	new.tree_sortkey := int_to_tree_key(new.project_id+1000);

	else

	select tree_sortkey, tree_increment_key(max_child_sortkey)
	into v_parent_sortkey, v_max_child_sortkey
	from im_projects
	where project_id = new.parent_id
	for update;

	update im_projects
	set max_child_sortkey = v_max_child_sortkey
	where project_id = new.parent_id;

	new.tree_sortkey := v_parent_sortkey || v_max_child_sortkey;

	end if;

	new.max_child_sortkey := null;

	return new;
end;$$;


ALTER FUNCTION public.im_project_insert_tr() OWNER TO evex;

--
-- Name: im_project_level_spaces(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_level_spaces(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_level		alias for $1;
	v_result	varchar;
	i		integer;
BEGIN
	v_result := '';
	FOR i IN 1..p_level LOOP
		v_result := v_result || '    ';
	END LOOP;
	RETURN v_result;
END; $_$;


ALTER FUNCTION public.im_project_level_spaces(integer) OWNER TO evex;

--
-- Name: im_project_managers_enumerator(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_managers_enumerator(integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_project_id		alias for $1;

	v_project_id		integer;
	v_parent_id		integer;
	v_project_lead_id	integer;
	v_count			integer;
BEGIN
	v_project_id := p_project_id;
	v_count := 100;

	WHILE (v_project_id is not null AND v_count > 0) LOOP
		select	parent_id, project_lead_id into v_parent_id, v_project_lead_id
		from	im_projects where project_id = v_project_id;

		IF v_project_lead_id is not null THEN RETURN NEXT v_project_lead_id; END IF;
		v_project_id := v_parent_id;
		v_count := v_count - 1;
	END LOOP;

	RETURN;
end;$_$;


ALTER FUNCTION public.im_project_managers_enumerator(integer) OWNER TO evex;

--
-- Name: im_project_name_from_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_name_from_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_project_id	alias for $1;
	v_project_name	varchar;
BEGIN
	select project_name
	into v_project_name
	from im_projects
	where project_id = p_project_id;

	return v_project_name;
end;$_$;


ALTER FUNCTION public.im_project_name_from_id(integer) OWNER TO evex;

--
-- Name: im_project_nr_from_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_nr_from_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_project_id	alias for $1;
	v_name		varchar;
BEGIN
	select project_nr
	into v_name
	from im_projects
	where project_id = p_project_id;

	return v_name;
end;$_$;


ALTER FUNCTION public.im_project_nr_from_id(integer) OWNER TO evex;

--
-- Name: im_project_nr_parent_list(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_nr_parent_list(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_project_id		alias for $1;
BEGIN
	RETURN im_project_nr_parent_list(p_project_id, ' ', 0);
END; $_$;


ALTER FUNCTION public.im_project_nr_parent_list(integer) OWNER TO evex;

--
-- Name: im_project_nr_parent_list(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_nr_parent_list(integer, character varying, integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_project_id		alias for $1;
	p_spacer		alias for $2;
	p_level			alias for $3;

	v_result		varchar;
	v_project_nr		varchar;
	v_parent_id		integer;
BEGIN
	-- End of recursion.
	IF p_project_id is NULL THEN RETURN ''; END IF;

	-- Error checking to avoid infinite loops within the DB...
	IF p_level > 10 THEN RETURN '- infinite loop with project_id='||p_project_id; END IF;

	-- Get the NR of the current project plus the parent_id
	select	p.project_nr, p.parent_id
	into	v_project_nr, v_parent_id
	from	im_projects p 
	where	p.project_id = p_project_id;

	-- Recurse for the parent projects
	v_result = im_project_nr_parent_list(v_parent_id, p_spacer, p_level+1);
	IF v_result != '' THEN v_result := v_result || p_spacer; END IF;
	v_result := v_result || v_project_nr;

	RETURN v_result;
END; $_$;


ALTER FUNCTION public.im_project_nr_parent_list(integer, character varying, integer) OWNER TO evex;

--
-- Name: im_project_sub_project_name_path(integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_project_sub_project_name_path(integer, boolean, boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    -- Returns a path of project_names -> bottom-up 
    -- Output of subproject-name itself and top parent project can be surpressed 

    p_sub_project_id            alias for $1;
    p_exlude_main_project_p     alias for $2;
    p_exlude_sub_project_p      alias for $3;
 
    v_subproject_id		integer;
    v_parent_id             	integer;
    v_project_name          	varchar;
    v_ctr           		integer;
    v_path          		varchar;
    v_slash         		varchar; 
 
BEGIN
    v_subproject_id := p_sub_project_id;
    v_ctr := 0; 
    v_path := '';

    WHILE v_ctr < 10  LOOP
        select  parent_id, project_name 
        into    v_parent_id, v_project_name
        from    im_projects p
        where   project_id = v_subproject_id;
        
        IF      
            v_parent_id is not null OR NOT p_exlude_main_project_p 
        THEN
            v_slash := '/';
            IF      '' = v_project_name
            THEN    
                    v_slash := '';
                    RAISE NOTICE 'v_project_name is empty';
            END IF; 

            IF      (v_ctr = 0 AND NOT p_exlude_sub_project_p) OR v_ctr != 0
            THEN    v_path := v_project_name || v_slash || v_path; 
            END IF; 

            v_subproject_id := v_parent_id;
        END IF;

        IF      v_parent_id is null 
        THEN    EXIT;
        ELSE 	v_ctr := v_ctr +1;
        END IF;     

    END LOOP;
    return v_path; 
 
end;$_$;


ALTER FUNCTION public.im_project_sub_project_name_path(integer, boolean, boolean) OWNER TO evex;

--
-- Name: im_projects_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_projects_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
	v_parent_sk	varbit default null;
	v_max_child_sortkey	varbit;
	v_old_parent_length	integer;
begin
	if new.project_id = old.project_id
	and ((new.parent_id = old.parent_id)
		or (new.parent_id is null
		and old.parent_id is null)) then

	return new;

	end if;

	-- the tree sortkey is going to change so get the new one and update it and all its
	-- children to have the new prefix...
	v_old_parent_length := length(new.tree_sortkey) + 1;

	if new.parent_id is null then
	v_parent_sk := int_to_tree_key(new.project_id+1000);
	else
		SELECT tree_sortkey, tree_increment_key(max_child_sortkey)
		INTO v_parent_sk, v_max_child_sortkey
		FROM im_projects
		WHERE project_id = new.parent_id
		FOR UPDATE;

		UPDATE im_projects
		SET max_child_sortkey = v_max_child_sortkey
		WHERE project_id = new.parent_id;

		v_parent_sk := v_parent_sk || v_max_child_sortkey;
	end if;

	UPDATE im_projects
	SET tree_sortkey = v_parent_sk || substring(tree_sortkey, v_old_parent_length)
	WHERE tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);

	return new;
end;$$;


ALTER FUNCTION public.im_projects_update_tr() OWNER TO evex;

--
-- Name: im_revoke_permission(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_revoke_permission(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_object_id	alias for $1;
	p_party_id	alias for $2;
	p_privilege	alias for $3;
BEGIN
	PERFORM acs_permission__revoke_permission(p_object_id, p_party_id, p_privilege);
	return 0;
END;$_$;


ALTER FUNCTION public.im_revoke_permission(integer, integer, character varying) OWNER TO evex;

--
-- Name: im_sub_categories(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_sub_categories(integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $_$
declare
	p_cat			alias for $1;
	v_cat			integer;
	row			RECORD;
BEGIN
	FOR row IN
		select	child_id
		from	im_category_hierarchy
		where	parent_id = p_cat
	    UNION
		select	p_cat
	LOOP
		RETURN NEXT row.child_id;
	END LOOP;

	RETURN;
end;$_$;


ALTER FUNCTION public.im_sub_categories(integer) OWNER TO evex;

--
-- Name: im_subgroup_create(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_subgroup_create(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_parent_name	alias for $1;
	p_subgroup_name alias for $2;

	v_rel_id		integer;
	v_parent_id		integer;
	v_subgroup_id		integer;
BEGIN
	-- Get the group_id from group_name
	select group_id into v_parent_id from groups
	where group_name = p_parent_name;

	-- Get the subgroup
	select group_id into v_subgroup_id from groups
	where group_name = p_subgroup_name;

	v_rel_id := composition_rel__new(
		v_parent_id,
		v_subgroup_id,
		0,
		null
	);
	return 0;
end;$_$;


ALTER FUNCTION public.im_subgroup_create(character varying, character varying) OWNER TO evex;

--
-- Name: im_traffic_light_from_id(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_traffic_light_from_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_status_id	alias for $1;

	v_category	varchar;
	v_gif		varchar;
BEGIN
	select	c.category, c.aux_string1
	into	v_category, v_gif
	from	im_categories c
	where	category_id = p_status_id;

	-- Take the GIF specified in the category
	IF v_gif is null OR v_gif = '' THEN 
		-- No GIF specified - take the default one...
		v_gif := '/intranet/images/navbar_default/bb_'||lower(v_category)|| '.gif';
	END IF;

	return '<img src="' || v_gif || '" border=0 title="" alt="">';
END;$_$;


ALTER FUNCTION public.im_traffic_light_from_id(integer) OWNER TO evex;

--
-- Name: im_user_matrix_grant(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.im_user_matrix_grant(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_group_name		alias for $1;
	p_grantee_group_name	alias for $2;
	p_privilege		alias for $3;

	v_group_id		integer;
	v_grantee_id		integer;
BEGIN
	-- Get the group_id from group_name
	select group_id into v_group_id from groups
	where group_name = p_group_name;

	-- Get the subgroup
	select group_id into v_grantee_id from groups
	where group_name = p_grantee_group_name;

	PERFORM acs_permission__grant_permission(
		v_group_id,
		v_grantee_id,
		p_privilege
	);
	return 0;
end;$_$;


ALTER FUNCTION public.im_user_matrix_grant(character varying, character varying, character varying) OWNER TO evex;

--
-- Name: image__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.image__delete(v_item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

    -- This should take care of deleting revisions, too.
    PERFORM content_item__delete (v_item_id);
    return 0;

END; 
$$;


ALTER FUNCTION public.image__delete(v_item_id integer) OWNER TO evex;

--
-- Name: image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, character varying, character varying, timestamp with time zone, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.image__new(p_name character varying, p_parent_id integer, p_item_id integer, p_revision_id integer, p_mime_type character varying, p_creation_user integer, p_creation_ip character varying, p_title character varying, p_description character varying, p_storage_type character varying, p_content_type character varying, p_nls_language character varying, p_publish_date timestamp with time zone, p_height integer, p_width integer, p_package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_item_id		 cr_items.item_id%TYPE;
    v_revision_id	 cr_revisions.revision_id%TYPE;
    v_package_id	 acs_objects.package_id%TYPE;
  BEGIN

     if content_item__is_subclass(p_content_type, 'image') = 'f' then
       raise EXCEPTION '-20000: image__new can only be called for an image type'; 
     end if;

    if p_package_id is null then
      v_package_id := acs_object__package_id(p_parent_id);
    else
      v_package_id := p_package_id;
    end if;

    v_item_id := content_item__new (
      p_name,
      p_parent_id,
      p_item_id,
      null,
      current_timestamp,
      p_creation_user,	
      p_parent_id,
      p_creation_ip,
      'content_item',
      p_content_type,
      null,
      null,
      null,
      null,
      null,
      p_storage_type,
      v_package_id
    );

    -- We will let the caller fill in the LOB data or file path.

    v_revision_id := content_revision__new (
      p_title,
      p_description,
      p_publish_date,
      p_mime_type,
      p_nls_language,
      null,            -- text
      v_item_id,
      p_revision_id,
      current_timestamp,
      p_creation_user,
      p_creation_ip,
      null,            -- content_length
      v_package_id
    );

    insert into images
    (image_id, height, width)
    values
    (v_revision_id, p_height, p_width);

    return v_item_id;
END; 
$$;


ALTER FUNCTION public.image__new(p_name character varying, p_parent_id integer, p_item_id integer, p_revision_id integer, p_mime_type character varying, p_creation_user integer, p_creation_ip character varying, p_title character varying, p_description character varying, p_storage_type character varying, p_content_type character varying, p_nls_language character varying, p_publish_date timestamp with time zone, p_height integer, p_width integer, p_package_id integer) OWNER TO evex;

--
-- Name: image__new(character varying, integer, integer, integer, character varying, integer, character varying, character varying, character varying, character varying, boolean, timestamp with time zone, character varying, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.image__new(new__name character varying, new__parent_id integer, new__item_id integer, new__revision_id integer, new__mime_type character varying, new__creation_user integer, new__creation_ip character varying, new__relation_tag character varying, new__title character varying, new__description character varying, new__is_live boolean, new__publish_date timestamp with time zone, new__path character varying, new__file_size integer, new__height integer, new__width integer, new__package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

    new__locale          varchar default null;
    new__nls_language	 varchar default null;
    new__creation_date	 timestamptz default current_timestamp;
    new__context_id      integer;	

    v_item_id		 cr_items.item_id%TYPE;
    v_package_id	 acs_objects.package_id%TYPE;
    v_revision_id	 cr_revisions.revision_id%TYPE;
  BEGIN
    new__context_id := new__parent_id;

    if new__package_id is null then
      v_package_id := acs_object__package_id(new__parent_id);
    else
      v_package_id := new__package_id;
    end if;

    v_item_id := content_item__new (
      new__name,
      new__parent_id,
      new__item_id,
      new__locale,
      new__creation_date,
      new__creation_user,	
      new__context_id,
      new__creation_ip,
      'content_item',
      'image',
      null,
      new__description,
      new__mime_type,
      new__nls_language,
      null,
      'file', -- storage_type
      v_package_id
    );

    -- update cr_child_rels to have the correct relation_tag
    update cr_child_rels
    set relation_tag = new__relation_tag
    where parent_id = new__parent_id
    and child_id = new__item_id
    and relation_tag = content_item__get_content_type(new__parent_id) || '-' || 'image';

    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      new__path,
      v_item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip,
      new__file_size,
      v_package_id
    );

    insert into images
    (image_id, height, width)
    values
    (v_revision_id, new__height, new__width);

    -- is_live => 't' not used as part of content_item.new
    -- because content_item.new does not let developer specify revision_id,
    -- revision_id is determined in advance 

    if new__is_live = 't' then
       PERFORM content_item__set_live_revision (v_revision_id);
    end if;

    return v_item_id;
END; 
$$;


ALTER FUNCTION public.image__new(new__name character varying, new__parent_id integer, new__item_id integer, new__revision_id integer, new__mime_type character varying, new__creation_user integer, new__creation_ip character varying, new__relation_tag character varying, new__title character varying, new__description character varying, new__is_live boolean, new__publish_date timestamp with time zone, new__path character varying, new__file_size integer, new__height integer, new__width integer, new__package_id integer) OWNER TO evex;

--
-- Name: image__new_revision(integer, integer, character varying, character varying, timestamp with time zone, character varying, character varying, integer, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.image__new_revision(p_item_id integer, p_revision_id integer, p_title character varying, p_description character varying, p_publish_date timestamp with time zone, p_mime_type character varying, p_nls_language character varying, p_creation_user integer, p_creation_ip character varying, p_height integer, p_width integer, p_package_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_revision_id      integer;
   v_package_id       acs_objects.package_id%TYPE;
BEGIN
    -- We will let the caller fill in the LOB data or file path.

    if p_package_id is null then
      v_package_id := acs_object__package_id(p_item_id);
    else
      v_package_id := p_package_id;
    end if;

    v_revision_id := content_revision__new (
      p_title,
      p_description,
      p_publish_date,
      p_mime_type,
      p_nls_language,
      null,               -- content_length
      p_item_id,
      p_revision_id,
      current_timestamp,
      p_creation_user,
      p_creation_ip,
      null,               -- content_length
      v_package_id
    );

    insert into images
    (image_id, height, width)
    values
    (v_revision_id, p_height, p_width);

    return v_revision_id;
END;
$$;


ALTER FUNCTION public.image__new_revision(p_item_id integer, p_revision_id integer, p_title character varying, p_description character varying, p_publish_date timestamp with time zone, p_mime_type character varying, p_nls_language character varying, p_creation_user integer, p_creation_ip character varying, p_height integer, p_width integer, p_package_id integer) OWNER TO evex;

--
-- Name: images; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.images (
    image_id integer NOT NULL,
    width integer,
    height integer
);


ALTER TABLE public.images OWNER TO evex;

--
-- Name: imagesi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.imagesi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    images.image_id,
    images.width,
    images.height
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.images
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = images.image_id));


ALTER TABLE public.imagesi OWNER TO evex;

--
-- Name: images_f(public.imagesi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.images_f(p_new public.imagesi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into images ( image_id, height, width ) values (v_revision_id, p_new.height, p_new.width);
    
   return;
   end;$$;


ALTER FUNCTION public.images_f(p_new public.imagesi) OWNER TO evex;

--
-- Name: instr(character varying, character); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.instr(str character varying, pat character) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
BEGIN
        return instr(str,pat,1,1);
END;
$$;


ALTER FUNCTION public.instr(str character varying, pat character) OWNER TO evex;

--
-- Name: instr(character varying, character, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.instr(str character varying, pat character, dir integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
BEGIN
        return instr(str,pat,dir,1);
END;
$$;


ALTER FUNCTION public.instr(str character varying, pat character, dir integer) OWNER TO evex;

--
-- Name: instr(character varying, character, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.instr(str character varying, pat character, dir integer, cnt integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
        v_len           integer;
        v_i             integer;
        v_c             char;
        v_cnt           integer;
        v_inc           integer;
BEGIN
        v_len := length(str);
        v_cnt := 0;
        
        if dir < 0 then
           v_inc := -1;
           v_i   := v_len;
        else 
           v_inc := 1;
           v_i   := 1;
        end if;
           
        while v_i > 0 and v_i <= v_len LOOP
          v_c := substr(str,v_i,1);
          if v_c::char = pat::char then 
            v_cnt := v_cnt + 1;
            if v_cnt = cnt then 
              return v_i;
            end if;
          end if;
          v_i := v_i + v_inc;
        end loop;

        return 0;

END;
$$;


ALTER FUNCTION public.instr(str character varying, pat character, dir integer, cnt integer) OWNER TO evex;

--
-- Name: int_to_tree_key(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.int_to_tree_key(p_intkey integer) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
-- Convert an integer into the bit string format used to store
-- tree sort keys.   Using 4 bytes for the long keys requires
-- using -2^31 rather than 2^31 to avoid a twos-complement 
-- "integer out of range" error in PG - if for some reason you
-- want to use a smaller value use positive powers of two!

-- There was an "out of range" check in here when I was using 15
-- bit long keys but the only check that does anything with the long
-- keys is to check for negative numbers.
DECLARE
BEGIN
  if p_intkey < 0 then
    raise exception 'int_to_tree_key: key must be a positive integer';
  end if;

  if p_intkey < 128 then
    return substring(bitfromint4(p_intkey), 25, 8);
  else
    return substring(bitfromint4(cast (-2^31 + p_intkey as int4)), 1, 32);
  end if;

END;
$$;


ALTER FUNCTION public.int_to_tree_key(p_intkey integer) OWNER TO evex;

--
-- Name: is_date(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.is_date(s character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	perform s::date;
	return true;
	exception when others then
		return false;
	end;
$$;


ALTER FUNCTION public.is_date(s character varying) OWNER TO evex;

--
-- Name: iurix_mails__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.iurix_mails__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
	p_mail_id	ALIAS FOR $1;
  BEGIN

	DELETE FROM iurix_mails WHERE mail_id = p_mail_id;
  
	RETURN 0;

  END; $_$;


ALTER FUNCTION public.iurix_mails__delete(integer) OWNER TO evex;

--
-- Name: iurix_mails__new(integer, integer, integer, character varying, character varying, text, character varying, character varying, character varying, character varying, character varying, text, text, text, text, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.iurix_mails__new(integer, integer, integer, character varying, character varying, text, character varying, character varying, character varying, character varying, character varying, text, text, text, text, character varying, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
	p_mail_id		ALIAS FOR $1;
	p_package_id		ALIAS FOR $2;
       	p_user_id		ALIAS FOR $3;
	p_type			ALIAS FOR $4;
	p_subject	      	ALIAS FOR $5;
	p_bodies	      	ALIAS FOR $6;
	p_date		      	ALIAS FOR $7;
	p_to		      	ALIAS FOR $8;
	p_from		      	ALIAS FOR $9;
	p_delivered_to	      	ALIAS FOR $10;
	p_importance	      	ALIAS FOR $11;
	p_dkim_signature      	ALIAS FOR $12;
	p_headers		ALIAS FOR $13;
	p_message_id		ALIAS FOR $14;
	p_received		ALIAS FOR $15;
	p_return_path		ALIAS FOR $16;
	p_x_mailer		ALIAS FOR $17;
	p_x_original_to		ALIAS FOR $18;
	p_x_arrival_time	ALIAS FOR $19;
       	p_x_originating_ip	ALIAS FOR $20;
	p_x_priority		ALIAS FOR $21;
	
  BEGIN
	
  	INSERT INTO iurix_mails (
	       mail_id,
	       package_id,
	       user_id,
	       type,
	       subject,
	       bodies,
	       date,
	       to_address,
	       from_address,
	       delivered_to,
	       importance,
	       dkim_signature,
	       headers,
	       message_id,
	       received,
	       return_path,
	       x_mailer,
	       x_original_to,
	       x_arrival_time,
	       x_originating_ip,
	       x_priority
  	) VALUES (
	       p_mail_id,
	       p_package_id,
	       p_user_id,
	       p_type,
	       p_subject,
	       p_bodies,
	       p_date,
	       p_to,
	       p_from,
	       p_delivered_to,
	       p_importance,
	       p_dkim_signature,
	       p_headers,
	       p_message_id,
	       p_received,
	       p_return_path,
	       p_x_mailer,
	       p_x_original_to,
	       p_x_arrival_time,
	       p_x_originating_ip,
	       p_x_priority
	);


	RETURN 0;

  END; $_$;


ALTER FUNCTION public.iurix_mails__new(integer, integer, integer, character varying, character varying, text, character varying, character varying, character varying, character varying, character varying, text, text, text, text, character varying, character varying, character varying, character varying, character varying, character varying) OWNER TO evex;

--
-- Name: iurix_mails__update(integer, integer, integer, character varying, character varying, text, character varying, character varying, character varying, character varying, character varying, text, text, text, text, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.iurix_mails__update(integer, integer, integer, character varying, character varying, text, character varying, character varying, character varying, character varying, character varying, text, text, text, text, character varying, character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
	p_mail_id		ALIAS FOR $1;
	p_package_id		ALIAS FOR $2;
       	p_user_id		ALIAS FOR $3;
	p_type			ALIAS FOR $4;
	p_subject	      	ALIAS FOR $5;
	p_bodies	      	ALIAS FOR $6;
	p_date		      	ALIAS FOR $7;
	p_to_address      	ALIAS FOR $8;
	p_from_address	      	ALIAS FOR $9;
	p_delivered_to	      	ALIAS FOR $10;
	p_importance	      	ALIAS FOR $11;
	p_dkim_signature      	ALIAS FOR $12;
	p_headers		ALIAS FOR $13;
	p_message_id		ALIAS FOR $14;
	p_received		ALIAS FOR $15;
	p_return_path		ALIAS FOR $16;
	p_x_mailer		ALIAS FOR $17;
	p_x_original_to		ALIAS FOR $18;
	p_x_arrival_time	ALIAS FOR $19;
       	p_x_originating_ip	ALIAS FOR $20;
	p_x_priority		ALIAS FOR $21;
	
  BEGIN
	
  	UPDATE iurix_mails SET 
	       package_id = p_package_id,
	       user_id = p_user_id,
	       type = p_type,
	       subject = p_subject,
	       bodies = p_bodies,
	       date = p_date,
	       to_address = p_to_address,
	       from_address = p_from_address,
	       delivered_to = p_delivered_to,
	       importance = p_importance,
	       dkim_signature = p_dkim_signature,
	       headers = p_headers,
	       message_id = p_message_id,
	       received = p_received,
	       return_path = p_return_path,
	       x_mailer = p_x_mailer,
	       x_original_to = p_x_original_to,
	       x_arrival_time = p_x_arrival_time,
	       x_originating_ip = p_x_originating_ip,
	       x_priority = p_x_priority
	WHERE  mail_id = p_mail_id;

	RETURN 0;

  END; $_$;


ALTER FUNCTION public.iurix_mails__update(integer, integer, integer, character varying, character varying, text, character varying, character varying, character varying, character varying, character varying, text, text, text, text, character varying, character varying, character varying, character varying, character varying, character varying) OWNER TO evex;

--
-- Name: iurix_mails; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.iurix_mails (
    mail_id integer NOT NULL,
    package_id integer,
    user_id integer,
    type character varying(10),
    subject character varying(255),
    bodies text,
    date character varying(255),
    to_address character varying(255),
    from_address character varying(255),
    delivered_to character varying(255),
    importance character varying(255),
    dkim_signature text,
    headers text,
    message_id text,
    received text,
    return_path character varying(255),
    x_arrival_time character varying(255),
    x_mailer character varying(255),
    x_original_to character varying(255),
    x_original_arrival_time character varying(255),
    x_originating_ip character varying(255),
    x_priority character varying(255)
);


ALTER TABLE public.iurix_mails OWNER TO evex;

--
-- Name: iurix_mailsi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.iurix_mailsi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    iurix_mails.mail_id,
    iurix_mails.package_id,
    iurix_mails.user_id,
    iurix_mails.type,
    iurix_mails.subject,
    iurix_mails.bodies,
    iurix_mails.date,
    iurix_mails.to_address,
    iurix_mails.from_address,
    iurix_mails.delivered_to,
    iurix_mails.importance,
    iurix_mails.dkim_signature,
    iurix_mails.headers,
    iurix_mails.message_id,
    iurix_mails.received,
    iurix_mails.return_path,
    iurix_mails.x_arrival_time,
    iurix_mails.x_mailer,
    iurix_mails.x_original_to,
    iurix_mails.x_original_arrival_time,
    iurix_mails.x_originating_ip,
    iurix_mails.x_priority
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.iurix_mails
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = iurix_mails.mail_id));


ALTER TABLE public.iurix_mailsi OWNER TO evex;

--
-- Name: iurix_mails_f(public.iurix_mailsi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.iurix_mails_f(p_new public.iurix_mailsi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into iurix_mails ( mail_id ) values (v_revision_id);
    
   return;
   end;$$;


ALTER FUNCTION public.iurix_mails_f(p_new public.iurix_mailsi) OWNER TO evex;

--
-- Name: journal_entry__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.journal_entry__delete(delete__journal_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	delete from journal_entries where journal_id = delete__journal_id;
	PERFORM acs_object__delete(delete__journal_id);

        return 0; 
END;
$$;


ALTER FUNCTION public.journal_entry__delete(delete__journal_id integer) OWNER TO evex;

--
-- Name: journal_entry__delete_for_object(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.journal_entry__delete_for_object(delete_for_object__object_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  journal_rec                           record;
BEGIN
        for journal_rec in select journal_id 
                             from journal_entries 
                            where object_id = delete_for_object__object_id  
        LOOP
	    PERFORM journal_entry__delete(journal_rec.journal_id);
	end loop;

        return 0; 
END;
$$;


ALTER FUNCTION public.journal_entry__delete_for_object(delete_for_object__object_id integer) OWNER TO evex;

--
-- Name: journal_entry__new(integer, integer, character varying, character varying, timestamp with time zone, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.journal_entry__new(new__journal_id integer, new__object_id integer, new__action character varying, new__action_pretty character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__msg character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_journal_id                journal_entries.journal_id%TYPE;
BEGIN
	v_journal_id := acs_object__new (
	  new__journal_id,
	  'journal_entry',
	  new__creation_date,
	  new__creation_user,
	  new__creation_ip,
	  new__object_id,
          't',
          new__action,
          null
	);

        insert into journal_entries (
            journal_id, object_id, action, action_pretty, msg
        ) values (
            v_journal_id, new__object_id, new__action, 
            new__action_pretty, new__msg
        );

        return v_journal_id;
     
END;
$$;


ALTER FUNCTION public.journal_entry__new(new__journal_id integer, new__object_id integer, new__action character varying, new__action_pretty character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__msg character varying) OWNER TO evex;

--
-- Name: last_day(date); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.last_day(date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	p_date_in alias for $1;		-- date_id

	v_date_out	date;
begin
	select to_date(date_trunc('month',add_months(p_date_in,1))::text, 'YYYY-MM-DD'::text) - 1 into v_date_out;
	return v_date_out;
end;$_$;


ALTER FUNCTION public.last_day(date) OWNER TO evex;

--
-- Name: last_day(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.last_day(last_day__somedate timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_month			integer;
       v_targetmonth		integer;
       v_date			timestamptz;
       v_targetdate		timestamptz;
BEGIN
	
       -- Initial values
       v_targetdate := last_day__somedate;
       v_targetmonth := extract(month from last_day__somedate);

       -- Add up to 31 days to the given date, stop if month changes.
       FOR i IN 1..31 LOOP

	    v_date := last_day__somedate + to_interval(i,'days');
	    v_month := extract(month from v_date);

	    if v_month != v_targetmonth
	    then
		exit;
	    else
	       v_targetdate := v_date;
	    end if;

       END LOOP;
	
       return v_targetdate;

END;
$$;


ALTER FUNCTION public.last_day(last_day__somedate timestamp with time zone) OWNER TO evex;

--
-- Name: lob_copy(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.lob_copy(from_id integer, to_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	if from_id is null then 
	    raise exception 'lob_copy: attempt to copy null from_id to % to_id',to_id;
        end if;

        insert into lobs (lob_id,refcount) values (to_id,0);

        insert into lob_data
             select to_id as lob_id, segment, byte_len, data
               from lob_data
              where lob_id = from_id;

        return null;

END;
$$;


ALTER FUNCTION public.lob_copy(from_id integer, to_id integer) OWNER TO evex;

--
-- Name: lob_get_data(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.lob_get_data(p_lob_id integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_rec   record;
        v_data  text default '';
BEGIN
        for v_rec in select data, segment from lob_data where lob_id = p_lob_id order by segment 
        loop
            v_data := v_data || v_rec.data;
        end loop;

        return v_data;

END;
$$;


ALTER FUNCTION public.lob_get_data(p_lob_id integer) OWNER TO evex;

--
-- Name: lob_length(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.lob_length(id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return sum(byte_len) from lob_data where lob_id = id;
END;
$$;


ALTER FUNCTION public.lob_length(id integer) OWNER TO evex;

--
-- Name: lobs_delete_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.lobs_delete_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	delete from lob_data where lob_id = old.lob_id;
	return old;
END;
$$;


ALTER FUNCTION public.lobs_delete_tr() OWNER TO evex;

--
-- Name: membership_rel__approve(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__approve(approve__rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update membership_rels
    set member_state = 'approved'
    where rel_id = approve__rel_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.membership_rel__approve(approve__rel_id integer) OWNER TO evex;

--
-- Name: membership_rel__ban(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__ban(ban__rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update membership_rels
    set member_state = 'banned'
    where rel_id = ban__rel_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.membership_rel__ban(ban__rel_id integer) OWNER TO evex;

--
-- Name: membership_rel__check_index(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__check_index(check_index__group_id integer, check_index__member_id integer, check_index__container_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result                              boolean;       
  n_rows                              integer;       
  row                                 record;
BEGIN

    select count(*) into n_rows
    from group_element_index
    where group_id = check_index__group_id
    and member_id = check_index__member_id
    and container_id = check_index__container_id;

    if n_rows = 0 then
      result := 'f';
      PERFORM acs_log__error('membership_rel.check_representation',
                    'Row missing from group_element_index: ' ||
                    'group_id = ' || check_index__group_id || ', ' ||
                    'member_id = ' || check_index__member_id || ', ' ||
                    'container_id = ' || check_index__container_id || '.');
    end if;

    for row in  select r.object_id_one as container_id
                from acs_rels r, composition_rels c
                where r.rel_id = c.rel_id
                and r.object_id_two = check_index__group_id  
    LOOP
      if membership_rel__check_index(row.container_id, check_index__member_id, check_index__container_id) = 'f' then
        result := 'f';
      end if;
    end loop;

    return result;
   
END;
$$;


ALTER FUNCTION public.membership_rel__check_index(check_index__group_id integer, check_index__member_id integer, check_index__container_id integer) OWNER TO evex;

--
-- Name: membership_rel__check_representation(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__check_representation(check_representation__rel_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  group_id                      groups.group_id%TYPE;
  member_id                     parties.party_id%TYPE;
  result                        boolean;  
  row                           record;     
BEGIN
    result := 't';

    if acs_object__check_representation(check_representation__rel_id) = 'f' then
      result := 'f';
    end if;

    select r.object_id_one, r.object_id_two
    into group_id, member_id
    from acs_rels r, membership_rels m
    where r.rel_id = m.rel_id
    and m.rel_id = check_representation__rel_id;

    if membership_rel__check_index(group_id, member_id, group_id) = 'f' then
      result := 'f';
    end if;

    for row in  select *
                from group_member_index
                where rel_id = check_representation__rel_id 
    LOOP
      if composition_rel__check_path_exists_p(row.container_id,
                                             row.group_id) = 'f' then
        result := 'f';
        PERFORM acs_log__error('membership_rel.check_representation',
                      'Extra row in group_member_index: ' ||
                      'group_id = ' || row.group_id || ', ' ||
                      'member_id = ' || row.member_id || ', ' ||
                      'container_id = ' || row.container_id || '.');
      end if;
    end loop;

    return result;
   
END;
$$;


ALTER FUNCTION public.membership_rel__check_representation(check_representation__rel_id integer) OWNER TO evex;

--
-- Name: membership_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__delete(rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    PERFORM acs_rel__delete(rel_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.membership_rel__delete(rel_id integer) OWNER TO evex;

--
-- Name: membership_rel__deleted(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__deleted(deleted__rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update membership_rels
    set member_state = 'deleted'
    where rel_id = deleted__rel_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.membership_rel__deleted(deleted__rel_id integer) OWNER TO evex;

--
-- Name: membership_rel__merge(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__merge(merge__rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update membership_rels
    set member_state = 'merged'
    where rel_id = merge__rel_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.membership_rel__merge(merge__rel_id integer) OWNER TO evex;

--
-- Name: membership_rel__new(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__new(object_id_one integer, object_id_two integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
--
-- membership_rel__new/2 maybe obsolete, when we define proper defaults for /7
--
DECLARE
BEGIN
        return membership_rel__new(null,
                                   'membership_rel',
                                   object_id_one,
                                   object_id_two,
                                   'approved',
                                   null,
                                   null);
END;
$$;


ALTER FUNCTION public.membership_rel__new(object_id_one integer, object_id_two integer) OWNER TO evex;

--
-- Name: membership_rel__new(integer, character varying, integer, integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__new(new__rel_id integer, rel_type character varying, object_id_one integer, object_id_two integer, new__member_state character varying, creation_user integer, creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_rel_id               integer;       
BEGIN
    v_rel_id := acs_rel__new (
      new__rel_id,
      rel_type,
      object_id_one,
      object_id_two,
      object_id_one,
      creation_user,
      creation_ip
    );

    insert into membership_rels
     (rel_id, member_state)
    values
     (v_rel_id, new__member_state);

    return v_rel_id;
   
END;
$$;


ALTER FUNCTION public.membership_rel__new(new__rel_id integer, rel_type character varying, object_id_one integer, object_id_two integer, new__member_state character varying, creation_user integer, creation_ip character varying) OWNER TO evex;

--
-- Name: membership_rel__reject(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__reject(reject__rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update membership_rels
    set member_state = 'rejected'
    where rel_id = reject__rel_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.membership_rel__reject(reject__rel_id integer) OWNER TO evex;

--
-- Name: membership_rel__unapprove(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rel__unapprove(unapprove__rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    update membership_rels
    set member_state = 'needs approval'
    where rel_id = unapprove__rel_id;

    return 0; 
END;
$$;


ALTER FUNCTION public.membership_rel__unapprove(unapprove__rel_id integer) OWNER TO evex;

--
-- Name: membership_rels_del_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rels_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_error text;
  map             record;
BEGIN
  -- First check if removing this relation would violate any relational constraints
  v_error := rel_constraint__violation_if_removed(old.rel_id);
  if v_error is not null then
      raise EXCEPTION '-20000: %', v_error;
  end if;

  for map in select group_id, element_id, rel_type
             from group_element_index
             where rel_id = old.rel_id
  loop
    perform party_approved_member__remove(map.group_id, map.element_id, old.rel_id, map.rel_type);
  end loop;

  delete from group_element_index
  where rel_id = old.rel_id;

  return old;

END;
$$;


ALTER FUNCTION public.membership_rels_del_tr() OWNER TO evex;

--
-- Name: membership_rels_in_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rels_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_object_id_one acs_rels.object_id_one%TYPE;
  v_object_id_two acs_rels.object_id_two%TYPE;
  v_rel_type      acs_rels.rel_type%TYPE;
  v_composable_p  acs_rel_types.composable_p%TYPE;
  v_error         text;
  map             record;
BEGIN
  
  -- First check if added this relation violated any relational constraints
  v_error := rel_constraint__violation(new.rel_id);
  if v_error is not null then
      raise EXCEPTION '-20000: %', v_error;
  end if;

  select object_id_one, object_id_two, r.rel_type, composable_p
  into v_object_id_one, v_object_id_two, v_rel_type, v_composable_p
  from acs_rels r
  join acs_rel_types t on (r.rel_type = t.rel_type)
  where rel_id = new.rel_id;

  -- Insert a row for me in the group_element_index.
  insert into group_element_index
   (group_id, element_id, rel_id, container_id, 
    rel_type, ancestor_rel_type)
  values
   (v_object_id_one, v_object_id_two, new.rel_id, v_object_id_one, 
    v_rel_type, 'membership_rel');

  if new.member_state = 'approved' then
    perform party_approved_member__add(v_object_id_one, v_object_id_two, new.rel_id, v_rel_type);
  end if;

  -- If this rel_type composable...
  if v_composable_p = 't' then

     -- For all groups of which I am a component, insert a
     -- row in the group_element_index.
     for map in select distinct group_id
	      from group_component_map
	      where component_id = v_object_id_one 
     loop

        insert into group_element_index
               (group_id, element_id, rel_id, container_id,
               rel_type, ancestor_rel_type)
        values
               (map.group_id, v_object_id_two, new.rel_id, v_object_id_one,
               v_rel_type, 'membership_rel');

        if new.member_state = 'approved' then
           perform party_approved_member__add(map.group_id, v_object_id_two, new.rel_id, v_rel_type);
        end if;

     end loop;
  end if;
  return new;

END;
$$;


ALTER FUNCTION public.membership_rels_in_tr() OWNER TO evex;

--
-- Name: membership_rels_up_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.membership_rels_up_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  map             record;
BEGIN

  if new.member_state = old.member_state then
    return new;
  end if;

  for map in select group_id, element_id, rel_type
             from group_element_index
             where rel_id = new.rel_id
  loop
    if new.member_state = 'approved' then
      perform party_approved_member__add(map.group_id, map.element_id, new.rel_id, map.rel_type);
    else
      perform party_approved_member__remove(map.group_id, map.element_id, new.rel_id, map.rel_type);
    end if;
  end loop;

  return new;

END;
$$;


ALTER FUNCTION public.membership_rels_up_tr() OWNER TO evex;

--
-- Name: next_day(date, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.next_day(date, character varying) RETURNS date
    LANGUAGE plpgsql
    AS $_$
declare
	p_date_in alias for $1;		-- date_in
	p_day	alias for $2;		-- day

	v_date_out	date;
	value_to_add integer;
	
begin
	if lower(p_day) = 'sunday' or lower(p_day) = 'sun' then 
	value_to_add := 0;
	else
		if lower(p_day) = 'monday' or lower(p_day) = 'mon' then 
			value_to_add := 1;
		else
		if lower(p_day) = 'tuesday' or lower(p_day) = 'tue' then 
			value_to_add := 2;
		else
		if lower(p_day) = 'wednesday' or lower(p_day) = 'wed' then 
			value_to_add := 3;
		else
		if lower(p_day) = 'thursday' or lower(p_day) = 'thu' then 
		value_to_add := 4;
		else
		if lower(p_day) = 'friday' or lower(p_day) = 'fri' then 
			value_to_add := 5;
		else
			if lower(p_day) = 'saturday' or lower(p_day) = 'sat' then 
			value_to_add := 6;
			end if;
		end if;
		end if;
		end if;
		end if;
		end if;
	end if;

	select p_date_in - date_part('dow', p_date_in)::int + value_to_add into v_date_out;
	return v_date_out;
end;$_$;


ALTER FUNCTION public.next_day(date, character varying) OWNER TO evex;

--
-- Name: next_day(timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.next_day(next_day__somedate timestamp with time zone, next_day__weekday character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_dow			integer;
       v_ref_dow		integer;
       v_add_days		integer;
BEGIN
	-- I cant find a function that converts days of the week to
	-- the corresponding integer value, so I roll my own (above)
	-- We avoid extract(dow from timestamp) because of incompatible output with to_char.
	v_ref_dow := dow_to_int(next_day__weekday);
	v_dow := to_number(to_char(next_day__somedate,'D'),'9');
	
	-- If next_day___weekday is the same day of the week as
	-- next_day__somedate, we add a full week.
	if v_dow < v_ref_dow
	then
	     v_add_days := v_ref_dow - v_dow;
        else
	     v_add_days := v_ref_dow - v_dow + 7;
	end if;

	-- Do date math
	return next_day__somedate + to_interval(v_add_days,'days');

END;
$$;


ALTER FUNCTION public.next_day(next_day__somedate timestamp with time zone, next_day__weekday character varying) OWNER TO evex;

--
-- Name: notification__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification__delete(p_notification_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from notifications where notification_id = p_notification_id;
    perform acs_object__delete(p_notification_id);
    return 0;
END;
$$;


ALTER FUNCTION public.notification__delete(p_notification_id integer) OWNER TO evex;

--
-- Name: notification__new(integer, integer, integer, timestamp with time zone, integer, integer, character varying, text, text, text, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification__new(p_notification_id integer, p_type_id integer, p_object_id integer, p_notif_date timestamp with time zone, p_response_id integer, p_notif_user integer, p_notif_subject character varying, p_notif_text text, p_notif_html text, p_file_ids text, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_notification_id               integer;
    v_notif_date                    notifications.notif_date%TYPE;
BEGIN
    v_notification_id := acs_object__new(
        p_notification_id,
        'notification',
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        p_context_id
    );

    if p_notif_date is null then
        v_notif_date := now();
    else
        v_notif_date := p_notif_date;
    end if;

    insert
    into notifications
    (notification_id, type_id, object_id, notif_date, response_id, notif_user, notif_subject, notif_text, notif_html, file_ids)
    values
    (v_notification_id, p_type_id, p_object_id, v_notif_date, p_response_id, p_notif_user, p_notif_subject, p_notif_text, p_notif_html, p_file_ids);

    return v_notification_id;
END;
$$;


ALTER FUNCTION public.notification__new(p_notification_id integer, p_type_id integer, p_object_id integer, p_notif_date timestamp with time zone, p_response_id integer, p_notif_user integer, p_notif_subject character varying, p_notif_text text, p_notif_html text, p_file_ids text, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: notification_delivery_method__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_delivery_method__delete(p_delivery_method_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        perform acs_object__delete(p_delivery_method_id);
        return 0;
END;
$$;


ALTER FUNCTION public.notification_delivery_method__delete(p_delivery_method_id integer) OWNER TO evex;

--
-- Name: notification_delivery_method__new(integer, integer, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_delivery_method__new(p_delivery_method_id integer, p_sc_impl_id integer, p_short_name character varying, p_pretty_name character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_delivery_method_id            integer;
BEGIN
    v_delivery_method_id := acs_object__new(
        p_delivery_method_id,
        'notification_delivery_method',
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        p_context_id
    );

    insert
    into notification_delivery_methods
    (delivery_method_id, sc_impl_id, short_name, pretty_name)
    values
    (v_delivery_method_id, p_sc_impl_id, p_short_name, p_pretty_name);

    return v_delivery_method_id;
END;

$$;


ALTER FUNCTION public.notification_delivery_method__new(p_delivery_method_id integer, p_sc_impl_id integer, p_short_name character varying, p_pretty_name character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: notification_interval__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_interval__delete(p_interval_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    perform acs_object__delete(p_interval_id);
    return 0;
END;

$$;


ALTER FUNCTION public.notification_interval__delete(p_interval_id integer) OWNER TO evex;

--
-- Name: notification_interval__new(integer, character varying, integer, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_interval__new(p_interval_id integer, p_name character varying, p_n_seconds integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_interval_id                   integer;
BEGIN
    v_interval_id := acs_object__new(
        p_interval_id,
        'notification_interval',
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        p_context_id
    );

    insert
    into notification_intervals
    (interval_id, name, n_seconds)
    values
    (v_interval_id, p_name, p_n_seconds);

    return v_interval_id;
END;

$$;


ALTER FUNCTION public.notification_interval__new(p_interval_id integer, p_name character varying, p_n_seconds integer, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: notification_reply__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_reply__delete(p_reply_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        perform acs_object__delete(p_reply_id);
        return (0);
END;
$$;


ALTER FUNCTION public.notification_reply__delete(p_reply_id integer) OWNER TO evex;

--
-- Name: notification_reply__new(integer, integer, integer, integer, character varying, text, timestamp with time zone, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_reply__new(p_reply_id integer, p_object_id integer, p_type_id integer, p_from_user integer, p_subject character varying, p_content text, p_reply_date timestamp with time zone, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_reply_id                      integer;        
BEGIN
        v_reply_id:= acs_object__new (
                                    p_reply_id,
                                    'notification_reply',
                                    p_creation_date,
                                    p_creation_user,
                                    p_creation_ip,
                                    p_context_id
                                    );

        insert into notification_replies
        (reply_id, object_id, type_id, from_user, subject, content, reply_date)
        values
        (v_reply_id, p_object_id, p_type_id, p_from_user, p_subject, p_content, p_reply_date);


        return v_reply_id;
END;
$$;


ALTER FUNCTION public.notification_reply__new(p_reply_id integer, p_object_id integer, p_type_id integer, p_from_user integer, p_subject character varying, p_content text, p_reply_date timestamp with time zone, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: notification_request__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_request__delete(p_request_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_notifications record;
BEGIN
    for v_notifications in select notification_id
                           from notifications n, notification_requests nr
                           where n.response_id = nr.object_id
                             and nr.request_id = p_request_id
    loop
      perform acs_object__delete(v_notifications.notification_id);
    end loop;

    perform acs_object__delete(p_request_id);
    return 0;
END;
$$;


ALTER FUNCTION public.notification_request__delete(p_request_id integer) OWNER TO evex;

--
-- Name: notification_request__delete_all(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_request__delete_all(p_object_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_request                       RECORD;
BEGIN
    for v_request in select request_id
                     from notification_requests
                     where object_id= p_object_id
    loop
        perform notification_request__delete(v_request.request_id);
    end loop;

    return 0;
END;
$$;


ALTER FUNCTION public.notification_request__delete_all(p_object_id integer) OWNER TO evex;

--
-- Name: notification_request__delete_all_for_user(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_request__delete_all_for_user(p_user_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_request                       RECORD;
BEGIN
    for v_request in select request_id
                     from notification_requests
                     where user_id= p_user_id
    loop
        perform notification_request__delete(v_request.request_id);
    end loop;

    return 0;
END;
$$;


ALTER FUNCTION public.notification_request__delete_all_for_user(p_user_id integer) OWNER TO evex;

--
-- Name: notification_request__new(integer, character varying, integer, integer, integer, integer, integer, character varying, boolean, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_request__new(p_request_id integer, p_object_type character varying, p_type_id integer, p_user_id integer, p_object_id integer, p_interval_id integer, p_delivery_method_id integer, p_format character varying, p_dynamic_p boolean, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_request_id integer;
BEGIN
        v_request_id:= acs_object__new (
                                       p_request_id,
                                       p_object_type,
                                       p_creation_date,
                                       p_creation_user,
                                       p_creation_ip,
                                       p_context_id);

      insert into notification_requests
      (request_id, type_id, user_id, object_id, interval_id, delivery_method_id, format, dynamic_p) values
      (v_request_id, p_type_id, p_user_id, p_object_id, p_interval_id, p_delivery_method_id, p_format, p_dynamic_p);

      return v_request_id;                          
END;
$$;


ALTER FUNCTION public.notification_request__new(p_request_id integer, p_object_type character varying, p_type_id integer, p_user_id integer, p_object_id integer, p_interval_id integer, p_delivery_method_id integer, p_format character varying, p_dynamic_p boolean, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: notification_type__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_type__delete(p_type_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    perform acs_object__delete(p_type_id);
    return 0;
END;
$$;


ALTER FUNCTION public.notification_type__delete(p_type_id integer) OWNER TO evex;

--
-- Name: notification_type__new(integer, integer, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.notification_type__new(p_type_id integer, p_sc_impl_id integer, p_short_name character varying, p_pretty_name character varying, p_description character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_type_id                       integer;
BEGIN
        v_type_id:= acs_object__new (
                                    p_type_id,
                                    'notification_type',
                                    p_creation_date,
                                    p_creation_user,
                                    p_creation_ip,
                                    p_context_id);

      insert into notification_types
      (type_id, sc_impl_id, short_name, pretty_name, description) values
      (v_type_id, p_sc_impl_id, p_short_name, p_pretty_name, p_description);
      
      return v_type_id;
END;
$$;


ALTER FUNCTION public.notification_type__new(p_type_id integer, p_sc_impl_id integer, p_short_name character varying, p_pretty_name character varying, p_description character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: number_src(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.number_src(v_src text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
        v_pos   integer;
        v_ret   text default '';
        v_tmp   text;
        v_cnt   integer default -1;
BEGIN
        if v_src is null then 
	     return null;
        end if;

        v_tmp := v_src;
        LOOP
            v_pos := position(E'\n' in v_tmp);
            v_cnt := v_cnt + 1;

            exit when v_pos = 0;

            if v_cnt != 0 then
              v_ret := v_ret || to_char(v_cnt,'9999') || ':' || substr(v_tmp,1,v_pos);
            end if;
            v_tmp := substr(v_tmp,v_pos + 1);
        end LOOP;

        return v_ret || to_char(v_cnt,'9999') || ':' || v_tmp;

END;
$$;


ALTER FUNCTION public.number_src(v_src text) OWNER TO evex;

--
-- Name: on_lob_ref(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.on_lob_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	if TG_OP = 'UPDATE' then
		if new.lob = old.lob then
			return new;
		end if;
	end if;

	if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
		if new.lob is not null then
			insert into lobs select new.lob, 0
				where 0 = (select count(*) from lobs where lob_id = new.lob);
			update lobs set refcount = refcount + 1 where lob_id = new.lob;
		end if;
	end if;

	if TG_OP <> 'INSERT' then
		if old.lob is not null then
			update lobs set refcount = refcount - 1 where lob_id = old.lob;
			delete from lobs where lob_id = old.lob and refcount = 0;
		end if;
	end if;

	if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then return new;
	else return old;
	end if;

END;
$$;


ALTER FUNCTION public.on_lob_ref() OWNER TO evex;

--
-- Name: one_if_within_n_days(timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.one_if_within_n_days(timestamp with time zone, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  query_date		alias for $1;
  n_days		alias for $2;
begin
  if current_timestamp - query_date <= timespan_days(n_days) then 
    return 1;
  else
    return 0;
  end if;
end;$_$;


ALTER FUNCTION public.one_if_within_n_days(timestamp with time zone, integer) OWNER TO evex;

--
-- Name: organization__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.organization__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
 p_organization_id    alias for $1; 
 v_return integer := 0;  
begin 

   -- these should not be necessary
   delete from acs_permissions 
     where object_id = p_organization_id; 

   delete from organization_type_map
     where organization_id = p_organization_id;

   delete from organizations 
     where organization_id = p_organization_id;

   raise NOTICE 'Deleting organization - %',p_organization_id;

   PERFORM party__delete(p_organization_id);

   return v_return;

end;$_$;


ALTER FUNCTION public.organization__del(integer) OWNER TO evex;

--
-- Name: organization__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.organization__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_organization_id    alias for $1;
    v_organization_name  organizations.name%TYPE;
begin
        select name || '_' || organization_id into v_organization_name
                from organizations
                where organization_id = p_organization_id;
    return v_organization_name;
end;
$_$;


ALTER FUNCTION public.organization__name(integer) OWNER TO evex;

--
-- Name: organization__new(character varying, character varying, text, integer, integer, character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.organization__new(character varying, character varying, text, integer, integer, character varying, character varying, character varying, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
    p_legal_name           alias for $1; -- comment
    p_name                 alias for $2; -- comment
    p_notes                alias for $3; -- comment
    p_organization_id      alias for $4; -- comment
    p_organization_type_id alias for $5; -- comment
    p_reg_number           alias for $6; -- comment
    p_email                alias for $7; -- email
    p_url                  alias for $8;
    p_creation_user        alias for $9; -- comment
    p_creation_ip          alias for $10;
    p_context_id           alias for $11; -- comment

    -- local vars
    v_organization_id organizations.organization_id%TYPE; 
begin 
  v_organization_id := party__new (  
    p_organization_id,     -- party_id
    'organization',
    now(), 
    p_creation_user,
    p_creation_ip,
    p_email, 
    p_url,
    p_context_id 
  );   
   
  update acs_objects
  set title = p_name
  where object_id = v_organization_id;

  insert into organizations (
    legal_name,
    name,
    notes,
    organization_id,
    reg_number 
  )  
  values ( 
    p_legal_name,
    p_name,
    p_notes,
    v_organization_id,
    p_reg_number 
  ); 

  insert into organization_type_map (
    organization_id,
    organization_type_id
  ) values (
    v_organization_id,
    p_organization_type_id
  );

  PERFORM acs_permission__grant_permission (
     v_organization_id,
     p_creation_user,
     'admin'
  );

   raise NOTICE 'Adding organization - %',p_name;
  return v_organization_id;

end;$_$;


ALTER FUNCTION public.organization__new(character varying, character varying, text, integer, integer, character varying, character varying, character varying, integer, character varying, integer) OWNER TO evex;

--
-- Name: organization__set(character varying, character varying, text, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.organization__set(character varying, character varying, text, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
    p_legal_name         alias for $1; -- comment
    p_name               alias for $2; -- comment
    p_notes              alias for $3; -- comment
    p_organization_id    alias for $4; -- comment
    p_reg_number         alias for $5; -- comment

    v_return integer := 0; 
begin 

  update organizations
  set 
    legal_name = p_legal_name,
    name = p_name,
    notes = p_notes,
    organization_id = p_organization_id,
    reg_number = p_reg_number
  where organization_id = p_organization_id;

  raise NOTICE 'Updating  - organization - %',p_organization_id;

return v_return;
end;$_$;


ALTER FUNCTION public.organization__set(character varying, character varying, text, integer, character varying) OWNER TO evex;

--
-- Name: organization_rel__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.organization_rel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  rel_id                 alias for $1;  
begin
    PERFORM acs_rel__delete(rel_id);

    return 0; 
end;$_$;


ALTER FUNCTION public.organization_rel__delete(integer) OWNER TO evex;

--
-- Name: organization_rel__new(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.organization_rel__new(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  object_id_one          alias for $1;  
  object_id_two          alias for $2;  
begin
        return organization_rel__new(null,
                                    'organization_rel',
                                    object_id_one,
                                    object_id_two,
                                    null,
                                    null);
end;$_$;


ALTER FUNCTION public.organization_rel__new(integer, integer) OWNER TO evex;

--
-- Name: organization_rel__new(integer, character varying, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.organization_rel__new(integer, character varying, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  new__rel_id            alias for $1;  -- default null  
  rel_type               alias for $2;  -- default 'organization_rel'
  object_id_one          alias for $3;  
  object_id_two          alias for $4;  
  creation_user          alias for $5;  -- default null
  creation_ip            alias for $6;  -- default null
  v_rel_id               integer;       
begin
    v_rel_id := acs_rel__new (
      new__rel_id,
      rel_type,
      object_id_one,
      object_id_two,
      object_id_one,
      creation_user,
      creation_ip
    );

    return v_rel_id;
   
end;$_$;


ALTER FUNCTION public.organization_rel__new(integer, character varying, integer, integer, integer, character varying) OWNER TO evex;

--
-- Name: pa_album__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_album__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
     v_album_id	    alias for $1;
     v_num_children integer;
begin
    -- check if album is empty (no rm -r *)
    select count(*) into v_num_children
    from cr_items 
    where parent_id = v_album_id;

    if v_num_children > 0 then
           raise exception 'The specified album % still contains photos.  An album must be empty before it can be deleted.', album_id;
    end if;
    
    -- content_item.delete takes care of all revision
    -- on delete cascades take care of rest

    PERFORM content_item__delete (v_album_id);
    return 0;
end; $_$;


ALTER FUNCTION public.pa_album__delete(integer) OWNER TO evex;

--
-- Name: pa_album__delete_revision(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_album__delete_revision(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    revision_id		alias for $1;
  -- do not need to delete from the pa_albums
  -- the on delete cascade will take care of this
  -- during the content_revision.delete
begin
    PERFORM content_revision__delete (revision_id);
    return 0;    
end; $_$;


ALTER FUNCTION public.pa_album__delete_revision(integer) OWNER TO evex;

--
-- Name: pa_album__new(character varying, integer, integer, boolean, integer, character varying, character varying, character varying, text, character varying, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_album__new(character varying, integer, integer, boolean, integer, character varying, character varying, character varying, text, character varying, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare
    new__name		alias for $1;
    new__album_id       alias for $2;
    new__parent_id	alias for $3; -- default null
    new__is_live	alias for $4; -- default f
    new__creation_user  alias for $5; -- default null
    new__creation_ip    alias for $6; -- default null
    new__title		alias for $7; -- default null
    new__description    alias for $8; -- default null
    new__story	        alias for $9; -- default null	
    new__photographer   alias for $10; -- default null	
    new__revision_id    alias for $11; -- default null
    new__creation_date  alias for $12; -- default now()
    new__locale		alias for $13; -- default null
    new__context_id	alias for $14; -- default null
    new__publish_date   alias for $15; -- default now()
    new__nls_language   alias for $16; -- default null
    
    -- if we ever need another parameter space creation_date is the best bet
    -- new__creation_date	timestamp default now();
    new__content_type	varchar default 'pa_album';
    new_relation_tag	varchar default null;
    new__mime_type	varchar default null;

    v_item_id       integer;
    v_revision_id   integer;
  begin
    v_item_id := content_item__new (
      new__name,
      new__parent_id,
      new__album_id,
      new__locale,
      new__creation_date,
      new__creation_user,	
      new__context_id,
      new__creation_ip,
      'content_item',
      new__content_type,
      null,
      null,
      null,
      null,
      null
    );

      -- not needed in the new call to content_item__new
      -- new__relation_tag,

    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      v_item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip
    );

    insert into pa_albums (pa_album_id, story, photographer)
    values 
    (v_revision_id, new__story, new__photographer);

    if new__is_live = 't' then
       PERFORM content_item__set_live_revision (v_revision_id);
    end if;

    return v_item_id;
end; $_$;


ALTER FUNCTION public.pa_album__new(character varying, integer, integer, boolean, integer, character varying, character varying, character varying, text, character varying, integer, timestamp with time zone, character varying, integer, timestamp with time zone, character varying) OWNER TO evex;

--
-- Name: pa_albums; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pa_albums (
    pa_album_id integer NOT NULL,
    story text,
    photographer character varying(200),
    taken_start timestamp without time zone,
    taken_end timestamp without time zone,
    iconic integer
);


ALTER TABLE public.pa_albums OWNER TO evex;

--
-- Name: TABLE pa_albums; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.pa_albums IS '
  Table for storing custom fields of albums within content repository.  
  A pa_album is used to group zero or more pa_photos.
';


--
-- Name: COLUMN pa_albums.story; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.pa_albums.story IS '
  Story behind the album. In postgresql we use the text datatype
  and there is no limit on text length.  This differs from the varchar2 with
  Oracle.
';


--
-- Name: COLUMN pa_albums.photographer; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.pa_albums.photographer IS '
        The photographer who took the pictures.
';


--
-- Name: COLUMN pa_albums.taken_start; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.pa_albums.taken_start IS '
        The date the photos were taken (end of range)
';


--
-- Name: COLUMN pa_albums.iconic; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.pa_albums.iconic IS '
        The photo to use as the cover photo for this album.  If it is null a
        default icon is chosen
';


--
-- Name: pa_albumsi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.pa_albumsi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    pa_albums.pa_album_id,
    pa_albums.story,
    pa_albums.photographer,
    pa_albums.taken_start,
    pa_albums.taken_end,
    pa_albums.iconic
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.pa_albums
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = pa_albums.pa_album_id));


ALTER TABLE public.pa_albumsi OWNER TO evex;

--
-- Name: pa_albums_f(public.pa_albumsi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_albums_f(p_new public.pa_albumsi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into pa_albums ( pa_album_id, story, photographer ) values (v_revision_id, p_new.story, p_new.photographer);
    
   return;
   end;$$;


ALTER FUNCTION public.pa_albums_f(p_new public.pa_albumsi) OWNER TO evex;

--
-- Name: pa_collection__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_collection__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_collection_id                             alias for $1;
begin
    delete from acs_permissions
           where object_id = p_collection_id;

    delete from pa_collections
           where collection_id = p_collection_id;

    raise NOTICE 'Deleting photo_collection...';
    PERFORM acs_object__delete(p_collection_id);

    return 0;

end;$_$;


ALTER FUNCTION public.pa_collection__delete(integer) OWNER TO evex;

--
-- Name: pa_collection__new(integer, integer, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_collection__new(integer, integer, character varying, timestamp with time zone, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  p_collection_id                       alias for $1;       -- default null
  p_owner_id                            alias for $2;       -- default null
  p_title                               alias for $3;
  p_creation_date                       alias for $4;       -- default now()
  p_creation_user                       alias for $5;       -- default null
  p_creation_ip                         alias for $6;       -- default null
  p_context_id                          alias for $7;       -- default null
  v_collection_id                                     pa_collections.collection_id%TYPE;
begin
        v_collection_id := acs_object__new (
                p_collection_id,
                'photo_collection',
                p_creation_date,
                p_creation_user,
                p_creation_ip,
                p_context_id
        );

        insert into pa_collections
          (collection_id, owner_id, title)
        values
          (v_collection_id, p_owner_id, p_title);

        PERFORM acs_permission__grant_permission(
          v_collection_id,
          p_owner_id,
          'admin'
    );

    return v_collection_id;

end;$_$;


ALTER FUNCTION public.pa_collection__new(integer, integer, character varying, timestamp with time zone, integer, character varying, integer) OWNER TO evex;

--
-- Name: pa_collection__title(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_collection__title(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_collection_id        alias for $1;
    v_title           varchar;
begin
    select title into v_title
        from pa_collections
        where collection_id = p_collection_id;
    return v_title;
end;
$_$;


ALTER FUNCTION public.pa_collection__title(integer) OWNER TO evex;

--
-- Name: pa_photo__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_photo__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    del__item_id	alias for $1;
    v_rec		record;
begin
    for v_rec in 
	select child_id
	from cr_child_rels
	where parent_id = del__item_id
    LOOP
	PERFORM image__delete (v_rec.child_id);
    end loop;

    -- content_item__delete takes care of all revisions
    -- on delete cascades take care of rest

    PERFORM content_item__delete (del__item_id);

    return 0; 
end; $_$;


ALTER FUNCTION public.pa_photo__delete(integer) OWNER TO evex;

--
-- Name: pa_photo__delete_revision(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_photo__delete_revision(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    revision_id		alias for $1;

    -- do not need to delete from the pa_photos
    -- the on delete cascade will take care of this
    -- during the content_revision.delete
begin
   PERFORM content_revision__delete (revision_id);
   return 0; 
end; $_$;


ALTER FUNCTION public.pa_photo__delete_revision(integer) OWNER TO evex;

--
-- Name: pa_photo__new(character varying, integer, integer, integer, timestamp with time zone, integer, character varying, character varying, integer, character varying, character varying, boolean, timestamp with time zone, character varying, character varying, text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_photo__new(character varying, integer, integer, integer, timestamp with time zone, integer, character varying, character varying, integer, character varying, character varying, boolean, timestamp with time zone, character varying, character varying, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  declare 
    new__name		alias for $1;
    new__parent_id	alias for $2; -- default null
    new__item_id	alias for $3; -- default null
    new__revision_id	alias for $4; -- default null
    new__creation_date  alias for $5; -- default now()
    new__creation_user  alias for $6; -- default null
    new__creation_ip    alias for $7; -- default null
    new__locale         alias for $8; -- default null
    new__context_id     alias for $9; -- default null
    new__title          alias for $10; -- default null
    new__description    alias for $11; -- default null
    new__is_live        alias for $12; -- default f
    new__publish_date	alias for $13; -- default now()
    new__nls_language	alias for $14; -- default null
    new__caption	alias for $15; -- default null
    new__story		alias for $16; -- default null
    -- mime_type determined by image content_type
    new__mime_type	varchar default null;
    -- the same as title
    -- user_filename	in pa_photos.user_filename%TYPE default null
    new__content_type  varchar default 'pa_photo';	
    new__relation_tag  varchar default null;	
    
    v_item_id		cr_items.item_id%TYPE;
    v_revision_id	cr_revisions.revision_id%TYPE;
  begin
    
    v_item_id := content_item__new (
      new__name,
      new__parent_id,
      new__item_id,
      new__locale,
      new__creation_date,
      new__creation_user,	
      new__context_id,
      new__creation_ip,
      'content_item',
      new__content_type,
      null,
      null,
      null,
      null,
      null
    );

      -- not needed in the new call to content_item__new
      -- new__relation_tag,

    v_revision_id := content_revision__new (
      new__title,
      new__description,
      new__publish_date,
      new__mime_type,
      new__nls_language,
      null,
      v_item_id,
      new__revision_id,
      new__creation_date,
      new__creation_user,
      new__creation_ip

    );

    insert into pa_photos
    (pa_photo_id, caption, story, user_filename)
    values
    (v_revision_id, new__caption, new__story, new__title);

    if new__is_live = 't' then
       PERFORM content_item__set_live_revision (v_revision_id);
    end if;

    return v_item_id;
end; $_$;


ALTER FUNCTION public.pa_photo__new(character varying, integer, integer, integer, timestamp with time zone, integer, character varying, character varying, integer, character varying, character varying, boolean, timestamp with time zone, character varying, character varying, text) OWNER TO evex;

--
-- Name: pa_photos; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pa_photos (
    pa_photo_id integer NOT NULL,
    caption character varying(500),
    story text,
    user_filename character varying(250),
    camera_model character varying(250),
    date_taken timestamp without time zone,
    flash boolean,
    focal_length numeric,
    exposure_time numeric,
    aperture character varying(32),
    focus_distance numeric,
    metering character varying(100),
    sha256 character varying(64),
    photographer character varying(200)
);


ALTER TABLE public.pa_photos OWNER TO evex;

--
-- Name: TABLE pa_photos; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.pa_photos IS '
   Table for storing custom fields of photos within content repository.
   A pa_photo stores descriptive attribute information about a user
   uploaded photo.  The actually binary image files are stored using
   associated images.
';


--
-- Name: pa_photosi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.pa_photosi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    pa_photos.pa_photo_id,
    pa_photos.caption,
    pa_photos.story,
    pa_photos.user_filename,
    pa_photos.camera_model,
    pa_photos.date_taken,
    pa_photos.flash,
    pa_photos.focal_length,
    pa_photos.exposure_time,
    pa_photos.aperture,
    pa_photos.focus_distance,
    pa_photos.metering,
    pa_photos.sha256,
    pa_photos.photographer
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.pa_photos
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = pa_photos.pa_photo_id));


ALTER TABLE public.pa_photosi OWNER TO evex;

--
-- Name: pa_photos_f(public.pa_photosi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pa_photos_f(p_new public.pa_photosi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into pa_photos ( pa_photo_id, story, caption, user_filename, camera_model, date_taken, flash, exposure_time, aperture, focus_distance, metering, sha256, photographer ) values (v_revision_id, p_new.story, p_new.caption, p_new.user_filename, p_new.camera_model, p_new.date_taken, p_new.flash, p_new.exposure_time, p_new.aperture, p_new.focus_distance, p_new.metering, p_new.sha256, p_new.photographer);
    
   return;
   end;$$;


ALTER FUNCTION public.pa_photos_f(p_new public.pa_photosi) OWNER TO evex;

--
-- Name: parties_del_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.parties_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

  delete from party_approved_member_map
  where party_id = old.party_id
    and member_id = old.party_id;

  return old;

END;
$$;


ALTER FUNCTION public.parties_del_tr() OWNER TO evex;

--
-- Name: parties_in_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.parties_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

  insert into party_approved_member_map
    (party_id, member_id, originating_rel_id)
  values
    (new.party_id, new.party_id, -10);

  return new;

END;
$$;


ALTER FUNCTION public.parties_in_tr() OWNER TO evex;

--
-- Name: party__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.party__delete(party_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  PERFORM acs_object__delete(party_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.party__delete(party_id integer) OWNER TO evex;

--
-- Name: party__email(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.party__email(email__party_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN

  return email from parties where party_id = email__party_id;

END;
$$;


ALTER FUNCTION public.party__email(email__party_id integer) OWNER TO evex;

--
-- Name: party__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.party__name(party_id integer) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
  if party_id = -1 then
   return 'The Public';
  else
   return null;
  end if;
  
END;
$$;


ALTER FUNCTION public.party__name(party_id integer) OWNER TO evex;

--
-- Name: party__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.party__new(new__party_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__email character varying, new__url character varying, new__context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_party_id                  parties.party_id%TYPE;
BEGIN
  v_party_id :=
   acs_object__new(new__party_id, new__object_type, new__creation_date, 
                   new__creation_user, new__creation_ip, new__context_id,
                   't', new__email, null);

  insert into parties
   (party_id, email, url)
  values
   (v_party_id, lower(new__email), new__url);

  return v_party_id;
  
END;
$$;


ALTER FUNCTION public.party__new(new__party_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__email character varying, new__url character varying, new__context_id integer) OWNER TO evex;

--
-- Name: party_approved_member__add(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.party_approved_member__add(p_party_id integer, p_member_id integer, p_rel_id integer, p_rel_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_segments record;
BEGIN

  perform party_approved_member__add_one(p_party_id, p_member_id, p_rel_id);

  -- if the relation type is mapped to relational segments map them too

  for v_segments in select segment_id
                  from rel_segments s, acs_object_types ot1, acs_object_types ot2
                  where 
                    ot1.object_type = p_rel_type
                    and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
                    and s.rel_type = ot2.object_type
                    and s.group_id = p_party_id
  loop
    perform party_approved_member__add_one(v_segments.segment_id, p_member_id, p_rel_id);
  end loop;

  return 1;

END;
$$;


ALTER FUNCTION public.party_approved_member__add(p_party_id integer, p_member_id integer, p_rel_id integer, p_rel_type character varying) OWNER TO evex;

--
-- Name: party_approved_member__add_one(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.party_approved_member__add_one(p_party_id integer, p_member_id integer, p_rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  insert into party_approved_member_map
    (party_id, member_id, originating_rel_id)
  values
    (p_party_id, p_member_id, p_rel_id);

  return 1;

END;
$$;


ALTER FUNCTION public.party_approved_member__add_one(p_party_id integer, p_member_id integer, p_rel_id integer) OWNER TO evex;

--
-- Name: party_approved_member__remove(integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.party_approved_member__remove(p_party_id integer, p_member_id integer, p_rel_id integer, p_rel_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_segments record;
BEGIN

  perform party_approved_member__remove_one(p_party_id, p_member_id, p_rel_id);

  -- if the relation type is mapped to relational segments unmap them too

  for v_segments in select segment_id
                  from rel_segments s, acs_object_types ot1, acs_object_types ot2
                  where 
                    ot1.object_type = p_rel_type
                    and ot1.tree_sortkey between ot2.tree_sortkey and tree_right(ot2.tree_sortkey)
                    and s.rel_type = ot2.object_type
                    and s.group_id = p_party_id
  loop
    perform party_approved_member__remove_one(v_segments.segment_id, p_member_id, p_rel_id);
  end loop;

  return 1;

END;
$$;


ALTER FUNCTION public.party_approved_member__remove(p_party_id integer, p_member_id integer, p_rel_id integer, p_rel_type character varying) OWNER TO evex;

--
-- Name: party_approved_member__remove_one(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.party_approved_member__remove_one(p_party_id integer, p_member_id integer, p_rel_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

  delete from party_approved_member_map
  where party_id = p_party_id
    and member_id = p_member_id
    and originating_rel_id = p_rel_id;

  return 1;

END;
$$;


ALTER FUNCTION public.party_approved_member__remove_one(p_party_id integer, p_member_id integer, p_rel_id integer) OWNER TO evex;

--
-- Name: person__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.person__delete(delete__person_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  delete from persons
  where person_id = delete__person_id;

  PERFORM party__delete(delete__person_id);

  return 0; 
END;
$$;


ALTER FUNCTION public.person__delete(delete__person_id integer) OWNER TO evex;

--
-- Name: person__first_names(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.person__first_names(first_names__person_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
  return first_names
  from persons
  where person_id = first_names__person_id;
  
END;
$$;


ALTER FUNCTION public.person__first_names(first_names__person_id integer) OWNER TO evex;

--
-- Name: person__last_name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.person__last_name(last_name__person_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
  return last_name
  from persons
  where person_id = last_name__person_id;

END;
$$;


ALTER FUNCTION public.person__last_name(last_name__person_id integer) OWNER TO evex;

--
-- Name: person__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.person__name(name__person_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN

  return first_names || ' ' || last_name
  from persons
  where person_id = name__person_id;

END;
$$;


ALTER FUNCTION public.person__name(name__person_id integer) OWNER TO evex;

--
-- Name: person__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.person__new(new__person_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__email character varying, new__url character varying, new__first_names character varying, new__last_name character varying, new__context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_person_id                 persons.person_id%TYPE;
BEGIN
  v_person_id :=
   party__new(new__person_id, new__object_type,
             new__creation_date, new__creation_user, new__creation_ip,
             new__email, new__url, new__context_id);

  update acs_objects
  set title = new__first_names || ' ' || new__last_name
  where object_id = v_person_id;

  insert into persons
   (person_id, first_names, last_name)
  values
   (v_person_id, new__first_names, new__last_name);

  return v_person_id;
  
END;
$$;


ALTER FUNCTION public.person__new(new__person_id integer, new__object_type character varying, new__creation_date timestamp with time zone, new__creation_user integer, new__creation_ip character varying, new__email character varying, new__url character varying, new__first_names character varying, new__last_name character varying, new__context_id integer) OWNER TO evex;

--
-- Name: photo_album__get_root_folder(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.photo_album__get_root_folder(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        v_package_id		alias for $1;
	v_folder_id		integer;
begin
 select coalesce(folder_id,0) into v_folder_id
 from pa_package_root_folder_map
 where package_id = v_package_id;

 if v_folder_id > 0 then
    return v_folder_id;
 else
    return null;
 end if;        
end; $_$;


ALTER FUNCTION public.photo_album__get_root_folder(integer) OWNER TO evex;

--
-- Name: photo_album__new_root_folder(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.photo_album__new_root_folder(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
        v_package_id		alias for $1;
	v_folder_id		pa_package_root_folder_map.folder_id%TYPE;
	v_package_name		apm_packages.instance_name%TYPE;
	v_package_key		apm_packages.package_key%TYPE;
begin
 select instance_name, package_key 
 into v_package_name, v_package_key
 from apm_packages
 where package_id = v_package_id;

 v_folder_id := content_folder__new (
 v_package_key || '_' || v_package_id, -- name
 v_package_name || ' Home', -- label 
 'Home for ' || v_package_name, -- description 
 null,         -- parent_id
 v_package_id, --context_id,
 null,         --folder_id
 now(),        --creation_date
 null,         --creation_user
 null          --creation_ip
 );

 insert into pa_package_root_folder_map 
 (package_id, folder_id)
 values 
 (v_package_id, v_folder_id);

 -- allow child items to be added
 PERFORM content_folder__register_content_type(v_folder_id,'pa_album', 'f');
 PERFORM content_folder__register_content_type(v_folder_id,'content_folder', 'f');

 return v_folder_id;
end; $_$;


ALTER FUNCTION public.photo_album__new_root_folder(integer) OWNER TO evex;

--
-- Name: pinds_blog_category__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_category__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id alias for $1;
begin
    update pinds_blog_entries
        set category_id = null
        where category_id = p_category_id;

    delete from pinds_blog_categories
        where category_id = p_category_id;

    PERFORM acs_object__delete(p_category_id);
    return 0;
end;
$_$;


ALTER FUNCTION public.pinds_blog_category__delete(integer) OWNER TO evex;

--
-- Name: pinds_blog_category__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_category__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id     alias for $1;
    v_name            varchar;
begin
    select name into v_name
        from pinds_blog_categories
        where category_id = p_category_id;
    return v_name;
end;
$_$;


ALTER FUNCTION public.pinds_blog_category__name(integer) OWNER TO evex;

--
-- Name: pinds_blog_category__new(integer, integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_category__new(integer, integer, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_category_id          alias for $1;
    p_package_id           alias for $2;
    p_name                 alias for $3;
    p_short_name           alias for $4;
    p_creation_user        alias for $5;
    p_creation_ip          alias for $6;
    v_category_id          integer;
begin
    v_category_id := acs_object__new (
        p_category_id,
        'pinds_blog_category',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id
    );

    insert into pinds_blog_categories (
      category_id, 
      package_id,
      name,
      short_name
    ) values (
      v_category_id, 
      p_package_id,
      p_name,
      p_short_name
    );

    return v_category_id;   
end;
$_$;


ALTER FUNCTION public.pinds_blog_category__new(integer, integer, character varying, character varying, integer, character varying) OWNER TO evex;

--
-- Name: pinds_blog_entries__dtrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_entries__dtrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    perform search_observer__enqueue(old.entry_id,'DELETE');
    return old;
end;$$;


ALTER FUNCTION public.pinds_blog_entries__dtrg() OWNER TO evex;

--
-- Name: pinds_blog_entries__itrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_entries__itrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if new.draft_p = 'f' then
        perform search_observer__enqueue(new.entry_id,'INSERT');
    end if;
    return new;
end;$$;


ALTER FUNCTION public.pinds_blog_entries__itrg() OWNER TO evex;

--
-- Name: pinds_blog_entries__utrg(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_entries__utrg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if (new.draft_p = 't' and old.draft_p = 'f') or new.deleted_p = 't' then
        perform search_observer__enqueue(old.entry_id,'DELETE');
    else 
        perform search_observer__enqueue(old.entry_id,'UPDATE');
    end if;
    return old;
end;$$;


ALTER FUNCTION public.pinds_blog_entries__utrg() OWNER TO evex;

--
-- Name: pinds_blog_entry__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_entry__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_entry_id alias for $1;
    comment_rec         record;
begin
    -- delete comments associated with this entry
    for comment_rec in select gc.comment_id 
                         from general_comments gc
                         where gc.object_id = p_entry_id loop
        perform acs_message__delete(comment_rec.comment_id);
    end loop;

    delete from pinds_blog_entries
        where entry_id = p_entry_id;
    PERFORM acs_object__delete(p_entry_id);
    return 0;
end;
$_$;


ALTER FUNCTION public.pinds_blog_entry__delete(integer) OWNER TO evex;

--
-- Name: pinds_blog_entry__new(integer, integer, character varying, character varying, integer, character varying, character varying, timestamp with time zone, character, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_entry__new(integer, integer, character varying, character varying, integer, character varying, character varying, timestamp with time zone, character, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_entry_id             alias for $1;
    p_package_id           alias for $2;
    p_title                alias for $3;
    p_title_url            alias for $4;
    p_category_id          alias for $5;
    p_content              alias for $6;
    p_content_format       alias for $7;
    p_entry_date           alias for $8;
    p_draft_p              alias for $9;
    p_creation_user        alias for $10;
    p_creation_ip          alias for $11;
    v_entry_id             integer;
begin
    v_entry_id := acs_object__new (
        p_entry_id,
        'pinds_blog_entry',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id, 
        't',
        p_title,
        p_package_id
    );

    insert into pinds_blog_entries (
      entry_id, 
      package_id,
      title,
      title_url,
      category_id,
      content,
      content_format,
      entry_date,
      draft_p,
      deleted_p
    ) values (
      v_entry_id, 
      p_package_id,
      p_title,
      p_title_url,
      p_category_id,
      p_content,
      p_content_format,
      p_entry_date,
      p_draft_p,
      'f'
    );

    PERFORM acs_permission__grant_permission(
        v_entry_id,
	p_creation_user,
	'admin'
    );

    return v_entry_id;   
end;
$_$;


ALTER FUNCTION public.pinds_blog_entry__new(integer, integer, character varying, character varying, integer, character varying, character varying, timestamp with time zone, character, integer, character varying) OWNER TO evex;

--
-- Name: pinds_blog_entry__title(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pinds_blog_entry__title(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_entry_id        alias for $1;
    v_title           varchar;
begin
    select title into v_title
        from pinds_blog_entries
        where entry_id = p_entry_id;
    return v_title;
end;
$_$;


ALTER FUNCTION public.pinds_blog_entry__title(integer) OWNER TO evex;

--
-- Name: postal_address__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.postal_address__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
 p_address_id    alias for $1; 
 v_return integer := 0;  
begin 

   delete from acs_permissions 
     where object_id = p_address_id; 

   delete from postal_addresses 
     where address_id = p_address_id;

   raise NOTICE 'Deleting postal_address - %',p_address_id;

   PERFORM acs_object__delete(p_address_id);

   return v_return;

end;$_$;


ALTER FUNCTION public.postal_address__del(integer) OWNER TO evex;

--
-- Name: postal_address__new(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, integer, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.postal_address__new(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, integer, character varying, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
    p_additional_text     alias for $1; -- comment
    p_address_id          alias for $2; -- comment
    p_country_code        alias for $3; -- comment
    p_delivery_address    alias for $4; -- comment
    p_municipality        alias for $5; -- comment
    p_party_id            alias for $6; -- comment
    p_latitude_id         alias for $7; -- comment
    p_longitude_id        alias for $8; -- comment
    p_postal_code         alias for $9; -- comment
    p_postal_type         alias for $10; -- comment
    p_region              alias for $11; -- comment
    p_creation_user       alias for $12; -- comment
    p_creation_ip         alias for $13; -- comment
    p_context_id          alias for $14; -- comment

    -- local vars
    v_address_id postal_addresses.address_id%TYPE; 
begin 
  v_address_id := acs_object__new (  
    p_address_id,  
    'postal_address',
    now(), 
    p_creation_user, 
    p_creation_ip, 
    p_context_id 
  );   
   

  insert into postal_addresses (
    additional_text,
    address_id,
    country_code,
    delivery_address,
    municipality,
    party_id,
    latitude,
    longitude,
    postal_code,
    postal_type,
    region 
  )  
  values ( 
    p_additional_text,
    v_address_id,
    p_country_code,
    p_delivery_address,
    p_municipality,
    p_party_id,
    p_latitude,
    p_longitude,
    p_postal_code,
    p_postal_type,
    p_region 
  ); 

  PERFORM acs_permission__grant_permission (
     v_address_id,
     p_creation_user,
     'admin'
  );

   raise NOTICE 'Adding postal_address - %',v_address_id;
  return v_address_id;

end;$_$;


ALTER FUNCTION public.postal_address__new(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, integer, character varying, integer, character varying, integer) OWNER TO evex;

--
-- Name: postal_address__new(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, character varying, integer, character varying, text, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.postal_address__new(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, character varying, integer, character varying, text, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
    p_additional_text     alias for $1; -- comment
    p_address_id          alias for $2; -- comment
    p_country_code        alias for $3; -- comment
    p_delivery_address    alias for $4; -- comment
    p_municipality        alias for $5; -- comment
    p_party_id            alias for $6; -- comment
    p_latitude            alias for $7; -- comment
    p_longitude           alias for $8; -- comment
    p_url		  alias for $9; -- google url
    p_postal_code         alias for $10; -- comment
    p_postal_type         alias for $11; -- comment
    p_region              alias for $12; -- comment
    p_nearbies            alias for $13; -- nearbies places
    p_creation_user       alias for $14; -- comment
    p_creation_ip         alias for $15; -- comment
    p_context_id          alias for $16; -- comment

    -- local vars
    v_address_id postal_addresses.address_id%TYPE; 
begin 
  v_address_id := acs_object__new (  
    p_address_id,  
    'postal_address',
    now(), 
    p_creation_user, 
    p_creation_ip, 
    p_context_id 
  );   
   

  insert into postal_addresses (
    additional_text,
    address_id,
    country_code,
    delivery_address,
    municipality,
    party_id,
    latitude,
    longitude,
    google_url,
    postal_code,
    postal_type,
    region,
    nearbies ) VALUES ( 
    p_additional_text,
    v_address_id,
    p_country_code,
    p_delivery_address,
    p_municipality,
    p_party_id,
    p_latitude,
    p_longitude,
    p_url,
    p_postal_code,
    p_postal_type,
    p_region,
    p_nearbies 
  ); 

  PERFORM acs_permission__grant_permission (
     v_address_id,
     p_creation_user,
     'admin'
  );

   raise NOTICE 'Adding postal_address - %',v_address_id;
  return v_address_id;

end;$_$;


ALTER FUNCTION public.postal_address__new(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, character varying, integer, character varying, text, integer, character varying, integer) OWNER TO evex;

--
-- Name: postal_address__update(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, character varying, integer, character varying, text, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.postal_address__update(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, character varying, integer, character varying, text, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
    p_additional_text     alias for $1; -- comment
    p_address_id          alias for $2; -- comment
    p_country_code        alias for $3; -- comment
    p_delivery_address    alias for $4; -- comment
    p_municipality        alias for $5; -- comment
    p_party_id            alias for $6; -- comment
    p_latitude         	  alias for $7; -- comment
    p_longitude        	  alias for $8; -- comment
    p_google_url	  alias for $9;
    p_postal_code         alias for $10; -- comment
    p_postal_type         alias for $11; -- comment
    p_region              alias for $12; -- comment
    p_nearbies		  alias for $13; -- nearbies places
    p_creation_user       alias for $14; -- comment
    p_creation_ip         alias for $15; -- comment
    p_context_id          alias for $16; -- comment


    -- local vars
    v_address_id postal_addresses.address_id%TYPE; 

  BEGIN  
    v_address_id := acs_object__update_last_modified(  
      p_address_id,  
      p_creation_user, 
      p_creation_ip, 
      now()
    );   
   

    UPDATE postal_addresses SET
      additional_text = p_additional_text,
      country_code = p_country_code,
      delivery_address = p_delivery_address,
      municipality = p_municipality,
      party_id = p_party_id,
      latitude = p_latitude,
      longitude = p_longitude,
      google_url = p_google_url,
      postal_code = p_postal_code,
      postal_type =   p_postal_type,
      region = p_region,
      nearbies = p_nearbies
    WHERE address_id = p_address_id;
  


   raise NOTICE 'Adding postal_address - %',v_address_id;
   raise NOTICE 'Adding2 postal_address - %',p_address_id;
  return v_address_id;

end;$_$;


ALTER FUNCTION public.postal_address__update(character varying, integer, character, character varying, character varying, integer, character varying, character varying, character varying, character varying, integer, character varying, text, integer, character varying, integer) OWNER TO evex;

--
-- Name: priv_recurse_subtree(bit varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.priv_recurse_subtree(nkey bit varying, child_priv character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        new_value       integer;
        v_rec           record;
        new_key         varbit;
BEGIN

        -- now iterate over all of the children of the 
        -- previous node.
        
        for v_rec in select privilege, child_privilege
                       from acs_privilege_hierarchy
                      where privilege = child_priv

        LOOP

            -- calculate the next key for this level and parent

            select max(tree_leaf_key_to_int(tree_sortkey)) into new_value
              from acs_privilege_hierarchy_index
             where tree_sortkey between nkey and tree_right(nkey)
               and tree_level(tree_sortkey) = tree_level(nkey) + 1;

            new_key := tree_next_key(nkey, new_value);

            -- insert the new child node.

            insert into acs_privilege_hierarchy_index
                        (privilege, child_privilege, tree_sortkey)
                        values
                        (v_rec.privilege, v_rec.child_privilege, new_key);

            -- keep recursing down until no more children are found

            PERFORM priv_recurse_subtree(new_key, v_rec.child_privilege);

        end LOOP;

        -- no children found, so insert the child node as its own separate 
        -- node.

        if NOT FOUND then
           insert into acs_privilege_hierarchy_index
                       (privilege, child_privilege, tree_sortkey)
                       values 
                       (child_priv, child_priv, tree_next_key(nkey, null));
        end if;

        return null;

END;
$$;


ALTER FUNCTION public.priv_recurse_subtree(nkey bit varying, child_priv character varying) OWNER TO evex;

--
-- Name: pseudo_contains(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.pseudo_contains(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  indexed_stuff  		alias for $1;
  space_sep_list_untrimmed alias for $2;
  space_sep_list        	text;
  upper_indexed_stuff   	text;
  -- if you call this var start you get hosed royally
  first_space           	integer;
  score                 	integer;
begin 
  space_sep_list := upper(ltrim(rtrim(space_sep_list_untrimmed)));
  upper_indexed_stuff := upper(indexed_stuff);
  score := 0;
  if space_sep_list is null or indexed_stuff is null then
    return score;  
  end if;
  loop
   first_space := position(' ' in space_sep_list);
   if first_space = 0 then
     -- one token or maybe end of list
     if position(space_sep_list in upper_indexed_stuff) <> 0 then
        return score+10;
     end if;
     return score;
   else
     -- first_space <> 0
     if position(substring(space_sep_list from 1 for first_space-1) in upper_indexed_stuff) <> 0 then
        score := score + 10;
     end if;
   end if;
    space_sep_list := substring(space_sep_list from first_space+1);
  end loop;  
end;$_$;


ALTER FUNCTION public.pseudo_contains(character varying, character varying) OWNER TO evex;

--
-- Name: rdbms_date(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rdbms_date(p_raw_date character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
  return "timestamptz" (p_raw_date || '+00');
END;
$$;


ALTER FUNCTION public.rdbms_date(p_raw_date character varying) OWNER TO evex;

--
-- Name: recurrence__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.recurrence__delete(delete__recurrence_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE 
BEGIN
       delete from recurrences
       where  recurrence_id = delete__recurrence_id;

       return 0;
END;
$$;


ALTER FUNCTION public.recurrence__delete(delete__recurrence_id integer) OWNER TO evex;

--
-- Name: recurrence__new(character varying, integer, character varying, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.recurrence__new(new__interval_name character varying, new__every_nth_interval integer, new__days_of_week character varying, new__recur_until timestamp with time zone, new__custom_func character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_recurrence_id		  recurrences.recurrence_id%TYPE;
       v_interval_type_id	  recurrence_interval_types.interval_type%TYPE;
BEGIN

       select nextval('recurrence_sequence') into v_recurrence_id from dual;
        
       select interval_type
       into   v_interval_type_id 
       from   recurrence_interval_types
       where  interval_name = new__interval_name;
        
       insert into recurrences
            (recurrence_id, 
             interval_type, 
             every_nth_interval, 
             days_of_week,
             recur_until, 
             custom_func)
       values
            (v_recurrence_id, 
             v_interval_type_id, 
             new__every_nth_interval, 
             new__days_of_week,
             new__recur_until, 
             new__custom_func);
         
       return v_recurrence_id;

END;
$$;


ALTER FUNCTION public.recurrence__new(new__interval_name character varying, new__every_nth_interval integer, new__days_of_week character varying, new__recur_until timestamp with time zone, new__custom_func character varying) OWNER TO evex;

--
-- Name: rel_constraint__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_constraint__delete(constraint_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    PERFORM acs_object__delete(constraint_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.rel_constraint__delete(constraint_id integer) OWNER TO evex;

--
-- Name: rel_constraint__get_constraint_id(integer, character, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_constraint__get_constraint_id(get_constraint_id__rel_segment integer, get_constraint_id__rel_side character, get_constraint_id__required_rel_segment integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_constraint_id                           rel_constraints.constraint_id%TYPE;
BEGIN

    return constraint_id
    from rel_constraints
    where rel_segment = get_constraint_id__rel_segment
      and rel_side = get_constraint_id__rel_side
      and required_rel_segment = get_constraint_id__required_rel_segment;

END;
$$;


ALTER FUNCTION public.rel_constraint__get_constraint_id(get_constraint_id__rel_segment integer, get_constraint_id__rel_side character, get_constraint_id__required_rel_segment integer) OWNER TO evex;

--
-- Name: rel_constraint__new(character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_constraint__new(nam character varying, sid1 integer, side character varying, sid2 integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return rel_constraint__new(null,
                                   'rel_constraint',
                                   nam,
                                   sid1,
                                   side,
                                   sid2,
                                   null,
                                   null,
                                   null
                                   );                                   
END;
$$;


ALTER FUNCTION public.rel_constraint__new(nam character varying, sid1 integer, side character varying, sid2 integer) OWNER TO evex;

--
-- Name: rel_constraint__new(integer, character varying, character varying, integer, character, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_constraint__new(new__constraint_id integer, new__constraint_type character varying, new__constraint_name character varying, new__rel_segment integer, new__rel_side character, new__required_rel_segment integer, new__context_id integer, new__creation_user integer, new__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_constraint_id             rel_constraints.constraint_id%TYPE;
BEGIN
    v_constraint_id := acs_object__new (
      new__constraint_id,
      new__constraint_type,
      now(),
      new__creation_user,
      new__creation_ip,
      new__context_id,
      't',
      new__constraint_name,
      null
    );

    insert into rel_constraints
     (constraint_id, constraint_name, 
      rel_segment, rel_side, required_rel_segment)
    values
     (v_constraint_id, new__constraint_name, 
      new__rel_segment, new__rel_side, new__required_rel_segment);

     return v_constraint_id;
   
END;
$$;


ALTER FUNCTION public.rel_constraint__new(new__constraint_id integer, new__constraint_type character varying, new__constraint_name character varying, new__rel_segment integer, new__rel_side character, new__required_rel_segment integer, new__context_id integer, new__creation_user integer, new__creation_ip character varying) OWNER TO evex;

--
-- Name: rel_constraint__violation(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_constraint__violation(violation__rel_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_error                           text; 
  constraint_violated               record;
BEGIN

    v_error := null;

    for constraint_violated in
     select constraint_id, constraint_name
       from rel_constraints_violated_one
       where rel_id = violation__rel_id
       LIMIT 1 
    LOOP

	  v_error := coalesce(v_error,'') || 
                     'Relational Constraint Violation: ' ||
                     constraint_violated.constraint_name || 
                     ' (constraint_id=' ||
                     constraint_violated.constraint_id || '). ';

          return v_error;
    end loop;

    for constraint_violated in
     select constraint_id, constraint_name
       from rel_constraints_violated_two
      where rel_id = violation__rel_id
      LIMIT 1 
    LOOP

           v_error := coalesce(v_error,'') || 
                      'Relational Constraint Violation: ' ||
                      constraint_violated.constraint_name || 
                      ' (constraint_id=' ||
                      constraint_violated.constraint_id || '). ';

           return v_error;
    end loop;

    return v_error;
   
END;
$$;


ALTER FUNCTION public.rel_constraint__violation(violation__rel_id integer) OWNER TO evex;

--
-- Name: rel_constraint__violation_if_removed(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_constraint__violation_if_removed(violation_if_removed__rel_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_count                                      integer;       
  v_error                                      text; 
  constraint_violated                          record;
BEGIN
    v_error := null;

    select count(*) into v_count
      from dual
     where exists (select 1 
                     from rc_violations_by_removing_rel r 
                    where r.rel_id = violation_if_removed__rel_id);

    if v_count > 0 then
      -- some other relation depends on this one. Lets build up a string
      -- of the constraints we are violating
      for constraint_violated in select constraint_id, constraint_name
                                   from rc_violations_by_removing_rel r
                                  where r.rel_id = violation_if_removed__rel_id 
      LOOP

          v_error := v_error || 'Relational Constraint Violation: ' ||
                     constraint_violated.constraint_name || 
                     ' (constraint_id=' ||
                     constraint_violated.constraint_id || '). ';

      end loop;

    end if;

    return v_error;

   
END;
$$;


ALTER FUNCTION public.rel_constraint__violation_if_removed(violation_if_removed__rel_id integer) OWNER TO evex;

--
-- Name: rel_constraints_del_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_constraints_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_rec   record;
BEGIN

        -- now update the rel_segments that depend on this segment
        
        for v_rec in select rel_segment 
                       from rc_segment_required_seg_map
                      where required_rel_segment = old.rel_segment 
                        and rel_side = old.rel_side
        LOOP

                delete from rc_segment_required_seg_map
                      where rel_segment = v_rec.rel_segment
                        and rel_side = old.rel_side
                        and required_rel_segment 
                            in (select required_rel_segment
                                  from rc_segment_required_seg_map
                                 where rel_segment = old.rel_segment
                                   and rel_side = old.rel_side);
                
        end LOOP;

        -- delete dependencies

        delete from rc_segment_required_seg_map
              where rel_segment = old.rel_segment
                and rel_side = old.rel_side
                and required_rel_segment 
                    in (select required_rel_segment
                          from rc_segment_required_seg_map
                         where rel_segment = old.required_rel_segment
                           and rel_side = old.rel_side);

        -- delete the constraint

        delete from rc_segment_required_seg_map
              where rel_segment = old.rel_segment
                and rel_side = old.rel_side 
                and required_rel_segment = old.required_rel_segment;

        return old;

END;
$$;


ALTER FUNCTION public.rel_constraints_del_tr() OWNER TO evex;

--
-- Name: rel_constraints_ins_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_constraints_ins_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_rec   record;
BEGIN
        -- insert the constraint

        insert into rc_segment_required_seg_map
               (rel_segment, rel_side, required_rel_segment)
               values
               (new.rel_segment, new.rel_side, new.required_rel_segment);

        -- add dependencies

        insert into rc_segment_required_seg_map
             select new.rel_segment, new.rel_side, required_rel_segment
               from rc_segment_required_seg_map
              where rel_segment = new.required_rel_segment
                and rel_side = new.rel_side;

        -- now update the rel_segments that depend on this segment
        
        for v_rec in select rel_segment 
                       from rc_segment_required_seg_map
                      where required_rel_segment = new.rel_segment 
                        and rel_side = new.rel_side
        LOOP
                insert into rc_segment_required_seg_map
                     select v_rec.rel_segment, new.rel_side, 
                            required_rel_segment
                       from rc_segment_required_seg_map
                      where rel_segment = new.rel_segment
                        and rel_side = new.rel_side;
                
        end LOOP;

        return new;

END;
$$;


ALTER FUNCTION public.rel_constraints_ins_tr() OWNER TO evex;

--
-- Name: rel_segment__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segment__delete(delete__segment_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  row                           record;
BEGIN

   -- remove all constraints on this segment
   for row in  select constraint_id 
                 from rel_constraints 
                where rel_segment = delete__segment_id 
   LOOP

       PERFORM rel_constraint__delete(row.constraint_id);

   end loop;

   PERFORM party__delete(delete__segment_id);

   return 0; 
END;
$$;


ALTER FUNCTION public.rel_segment__delete(delete__segment_id integer) OWNER TO evex;

--
-- Name: rel_segment__get(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segment__get(get__group_id integer, get__rel_type character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN

   return min(segment_id)
   from rel_segments
   where group_id = get__group_id
     and rel_type = get__rel_type;
  
END;
$$;


ALTER FUNCTION public.rel_segment__get(get__group_id integer, get__rel_type character varying) OWNER TO evex;

--
-- Name: rel_segment__get_or_new(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segment__get_or_new(gid integer, typ character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return rel_segment__get_or_new(gid,typ,null);
END;
$$;


ALTER FUNCTION public.rel_segment__get_or_new(gid integer, typ character varying) OWNER TO evex;

--
-- Name: rel_segment__get_or_new(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segment__get_or_new(get_or_new__group_id integer, get_or_new__rel_type character varying, segment_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_segment_id                  rel_segments.segment_id%TYPE;
  v_segment_name                rel_segments.segment_name%TYPE;
BEGIN

   v_segment_id := rel_segment__get(get_or_new__group_id,get_or_new__rel_type);

   if v_segment_id is null then

      if segment_name is not null then
         v_segment_name := segment_name;
      else
         select groups.group_name || ' - ' || acs_object_types.pretty_name ||
                  ' segment'
         into v_segment_name
         from groups, acs_object_types
         where groups.group_id = get_or_new__group_id
           and acs_object_types.object_type = get_or_new__rel_type;

      end if;

      v_segment_id := rel_segment__new (
          null,
          'rel_segment',
          now(),
          null,
          null,
          null,
          null,
          v_segment_name,
          get_or_new__group_id,
          get_or_new__rel_type,
          get_or_new__group_id
      );

   end if;

   return v_segment_id;

  
END;
$$;


ALTER FUNCTION public.rel_segment__get_or_new(get_or_new__group_id integer, get_or_new__rel_type character varying, segment_name character varying) OWNER TO evex;

--
-- Name: rel_segment__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segment__name(name__segment_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  name__segment_name           varchar(200);  
BEGIN
  return segment_name
  from rel_segments
  where segment_id = name__segment_id;

END;
$$;


ALTER FUNCTION public.rel_segment__name(name__segment_id integer) OWNER TO evex;

--
-- Name: rel_segment__new(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segment__new(new__segment_name character varying, new__group_id integer, new__rel_type character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_segment_id           rel_segments.segment_id%TYPE;
BEGIN

   v_segment_id := rel_segment__new(null, 'rel_segment', now(), null, null, null, null, new__segment_name, new__group_id, new__rel_type, null);

   return v_segment_id;

END;
$$;


ALTER FUNCTION public.rel_segment__new(new__segment_name character varying, new__group_id integer, new__rel_type character varying) OWNER TO evex;

--
-- Name: rel_segment__new(integer, character varying, timestamp with time zone, integer, character varying, character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segment__new(new__segment_id integer, object_type character varying, creation_date timestamp with time zone, creation_user integer, creation_ip character varying, email character varying, url character varying, new__segment_name character varying, new__group_id integer, new__rel_type character varying, context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_segment_id           rel_segments.segment_id%TYPE;
BEGIN
  v_segment_id :=
   party__new(new__segment_id, object_type, creation_date, creation_user,
             creation_ip, email, url, context_id);

  update acs_objects
  set title = new__segment_name
  where object_id = v_segment_id;

  insert into rel_segments
   (segment_id, segment_name, group_id, rel_type)
  values
   (v_segment_id, new__segment_name, new__group_id, new__rel_type);

  return v_segment_id;
  
END;
$$;


ALTER FUNCTION public.rel_segment__new(new__segment_id integer, object_type character varying, creation_date timestamp with time zone, creation_user integer, creation_ip character varying, email character varying, url character varying, new__segment_name character varying, new__group_id integer, new__rel_type character varying, context_id integer) OWNER TO evex;

--
-- Name: rel_segments_del_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segments_del_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

  delete from party_approved_member_map
  where party_id = old.segment_id
    and member_id in (select element_id
                      from group_element_index
                      where group_id = old.group_id
                        and rel_type = old.rel_type);

  return old;

END;
$$;


ALTER FUNCTION public.rel_segments_del_tr() OWNER TO evex;

--
-- Name: rel_segments_in_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rel_segments_in_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

  insert into party_approved_member_map
    (party_id, member_id, originating_rel_id)
  select new.segment_id, element_id, rel_id
    from group_element_index
    where group_id = new.group_id
      and rel_type = new.rel_type;

  return new;

END;
$$;


ALTER FUNCTION public.rel_segments_in_tr() OWNER TO evex;

--
-- Name: rss_gen_subscr__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rss_gen_subscr__del(p_subscr_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	delete from acs_permissions
		   where object_id = p_subscr_id;

	delete from rss_gen_subscrs
		   where subscr_id = p_subscr_id;

	raise NOTICE 'Deleting subscription...';
	PERFORM acs_object__delete(p_subscr_id);

	return 0;

END;
$$;


ALTER FUNCTION public.rss_gen_subscr__del(p_subscr_id integer) OWNER TO evex;

--
-- Name: rss_gen_subscr__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rss_gen_subscr__delete(p_subscr_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  return rss_gen_subscr__del (p_subscr_id);
END;
$$;


ALTER FUNCTION public.rss_gen_subscr__delete(p_subscr_id integer) OWNER TO evex;

--
-- Name: rss_gen_subscr__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rss_gen_subscr__name(p_subscr_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	return 'RSS Generation Subscription #' || p_subscr_id;
END;
$$;


ALTER FUNCTION public.rss_gen_subscr__name(p_subscr_id integer) OWNER TO evex;

--
-- Name: rss_gen_subscr__new(integer, integer, character varying, integer, timestamp with time zone, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rss_gen_subscr__new(p_subscr_id integer, p_impl_id integer, p_summary_context_id character varying, p_timeout integer, p_lastbuild timestamp with time zone, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_subscr_id			rss_gen_subscrs.subscr_id%TYPE;
  v_summary_context_id  rss_gen_subscrs.summary_context_id%TYPE;
BEGIN
	v_subscr_id := acs_object__new (
		p_subscr_id,
		p_object_type,
		p_creation_date,
		p_creation_user,
		p_creation_ip,
		p_context_id
	);

        if p_summary_context_id is null then
          v_summary_context_id := v_subscr_id;
        else
          v_summary_context_id := p_summary_context_id;
        end if;

	insert into rss_gen_subscrs
	  (subscr_id, impl_id, summary_context_id, timeout, lastbuild)
	values
	  (v_subscr_id, p_impl_id, v_summary_context_id, p_timeout, p_lastbuild);

	return v_subscr_id;

END;
$$;


ALTER FUNCTION public.rss_gen_subscr__new(p_subscr_id integer, p_impl_id integer, p_summary_context_id character varying, p_timeout integer, p_lastbuild timestamp with time zone, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: rule_exists(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.rule_exists(rule_name character varying, table_name character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
BEGIN
        return count(*) = 1
          from pg_rules
         where tablename::varchar = lower(table_name)
           and rulename::varchar = lower(rule_name);

END;
$$;


ALTER FUNCTION public.rule_exists(rule_name character varying, table_name character varying) OWNER TO evex;

--
-- Name: search_columns_evex(text, name[], name[]); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.search_columns_evex(needle text, haystack_tables name[] DEFAULT '{}'::name[], haystack_schema name[] DEFAULT '{public}'::name[]) RETURNS TABLE(schemaname text, tablename text, columnname text, rowctid text)
    LANGUAGE plpgsql
    AS $$
	    begin
	      FOR schemaname,tablename,columnname IN
	            SELECT c.table_schema,c.table_name,c.column_name
		          FROM information_schema.columns c
			        JOIN information_schema.tables t ON
				        (t.table_name=c.table_name AND t.table_schema=c.table_schema)
					      WHERE (c.table_name=ANY(haystack_tables) OR haystack_tables='{}')
					              AND c.table_schema=ANY(haystack_schema)
						              AND t.table_type='BASE TABLE'
							        LOOP
								    EXECUTE format('SELECT ctid FROM %I.%I WHERE cast(%I as text)=%L',
								           schemaname,
									          tablename,
										         columnname,
											        needle
												    ) INTO rowctid;
												        IF rowctid is not null THEN
													      RETURN NEXT;
													          END IF;
														   END LOOP;
														   END;
														   $$;


ALTER FUNCTION public.search_columns_evex(needle text, haystack_tables name[], haystack_schema name[]) OWNER TO evex;

--
-- Name: search_observer__dequeue(integer, timestamp with time zone, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.search_observer__dequeue(p_object_id integer, p_event_date timestamp with time zone, p_event character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

    delete from search_observer_queue 
    where object_id = p_object_id 
    and event = p_event
    and to_char(event_date,'yyyy-mm-dd hh24:mi:ss.us-tz') = to_char(p_event_date,'yyyy-mm-dd hh24:mi:ss.us-tz');

    return 0;

END;
$$;


ALTER FUNCTION public.search_observer__dequeue(p_object_id integer, p_event_date timestamp with time zone, p_event character varying) OWNER TO evex;

--
-- Name: search_observer__enqueue(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.search_observer__enqueue(p_object_id integer, p_event character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    insert into search_observer_queue (
	object_id,
	event
    ) values (
        p_object_id,
	p_event
    );

    return 0;

END;
$$;


ALTER FUNCTION public.search_observer__enqueue(p_object_id integer, p_event character varying) OWNER TO evex;

--
-- Name: sec_session_property__upsert(bigint, character varying, character varying, character varying, boolean, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.sec_session_property__upsert(p_session_id bigint, p_module character varying, p_name character varying, p_value character varying, p_secure_p boolean, p_last_hit integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    LOOP
        -- first try to update the key
    update sec_session_properties
        set   property_value = p_value, secure_p = p_secure_p, last_hit = p_last_hit 
        where session_id = p_session_id and module = p_module and property_name = p_name;
        IF found THEN
            return;
        END IF;
        -- not there, so try to insert the key
        -- if someone else inserts the same key concurrently,
        -- we could get a unique-key failure
        BEGIN
            insert into sec_session_properties
                   (session_id,   module,   property_name, secure_p,   last_hit)
            values (p_session_id, p_module, p_name,        p_secure_p, p_last_hit);
            RETURN;
            EXCEPTION WHEN unique_violation THEN
            -- Do nothing, and loop to try the UPDATE again.
        END;
    END LOOP;
END;
$$;


ALTER FUNCTION public.sec_session_property__upsert(p_session_id bigint, p_module character varying, p_name character varying, p_value character varying, p_secure_p boolean, p_last_hit integer) OWNER TO evex;

--
-- Name: site_node__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node__delete(delete__node_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from site_nodes
    where node_id = delete__node_id;

    PERFORM acs_object__delete(delete__node_id);

    return 0; 
END;
$$;


ALTER FUNCTION public.site_node__delete(delete__node_id integer) OWNER TO evex;

--
-- Name: site_node__find_pattern(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node__find_pattern(find_pattern__node_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_pattern_p                   site_nodes.pattern_p%TYPE;
  v_parent_id                   site_nodes.node_id%TYPE;
BEGIN
    if find_pattern__node_id is null then
--      raise no_data_found;
        raise exception 'NO DATA FOUND';
    end if;

    select pattern_p, parent_id into v_pattern_p, v_parent_id
    from site_nodes
    where node_id = find_pattern__node_id;

    if v_pattern_p = 't' then
      return find_pattern__node_id;
    else
      return site_node__find_pattern(v_parent_id);
    end if;
   
END;
$$;


ALTER FUNCTION public.site_node__find_pattern(find_pattern__node_id integer) OWNER TO evex;

--
-- Name: site_node__new(integer, integer, character varying, integer, boolean, boolean, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node__new(new__node_id integer, new__parent_id integer, new__name character varying, new__object_id integer, new__directory_p boolean, new__pattern_p boolean, new__creation_user integer, new__creation_ip character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_node_id                   site_nodes.node_id%TYPE;
  v_directory_p               site_nodes.directory_p%TYPE;
BEGIN
    if new__parent_id is not null then
      select directory_p into v_directory_p
      from site_nodes
      where node_id = new__parent_id;

      if v_directory_p = 'f' then
        raise EXCEPTION '-20000: Node % is not a directory', new__parent_id;
      end if;
    end if;

    v_node_id := acs_object__new (
      new__node_id,
      'site_node',
      now(),
      new__creation_user,
      new__creation_ip,
      null,
      't',
      new__name,
      new__object_id
    );

    insert into site_nodes
     (node_id, parent_id, name, object_id, directory_p, pattern_p)
    values
     (v_node_id, new__parent_id, new__name, new__object_id,
      new__directory_p, new__pattern_p);

     return v_node_id;
   
END;
$$;


ALTER FUNCTION public.site_node__new(new__node_id integer, new__parent_id integer, new__name character varying, new__object_id integer, new__directory_p boolean, new__pattern_p boolean, new__creation_user integer, new__creation_ip character varying) OWNER TO evex;

--
-- Name: site_node__node_id(character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node__node_id(p_url character varying, p_parent_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_pos                  integer;
  v_first                site_nodes.name%TYPE;
  v_rest                 text; 
  v_node_id              integer;       
  v_pattern_p            site_nodes.pattern_p%TYPE;
  v_url                  text; 
  v_directory_p          site_nodes.directory_p%TYPE;
  v_trailing_slash_p     boolean;       
BEGIN
    v_url := p_url;

    if substr(v_url, length(v_url), 1) = '/' then
      --
      -- The URL ends with a / so it must be a directory. Strip the
      -- trailing slash.
      --
      v_trailing_slash_p := true;
      v_url := substr(v_url, 1, length(v_url) - 1);
    end if;

    --
    -- Split the URL on the first "/" into v_first and v_rest. 
    --
    select position('/' in v_url) into v_pos;

    if v_pos = 0 then
      --
      -- No slash found
      --
      v_first := v_url;
      v_rest := null;
    else
      --
      -- Split URL
      --
      v_first := substr(v_url, 1, v_pos - 1);
      v_rest := substr(v_url, v_pos + 1);
    end if;

    if p_parent_id is not null then 
      select node_id, directory_p into v_node_id, v_directory_p
      from site_nodes
      where parent_id = p_parent_id
      and name = v_first;
    else
      --
      -- This is typically just the query on the (empty) top-node.
      --
      select node_id, directory_p into v_node_id, v_directory_p
      from site_nodes
      where parent_id is null 
      and name = v_first;
    end if;

    if NOT FOUND then 
        return site_node__find_pattern(p_parent_id);
    end if;

    --
    -- v_first was found. 
    --
    if v_rest is null then
      --
      -- We are at the end of the URL. If we have a trailing slash and
      -- the site node is not a directory, return the result of
      -- find_pattern(). Otherwise, return the found node_id
      --
      if v_trailing_slash_p is true and v_directory_p is false then
        return site_node__find_pattern(p_parent_id);
      else
        return v_node_id;
      end if;
    else
      --
      -- Call the function recursively on the v_rest chunk
      --
      return site_node__node_id(v_rest, v_node_id);
    end if;
END;
$$;


ALTER FUNCTION public.site_node__node_id(p_url character varying, p_parent_id integer) OWNER TO evex;

--
-- Name: site_node__url(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node__url(url__node_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
        BEGIN
            return ( With RECURSIVE site_nodes_recursion(parent_id, path, directory_p, node_id) as (
            
                select parent_id, ARRAY[name || case when directory_p then '/' else ' ' end]::text[] as path, directory_p, node_id
                from site_nodes where node_id = url__node_id
            
                UNION ALL
            
                select sn.parent_id, sn.name::text || snr.path , sn.directory_p, snr.parent_id
                from site_nodes sn join site_nodes_recursion snr on sn.node_id = snr.parent_id 
                where snr.parent_id is not null    

            ) select array_to_string(path,'/') from site_nodes_recursion where parent_id is null
        );
        END; 
        $$;


ALTER FUNCTION public.site_node__url(url__node_id integer) OWNER TO evex;

--
-- Name: site_node_get_tree_sortkey(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node_get_tree_sortkey(p_node_id integer) RETURNS bit varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN
  return tree_sortkey from site_nodes where node_id = p_node_id;
END;
$$;


ALTER FUNCTION public.site_node_get_tree_sortkey(p_node_id integer) OWNER TO evex;

--
-- Name: site_node_insert_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node_insert_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_sk     varbit default null;
        v_max_value     integer;
BEGIN
        if new.parent_id is null then
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
              from site_nodes 
             where parent_id is null;
        else
            select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value 
              from site_nodes 
             where parent_id = new.parent_id;

            select tree_sortkey into v_parent_sk 
              from site_nodes 
             where node_id = new.parent_id;
        end if;

        new.tree_sortkey := tree_next_key(v_parent_sk, v_max_value);

        return new;

END;
$$;


ALTER FUNCTION public.site_node_insert_tr() OWNER TO evex;

--
-- Name: site_node_object_map__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node_object_map__del(p_object_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete
    from site_node_object_mappings
    where object_id = p_object_id;

    return 0;
END;

$$;


ALTER FUNCTION public.site_node_object_map__del(p_object_id integer) OWNER TO evex;

--
-- Name: site_node_object_map__new(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node_object_map__new(p_object_id integer, p_node_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    perform site_node_object_map__del(p_object_id);

    insert
    into site_node_object_mappings
    (object_id, node_id)
    values
    (p_object_id, p_node_id);

    return 0;
END;

$$;


ALTER FUNCTION public.site_node_object_map__new(p_object_id integer, p_node_id integer) OWNER TO evex;

--
-- Name: site_node_update_tr(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.site_node_update_tr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        v_parent_sk     varbit default null;
        v_max_value     integer;
        p_id            integer;
        v_rec           record;
        clr_keys_p      boolean default 't';
BEGIN
        if new.node_id = old.node_id and 
           ((new.parent_id = old.parent_id) or 
            (new.parent_id is null and old.parent_id is null)) then

           return new;

        end if;

        for v_rec in select node_id
                       from site_nodes 
                      where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey)
                   order by tree_sortkey
        LOOP
            if clr_keys_p then
               update site_nodes set tree_sortkey = null
               where tree_sortkey between new.tree_sortkey and tree_right(new.tree_sortkey);
               clr_keys_p := 'f';
            end if;
            
            select parent_id into p_id
              from site_nodes 
             where node_id = v_rec.node_id;

            if p_id is null then
                select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
                  from site_nodes
                 where parent_id is null;
            else
                select max(tree_leaf_key_to_int(tree_sortkey)) into v_max_value
                  from site_nodes 
                 where parent_id = p_id;

                select tree_sortkey into v_parent_sk 
                  from site_nodes 
                 where node_id = p_id;
            end if;

            update site_nodes 
               set tree_sortkey = tree_next_key(v_parent_sk, v_max_value)
             where node_id = v_rec.node_id;

        end LOOP;

        return new;

END;
$$;


ALTER FUNCTION public.site_node_update_tr() OWNER TO evex;

--
-- Name: split(character varying, character, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.split(p_string character varying, p_split_char character, p_element integer) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE

  v_left_split		integer;
  v_right_split		integer;
  v_len			integer;
BEGIN
  v_len = length(p_string);
  if v_len = 0 or p_string is null or p_element <= 0 then
    return NULL;
  end if;
  if p_element = 1 then
    v_left_split := 0;
  else
    v_left_split := instr(p_string, p_split_char, 1, p_element-1);
  end if;
  v_right_split := instr(p_string, p_split_char, 1, p_element);
  if v_right_split = 0 then
    v_right_split = v_len + 1;
  end if;
  if v_left_split = 0 and v_right_split = v_len+1 and p_element <> 1 then
    return null;
  end if;
  return substr(p_string, v_left_split+1, (v_right_split - v_left_split - 1));
END;
$$;


ALTER FUNCTION public.split(p_string character varying, p_split_char character, p_element integer) OWNER TO evex;

--
-- Name: subsite_callback__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.subsite_callback__delete(delete__callback_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      delete from subsite_callbacks where callback_id = delete__callback_id;
      return 0;
END;
$$;


ALTER FUNCTION public.subsite_callback__delete(delete__callback_id integer) OWNER TO evex;

--
-- Name: subsite_callback__new(integer, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.subsite_callback__new(new__callback_id integer, new__event_type character varying, new__object_type character varying, new__callback character varying, new__callback_type character varying, new__sort_order integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_callback_id		   subsite_callbacks.callback_id%TYPE;
  v_sort_order		   subsite_callbacks.sort_order%TYPE;
BEGIN

    if new__callback_id is null then
       select nextval('t_acs_object_id_seq') into v_callback_id;
    else
       v_callback_id := new__callback_id;
    end if;
   
    if new__sort_order is null then
       -- Make this the next event for this object_type/event_type combination
       select coalesce(max(sort_order),0) + 1 into v_sort_order
         from subsite_callbacks
        where object_type = new__object_type
          and event_type = new__event_type;
    else
       v_sort_order := new__sort_order;
    end if;

--    begin 
      insert into subsite_callbacks
      (callback_id, event_type, object_type, callback, callback_type, sort_order)
      values
      (v_callback_id, new__event_type, new__object_type, new__callback, new__callback_type, v_sort_order);

-- TODO: Can we do this properly?
--       If not, could move select before insert
--      exception when dup_val_on_index then
--        select callback_id into v_callback_id
--          from subsite_callbacks
--         where event_type = new__event_type
--           and object_type = new__object_type
--           and callback_type = new__callback_type
--           and callback = new__callback;
--    end;
    return v_callback_id;

END;
$$;


ALTER FUNCTION public.subsite_callback__new(new__callback_id integer, new__event_type character varying, new__object_type character varying, new__callback character varying, new__callback_type character varying, new__sort_order integer) OWNER TO evex;

--
-- Name: table_exists(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.table_exists(table_exists__table_name character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
BEGIN

        return count(*) > 0
          from pg_class 
         where relname = lower(table_exists__table_name);
 
END;
$$;


ALTER FUNCTION public.table_exists(table_exists__table_name character varying) OWNER TO evex;

--
-- Name: telecom_number__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.telecom_number__del(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
 p_number_id    alias for $1; 
 v_return integer := 0;  
begin 

   delete from acs_permissions 
     where object_id = p_number_id; 

   delete from telecom_numbers 
     where number_id = p_number_id;

   raise NOTICE 'Deleting telecom_number - %',p_number_id;

   PERFORM acs_object__delete(p_number_id);
   return v_return;

end;$_$;


ALTER FUNCTION public.telecom_number__del(integer) OWNER TO evex;

--
-- Name: telecom_number__new(character varying, character varying, character varying, integer, character varying, character varying, integer, integer, integer, boolean, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.telecom_number__new(character varying, character varying, character varying, integer, character varying, character varying, integer, integer, integer, boolean, character varying, integer, character varying, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
declare 
    p_area_city_code       alias for $1; -- comment
    p_best_contact_time    alias for $2; -- comment
    p_extension            alias for $3; -- comment
    p_itu_id               alias for $4; -- comment
    p_location             alias for $5; -- comment
    p_national_number      alias for $6; -- comment
    p_number_id            alias for $7; -- comment
    p_party_id             alias for $8; -- comment
    p_phone_type_id        alias for $9; -- comment
    p_sms_enabled_p        alias for $10; -- comment
    p_subscriber_number    alias for $11; -- comment
    p_creation_user        alias for $12; -- comment
    p_creation_ip          alias for $13; -- comment
    p_context_id           alias for $14; -- comment

    -- local vars
    v_number_id telecom_numbers.number_id%TYPE; 
begin 
  v_number_id := acs_object__new (  
    null,  
    'telecom_number',
    now(), 
    p_creation_user, 
    p_creation_ip, 
    p_context_id 
  );   
   

  insert into telecom_numbers (
    area_city_code,
    best_contact_time,
    extension,
    itu_id,
    location,
    national_number,
    number_id,
    party_id,
    phone_type_id,
    sms_enabled_p,
    subscriber_number 
  )  
  values ( 
    p_area_city_code,
    p_best_contact_time,
    p_extension,
    p_itu_id,
    p_location,
    p_national_number,
    v_number_id,
    p_party_id,
    p_phone_type_id,
    p_sms_enabled_p,
    p_subscriber_number 
  ); 

  PERFORM acs_permission__grant_permission (
     v_number_id,
     p_creation_user,
     'admin'
  );

   raise NOTICE 'Adding telecom_number - %',v_number_id;
  return v_number_id;

end;$_$;


ALTER FUNCTION public.telecom_number__new(character varying, character varying, character varying, integer, character varying, character varying, integer, integer, integer, boolean, character varying, integer, character varying, integer) OWNER TO evex;

--
-- Name: template_demo_note__del(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.template_demo_note__del(p_template_demo_note_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    delete from acs_permissions
           where object_id = p_template_demo_note_id;

    delete from template_demo_notes
           where template_demo_note_id = p_template_demo_note_id;

    raise NOTICE 'Deleting note...';
    PERFORM acs_object__delete(p_template_demo_note_id);

    return 0;

END;
$$;


ALTER FUNCTION public.template_demo_note__del(p_template_demo_note_id integer) OWNER TO evex;

--
-- Name: template_demo_note__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.template_demo_note__name(p_template_demo_note_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_template_demo_note_name    template_demo_notes.title%TYPE;
BEGIN
    select title into v_template_demo_note_name
        from template_demo_notes
        where template_demo_note_id = p_template_demo_note_id;

    return v_template_demo_note_name;
END;

$$;


ALTER FUNCTION public.template_demo_note__name(p_template_demo_note_id integer) OWNER TO evex;

--
-- Name: template_demo_note__new(integer, character varying, character varying, character varying, character varying, timestamp with time zone, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.template_demo_note__new(p_template_demo_note_id integer, p_title character varying, p_body character varying, p_color character varying, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_template_demo_note_id      template_demo_notes.template_demo_note_id%TYPE;
BEGIN
    v_template_demo_note_id := acs_object__new (
        p_template_demo_note_id,
        p_object_type,
        p_creation_date,
        p_creation_user,
        p_creation_ip,
        p_context_id
    );

    insert into template_demo_notes
      (template_demo_note_id, title, body, color)
    values
      (v_template_demo_note_id, p_title, p_body, p_color);

    if p_creation_user is not null then
      PERFORM acs_permission__grant_permission(
            v_template_demo_note_id,
            p_creation_user,
            'admin'
      );
    end if;

    return v_template_demo_note_id;

END;
$$;


ALTER FUNCTION public.template_demo_note__new(p_template_demo_note_id integer, p_title character varying, p_body character varying, p_color character varying, p_object_type character varying, p_creation_date timestamp with time zone, p_creation_user integer, p_creation_ip character varying, p_context_id integer) OWNER TO evex;

--
-- Name: time_interval__copy(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__copy(copy__interval_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- return time_intervals.interval_id%TYPE
DECLARE    
       v_query               varchar;
       v_result              time_intervals.interval_id%TYPE;
       rec_datecalc          record;
BEGIN
        return time_interval__copy(
                   copy__interval_id,
                   interval '0 days'
                   );

END;
$$;


ALTER FUNCTION public.time_interval__copy(copy__interval_id integer) OWNER TO evex;

--
-- Name: time_interval__copy(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__copy(copy__interval_id integer, copy__offset integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE    
BEGIN

       return time_interval__copy(
                  copy__interval_id,
                  to_interval(copy__offset,'days')
                  );

END;
$$;


ALTER FUNCTION public.time_interval__copy(copy__interval_id integer, copy__offset integer) OWNER TO evex;

--
-- Name: time_interval__copy(integer, interval); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__copy(copy__interval_id integer, copy__offset interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE    
       interval_row           time_intervals%ROWTYPE;
       v_foo                 timestamptz;
BEGIN
       select * into interval_row
       from   time_intervals
       where  interval_id = copy__interval_id;
	
       return time_interval__new(
                  (interval_row.start_date ::timestamp + copy__offset) :: timestamptz,
                  (interval_row.end_date ::timestamp + copy__offset) :: timestamptz
                  );

END;
$$;


ALTER FUNCTION public.time_interval__copy(copy__interval_id integer, copy__offset interval) OWNER TO evex;

--
-- Name: time_interval__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__delete(delete__interval_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       delete from time_intervals
       where  interval_id = delete__interval_id;

       return 0;
END;
$$;


ALTER FUNCTION public.time_interval__delete(delete__interval_id integer) OWNER TO evex;

--
-- Name: time_interval__edit(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__edit(edit__interval_id integer, edit__start_date timestamp with time zone, edit__end_date timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

        -- JS: I hate deeply nested if-else-ifs!!! 

        -- Null for start_date or end_date means dont change.
        if edit__start_date is not null and edit__end_date is not null then
            update time_intervals
            set    start_date  = edit__start_date,
                   end_date    = edit__end_date
            where  interval_id = edit__interval_id;
        end if;

        -- Update only the end date if not null even if start date is null
        if edit__start_date is not null and edit__end_date is null 
        then
            update time_intervals
            set    start_date  = edit__start_date
            where  interval_id = edit__interval_id;
        end if;
            
        -- Update only the start date if not null even if end date is null
        if edit__end_date is not null and edit__start_date is null 
        then
                 update time_intervals
                 set end_date       = edit__end_date
                 where interval_id  = edit__interval_id;
        end if;

        return 0;

END;
$$;


ALTER FUNCTION public.time_interval__edit(edit__interval_id integer, edit__start_date timestamp with time zone, edit__end_date timestamp with time zone) OWNER TO evex;

--
-- Name: time_interval__eq(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__eq(eq__interval_1_id integer, eq__interval_2_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
--  return boolean
DECLARE
       interval_1_row time_intervals%ROWTYPE;
       interval_2_row time_intervals%ROWTYPE;
BEGIN
       select * into interval_1_row
       from   time_intervals
       where  interval_id = eq__interval_1_id;

       select * into interval_2_row
       from   time_intervals
       where  interval_id = eq__interval_2_id;

       if interval_1_row.start_date = interval_2_row.start_date and 
          interval_1_row.end_date = interval_2_row.end_date 
       then
            return true;
       else
            return false;
       end if;

END;
$$;


ALTER FUNCTION public.time_interval__eq(eq__interval_1_id integer, eq__interval_2_id integer) OWNER TO evex;

--
-- Name: time_interval__new(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__new(new__start_date timestamp with time zone, new__end_date timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_interval_id     time_intervals.interval_id%TYPE;
BEGIN
       select nextval('timespan_sequence') into v_interval_id from dual;

       insert into time_intervals 
            (interval_id, start_date, end_date)
       values
            (v_interval_id, new__start_date, new__end_date);
                
       return v_interval_id;

END;
$$;


ALTER FUNCTION public.time_interval__new(new__start_date timestamp with time zone, new__end_date timestamp with time zone) OWNER TO evex;

--
-- Name: time_interval__overlaps_p(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__overlaps_p(overlaps_p__interval_id_1 integer, overlaps_p__interval_id_2 integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_start_1                   timestamptz;
       v_start_2                   timestamptz;
       v_end_1                     timestamptz;
       v_end_2                     timestamptz;
BEGIN
       -- Pull out the start and end dates and call the main overlaps_p.
       select start_date, end_date
       into   v_start_1, v_end_1
       from   time_intervals
       where  interval_id = overlaps_p__interval_id_1;

       select start_date, end_date
       into   v_start_2, v_end_2
       from   time_intervals
       where  interval_id = overlaps_p__interval_id_2;

       return time_interval__overlaps_p(
                  v_start_1, 
                  v_end_1, 
                  v_start_2, 
                  v_end_2
                  );

END;
$$;


ALTER FUNCTION public.time_interval__overlaps_p(overlaps_p__interval_id_1 integer, overlaps_p__interval_id_2 integer) OWNER TO evex;

--
-- Name: time_interval__overlaps_p(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__overlaps_p(overlaps_p__interval_id integer, overlaps_p__start_date timestamp with time zone, overlaps_p__end_date timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_interval_start            time_intervals.start_date%TYPE;
       v_interval_end              time_intervals.end_date%TYPE;
BEGIN
       -- Pull out the start and end date and call the main overlaps_p.
       select start_date, end_date
       into   v_interval_start, v_interval_end
       from   time_intervals
       where  interval_id = overlaps_p__interval_id;

       return time_interval__overlaps_p(
                  v_interval_start, 
                  v_interval_end, 
                  overlaps_p__start_date, 
                  overlaps_p__end_date
                  );

END;
$$;


ALTER FUNCTION public.time_interval__overlaps_p(overlaps_p__interval_id integer, overlaps_p__start_date timestamp with time zone, overlaps_p__end_date timestamp with time zone) OWNER TO evex;

--
-- Name: time_interval__overlaps_p(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__overlaps_p(overlaps_p__start_1 timestamp with time zone, overlaps_p__end_1 timestamp with time zone, overlaps_p__start_2 timestamp with time zone, overlaps_p__end_2 timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

       -- JS: Modified yet another deeply nested if-else-if
       -- JS: Note that null date is the representation for infinite 
       -- (positive or negative) time. 
       if overlaps_p__start_1 is null 
       then
            -- No overlap if 2nd interval starts after 1st ends
            if overlaps_p__end_1 < overlaps_p__start_2 
            then
                return false;
            else
                return true;
            end if;
       end if;

       if overlaps_p__start_2 is null 
       then
            -- No overlap if 2nd interval ends before 1st starts
            if overlaps_p__end_2 < overlaps_p__start_1 
            then
                return false;
            else
                return true;
            end if;
       end if;

       -- Okay, both start dates are not null
       if overlaps_p__start_1 <= overlaps_p__start_2 
       then
            -- 1st starts before 2nd
            if overlaps_p__end_1 < overlaps_p__start_2 
            then
                  -- No overlap if 1st ends before 2nd starts
                  return false;
            else
                 -- No overlap or at least one null
                 return true;
            end if;

       else

            -- 1st starts after 2nd
            if overlaps_p__end_2 < overlaps_p__start_1 
            then
                 -- No overlap if 2nd ends before 1st starts
                 return false;
            else
                 -- No overlap or at least one null
                 return true;
            end if;

       end if;

END;
$$;


ALTER FUNCTION public.time_interval__overlaps_p(overlaps_p__start_1 timestamp with time zone, overlaps_p__end_1 timestamp with time zone, overlaps_p__start_2 timestamp with time zone, overlaps_p__end_2 timestamp with time zone) OWNER TO evex;

--
-- Name: time_interval__shift(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__shift(shift__interval_id integer, shift__start_offset integer, shift__end_offset integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE 
BEGIN

      return time_interval__shift(
                 shift__interval_id,
                 to_interval(shift__start_offset,'days'),
                 to_interval(shift__end_offset,'days')
                 );

END;
$$;


ALTER FUNCTION public.time_interval__shift(shift__interval_id integer, shift__start_offset integer, shift__end_offset integer) OWNER TO evex;

--
-- Name: time_interval__shift(integer, interval, interval); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.time_interval__shift(shift__interval_id integer, shift__start_offset interval, shift__end_offset interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE 
BEGIN
       update time_intervals
       set    start_date = start_date + shift__start_offset,
              end_date   = end_date + shift__end_offset
       where  interval_id = shift__interval_id;

       return 0;

END;
$$;


ALTER FUNCTION public.time_interval__shift(shift__interval_id integer, shift__start_offset interval, shift__end_offset interval) OWNER TO evex;

--
-- Name: timespan__copy(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__copy(copy__timespan_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- timespans.timespan_id%TYPE
DECLARE
BEGIN

       return timespan__copy(
                    copy__timespan_id,
                    interval '0 days'
                    );

END;
$$;


ALTER FUNCTION public.timespan__copy(copy__timespan_id integer) OWNER TO evex;

--
-- Name: timespan__copy(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__copy(copy__timespan_id integer, copy__offset integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       return timespan__copy(
                    copy__timespan_id,
                    to_interval(copy__offset,'days')
                    );

END;
$$;


ALTER FUNCTION public.timespan__copy(copy__timespan_id integer, copy__offset integer) OWNER TO evex;

--
-- Name: timespan__copy(integer, interval); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__copy(copy__timespan_id integer, copy__offset interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       rec_timespan             record;
       v_interval_id            timespans.interval_id%TYPE;
       v_timespan_id            timespans.timespan_id%TYPE;
BEGIN
       v_timespan_id := null;

       -- Loop over each interval in timespan, creating a new copy
       for rec_timespan in 
            select * 
            from timespans
            where timespan_id = copy__timespan_id
       loop
            v_interval_id := time_interval__copy(
                                rec_timespan.interval_id, 
                                copy__offset
                                );

            if v_timespan_id is null 
            then
                 -- JS: NOTE DEFAULT BEHAVIOR OF timespan__new
                v_timespan_id := timespan__new(v_interval_id);
            else
                -- no copy, use whatever is generated by time_interval__copy
                PERFORM timespan__join_interval(
                                v_timespan_id, 
                                v_interval_id,
                                false);
            end if;

       end loop;

       return v_timespan_id;

END;
$$;


ALTER FUNCTION public.timespan__copy(copy__timespan_id integer, copy__offset interval) OWNER TO evex;

--
-- Name: timespan__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__delete(delete__timespan_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
       -- Delete intervals, corresponding timespan entries deleted by
       -- cascading constraints

       delete from time_intervals
       where  interval_id in (select interval_id
                              from   timespans
                              where  timespan_id = delete__timespan_id);
       return 0;

END;
$$;


ALTER FUNCTION public.timespan__delete(delete__timespan_id integer) OWNER TO evex;

--
-- Name: timespan__exists_p(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__exists_p(exists_p__timespan_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_result         integer;
BEGIN
       -- Only need to check if any rows exist. 
       select count(*)
       into   v_result
       from dual
       where exists (select timespan_id
                     from   timespans
                     where  timespan_id = exists_p__timespan_id);

       if v_result = 0 then
           return false;
       else
           return true;
       end if;

END;
$$;


ALTER FUNCTION public.timespan__exists_p(exists_p__timespan_id integer) OWNER TO evex;

--
-- Name: timespan__interval_delete(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__interval_delete(interval_delete__timespan_id integer, interval_delete__interval_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

       delete from timespans
       where timespan_id = interval_delete__timespan_id
       and   interval_id = interval_delete__interval_id;

       return 0;

END;
$$;


ALTER FUNCTION public.timespan__interval_delete(interval_delete__timespan_id integer, interval_delete__interval_id integer) OWNER TO evex;

--
-- Name: timespan__join(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__join(join__timespan_1_id integer, join__timespan_2_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_interval_id          time_intervals.interval_id%TYPE;
       rec_timespan           record;
BEGIN
       -- Loop over intervals in 2nd timespan, join with 1st.
       for rec_timespan in 
            select * 
            from   timespans
            where  timespan_id = join__timespan_2_id
       loop
            v_interval_id := timespan__join_interval(
                                  join__timespan_1_id, 
                                  rec_timespan.interval_id,
                                  false
                                  );
       end loop;

       -- JS: Return the last interval id joined.  Not very useful, since there may be
       -- JS: more than one interval joined
       return v_interval_id;

END;
$$;


ALTER FUNCTION public.timespan__join(join__timespan_1_id integer, join__timespan_2_id integer) OWNER TO evex;

--
-- Name: timespan__join(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__join(join__timespan_id integer, join__start_date timestamp with time zone, join__end_date timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

       -- JS: This will create a new interval with start_date and end_date
       -- JS: so we might as well return the interval id 
       return timespan__join_interval(
                join__timespan_id, 
                time_interval__new(join__start_date, join__end_date),
                false
                );

END;
$$;


ALTER FUNCTION public.timespan__join(join__timespan_id integer, join__start_date timestamp with time zone, join__end_date timestamp with time zone) OWNER TO evex;

--
-- Name: timespan__join_interval(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__join_interval(join_interval__timespan_id integer, join_interval__interval_id integer, join_interval__copy_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- time_intervals.interval_id%TYPE
DECLARE
       v_interval_id                  time_intervals.interval_id%TYPE;
BEGIN
       if join_interval__copy_p then
           v_interval_id := time_interval__copy(join_interval__interval_id);
       else
           v_interval_id := join_interval__interval_id;
       end if;
        
       insert into timespans
            (timespan_id, interval_id)
       values
            (join_interval__timespan_id, v_interval_id);

       -- JS: We might as well return the interval id being joined, instead of returning a dummy integer
       return v_interval_id;

END;
$$;


ALTER FUNCTION public.timespan__join_interval(join_interval__timespan_id integer, join_interval__interval_id integer, join_interval__copy_p boolean) OWNER TO evex;

--
-- Name: timespan__multi_interval_p(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__multi_interval_p(multi_interval_p__timespan_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_result                 boolean;
BEGIN
       -- 'f' if 0 or 1 intervals, 't' otherwise
       -- use the simple case syntax
       select (case count(timespan_id) 
                    when 0 then false
                    when 1 then false 
                    else true
               end)
       into v_result
       from timespans
       where timespan_id = multi_interval_p__timespan_id;
        
       return v_result;

END;
$$;


ALTER FUNCTION public.timespan__multi_interval_p(multi_interval_p__timespan_id integer) OWNER TO evex;

--
-- Name: timespan__new(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__new(new__interval_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
        return timespan__new(
                   new__interval_id,
                   true
                   );
        
END;
$$;


ALTER FUNCTION public.timespan__new(new__interval_id integer) OWNER TO evex;

--
-- Name: timespan__new(integer, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__new(new__interval_id integer, new__copy_p boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- timespans.timespan_id%TYPE
DECLARE
        v_timespan_id           timespans.timespan_id%TYPE;
        v_interval_id           time_intervals.interval_id%TYPE;
BEGIN
        -- get a new id;
        select nextval('timespan_sequence') into v_timespan_id from dual;

        if new__copy_p
        then      
             -- JS: Note use of overloaded function (zero offset)
             v_interval_id := time_interval__copy(new__interval_id);
        else
             v_interval_id := new__interval_id;
        end if;
        
        insert into timespans
            (timespan_id, interval_id)
        values
            (v_timespan_id, v_interval_id);
        
        return v_timespan_id;

END;
$$;


ALTER FUNCTION public.timespan__new(new__interval_id integer, new__copy_p boolean) OWNER TO evex;

--
-- Name: timespan__new(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__new(new__start_date timestamp with time zone, new__end_date timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

       -- JS: If we simply call timespan__new with default copy_p = true,
       -- JS: there will be two new time intervals that will be created
       -- JS: everytime this function is called. The first one will never be used!!! 
       -- JS: To fix, we use the timespan__new with copy_p parameter and
       -- JS: setting copy_p to false.
       return timespan__new(time_interval__new(new__start_date, new__end_date),false);

END;
$$;


ALTER FUNCTION public.timespan__new(new__start_date timestamp with time zone, new__end_date timestamp with time zone) OWNER TO evex;

--
-- Name: timespan__overlaps_interval_p(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__overlaps_interval_p(overlaps_interval_p__timespan_id integer, overlaps_interval_p__interval_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_start_date               timestamptz;
       v_end_date                 timestamptz;
BEGIN
       select start_date, end_date
       into   v_start_date, v_end_date
       from   time_intervals
       where  interval_id = overlaps_interval_p__interval_id;
        
       return timespan__overlaps_p(
                        overlaps_interval_p__timespan_id, 
                        v_start_date, 
                        v_end_date
                        );

END;
$$;


ALTER FUNCTION public.timespan__overlaps_interval_p(overlaps_interval_p__timespan_id integer, overlaps_interval_p__interval_id integer) OWNER TO evex;

--
-- Name: timespan__overlaps_p(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__overlaps_p(overlaps_p__timespan_1_id integer, overlaps_p__timespan_2_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_result             boolean;
       rec_timespan                 record;
BEGIN
       -- Loop over 2nd timespan, checking each interval against 1st
       for rec_timespan in 
            select * 
            from timespans
            where timespan_id = overlaps_p__timespan_2_id
       loop
            v_result := timespan__overlaps_interval_p(
                                overlaps_p__timespan_1_id,
                                rec_timespan.interval_id
                                );
            if v_result then
                return true;
            end if;
       end loop;

       return false;

END;
$$;


ALTER FUNCTION public.timespan__overlaps_p(overlaps_p__timespan_1_id integer, overlaps_p__timespan_2_id integer) OWNER TO evex;

--
-- Name: timespan__overlaps_p(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan__overlaps_p(overlaps_p__timespan_id integer, overlaps_p__start_date timestamp with time zone, overlaps_p__end_date timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
       v_result                    boolean;
       rec_timespan                record;
BEGIN
       -- Loop over each interval in timespan, checking against dates.
       for rec_timespan in
            select * 
            from timespans
            where timespan_id = overlaps_p__timespan_id
       loop
            v_result := time_interval__overlaps_p(
                                rec_timespan.interval_id, 
                                overlaps_p__start_date,
                                overlaps_p__end_date
                                );

            if v_result then
                return true;
            end if;
       end loop;

       return false;

END;
$$;


ALTER FUNCTION public.timespan__overlaps_p(overlaps_p__timespan_id integer, overlaps_p__start_date timestamp with time zone, overlaps_p__end_date timestamp with time zone) OWNER TO evex;

--
-- Name: timespan_days(double precision); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timespan_days(double precision) RETURNS interval
    LANGUAGE plpgsql
    AS $_$
DECLARE
        n_days alias for $1;
BEGIN
        return (n_days::text || ' days')::interval;
END;
$_$;


ALTER FUNCTION public.timespan_days(double precision) OWNER TO evex;

--
-- Name: timezone__add_rule(character varying, character varying, integer, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__add_rule(p_tz character varying, p_abbrev character varying, p_isdst_p integer, p_gmt_offset character varying, p_utc_start character varying, p_utc_end character varying, p_local_start character varying, p_local_end character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  insert into timezone_rules
    (tz_id, abbrev, utc_start, utc_end, local_start, local_end, gmt_offset, isdst_p)
  select timezone__get_id(p_tz), p_abbrev, rdbms_date(p_utc_start),
    rdbms_date(p_utc_end), rdbms_date(p_local_start),
    to_date(p_local_end),
    p_gmt_offset,
    case p_isdst_p when 0 then 'f' else 't'end;
END;
$$;


ALTER FUNCTION public.timezone__add_rule(p_tz character varying, p_abbrev character varying, p_isdst_p integer, p_gmt_offset character varying, p_utc_start character varying, p_utc_end character varying, p_local_start character varying, p_local_end character varying) OWNER TO evex;

--
-- Name: timezone__convert_to_local(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__convert_to_local(p_tz_id integer, p_utc_varchar character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_base_time timestamptz;
BEGIN

  select "timestamptz" (p_utc_varchar || substr(gmt_offset,1,5)) into v_base_time
  from timezones
  where tz_id = p_tz_id;

  if not found then
    return "timestamptz" (p_utc_varchar || '+00');
  end if;

  return "timestamptz" (p_utc_varchar) + "interval" (gmt_offset || 'seconds')
  from   timezone_rules
  where  tz_id = p_tz_id and v_base_time between utc_start and utc_end;

END;
$$;


ALTER FUNCTION public.timezone__convert_to_local(p_tz_id integer, p_utc_varchar character varying) OWNER TO evex;

--
-- Name: timezone__convert_to_utc(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__convert_to_utc(p_tz_id integer, p_local_varchar character varying) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_base_time timestamptz;
BEGIN

  select "timestamptz" (p_local_varchar || substr(gmt_offset,1,5)) into v_base_time
  from timezones
  where tz_id = p_tz_id;

  if not found then
    return "timestamptz" (p_local_varchar || '+00');
  end if;

  return "timestamptz" (p_local_varchar) - "interval" (gmt_offset || 'seconds')
  from   timezone_rules
  where  tz_id = p_tz_id and v_base_time between utc_start and utc_end;

END;
$$;


ALTER FUNCTION public.timezone__convert_to_utc(p_tz_id integer, p_local_varchar character varying) OWNER TO evex;

--
-- Name: timezone__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__delete(p_tz_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  delete from timezone_rules where tz_id = p_tz_id;
  delete from timezones      where tz_id = p_tz_id;
  return 0;
END;
$$;


ALTER FUNCTION public.timezone__delete(p_tz_id integer) OWNER TO evex;

--
-- Name: timezone__get_abbrev(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__get_abbrev(p_tz_id integer, p_time timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_abbrev timezone_rules.abbrev%TYPE;
BEGIN
  v_abbrev := 'GMT';

  select abbrev into v_abbrev
  from   timezone_rules
  where  tz_id = p_tz_id and p_time between local_start and local_end;
	 
  return v_abbrev;
END;
$$;


ALTER FUNCTION public.timezone__get_abbrev(p_tz_id integer, p_time timestamp with time zone) OWNER TO evex;

--
-- Name: timezone__get_date(integer, timestamp with time zone, character varying, boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__get_date(p_tz_id integer, p_timestamp timestamp with time zone, p_format character varying, p_append_timezone_p boolean) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_timestamp timestamptz;
  v_abbrev text;
  v_date text;
BEGIN

  v_abbrev := '';
  if p_append_timezone_p then
    select abbrev into v_abbrev
    from   timezone_rules
    where  tz_id = p_tz_id and p_timestamp between utc_start and utc_end;
  end if;

  select to_char(p_timestamp + "interval" (
     (extract(timezone_hour from p_timestamp) * 3600 + extract(timezone_minute from p_timestamp) * 60) || 'seconds') +
         "interval" (gmt_offset || 'seconds'), p_format) || ' ' || v_abbrev
    into v_date 
  from   timezone_rules
  where  tz_id = p_tz_id and p_timestamp between utc_start and utc_end;

  if not found then
    select to_char(p_timestamp + "interval" ((extract(timezone_hour from p_timestamp) * 3600 + extract(timezone_minute from p_timestamp) * 60) || 'seconds'), p_format)
      into v_date;
  end if;

  return v_date;

END;
$$;


ALTER FUNCTION public.timezone__get_date(p_tz_id integer, p_timestamp timestamp with time zone, p_format character varying, p_append_timezone_p boolean) OWNER TO evex;

--
-- Name: timezone__get_id(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__get_id(p_tz character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  v_tz_id integer;
BEGIN

  return tz_id
  from   timezones
  where  tz = p_tz;

END;
$$;


ALTER FUNCTION public.timezone__get_id(p_tz character varying) OWNER TO evex;

--
-- Name: timezone__get_offset(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__get_offset(p_tz_id integer, p_time timestamp with time zone) RETURNS interval
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_offset integer;
BEGIN
  v_offset := '0';

  select gmt_offset into v_offset
  from timezone_rules
  where  tz_id = p_tz_id and p_time between utc_start and utc_end;

  return "interval" (v_offset || 'seconds');
END;
$$;


ALTER FUNCTION public.timezone__get_offset(p_tz_id integer, p_time timestamp with time zone) OWNER TO evex;

--
-- Name: timezone__get_rawoffset(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__get_rawoffset(p_tz_id integer, p_time timestamp with time zone) RETURNS interval
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_offset varchar;
BEGIN
  v_offset := '0';

  select
    case isdst_p
    when 't' then "interval" (gmt_offset || 'seconds') - '3600 seconds'
    else "interval" (gmt_offset || 'seconds')
    end
  into v_offset
  from   timezone_rules
  where  tz_id  = p_tz_id and p_time between utc_start and utc_end;

  return v_offset;
END;
$$;


ALTER FUNCTION public.timezone__get_rawoffset(p_tz_id integer, p_time timestamp with time zone) OWNER TO evex;

--
-- Name: timezone__isdst_p(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__isdst_p(p_tz_id integer, p_time timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_isdst_p boolean;
BEGIN
  v_isdst_p := 'f';

  select isdst_p into v_isdst_p
  from   timezone_rules
  where  tz_id = p_tz_id and p_time between local_start and local_end;

  return v_isdst_p;
END;
$$;


ALTER FUNCTION public.timezone__isdst_p(p_tz_id integer, p_time timestamp with time zone) OWNER TO evex;

--
-- Name: timezone__new(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.timezone__new(p_tz character varying, p_gmt_offset character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  insert into timezones
    (tz_id, tz, gmt_offset)
  values
    (nextval('timezone_seq'), p_tz, gmt_offset);
  return 0;
END;
$$;


ALTER FUNCTION public.timezone__new(p_tz character varying, p_gmt_offset character varying) OWNER TO evex;

--
-- Name: to_interval(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.to_interval(interval__number integer, interval__units character varying) RETURNS interval
    LANGUAGE plpgsql
    AS $$
	
DECLARE    
BEGIN
	-- We should probably do unit checking at some point
	return ('''' || interval__number || ' ' || interval__units || '''')::interval;

END;
$$;


ALTER FUNCTION public.to_interval(interval__number integer, interval__units character varying) OWNER TO evex;

--
-- Name: tree_ancestor_key(bit varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_ancestor_key(p_tree_key bit varying, p_level integer) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
-- Returns a key for the ancestor at the given level.  The root is level
-- one.
DECLARE
  v_level         integer default 0;
  v_pos           integer default 1;
BEGIN

  if tree_level(p_tree_key) < p_level then
    raise exception 'tree_ancestor_key: key is at a level less than %', p_level;
  end if;

  while v_level < p_level loop
    v_level := v_level + 1;
    if substring(p_tree_key, v_pos, 1) = '1' then
      v_pos := v_pos + 32;
    else
      v_pos := v_pos + 8;
    end if;
  end loop;

  return substring(p_tree_key, 1, v_pos - 1);

END;
$$;


ALTER FUNCTION public.tree_ancestor_key(p_tree_key bit varying, p_level integer) OWNER TO evex;

--
-- Name: tree_ancestor_keys(bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_ancestor_keys(bit varying) RETURNS SETOF bit varying
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$

  select tree_ancestor_keys($1, 1)

$_$;


ALTER FUNCTION public.tree_ancestor_keys(bit varying) OWNER TO evex;

--
-- Name: tree_ancestor_keys(bit varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_ancestor_keys(bit varying, integer) RETURNS SETOF bit varying
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
  select tree_ancestor_key($1, $2)
  union
  select tree_ancestor_keys($1, $2 + 1)
  where $2 < tree_level($1)
$_$;


ALTER FUNCTION public.tree_ancestor_keys(bit varying, integer) OWNER TO evex;

--
-- Name: tree_ancestor_p(bit varying, bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_ancestor_p(p_potential_ancestor bit varying, p_potential_child bit varying) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
BEGIN
  return position(p_potential_ancestor in p_potential_child) = 1;
END;
$$;


ALTER FUNCTION public.tree_ancestor_p(p_potential_ancestor bit varying, p_potential_child bit varying) OWNER TO evex;

--
-- Name: tree_increment_key(bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_increment_key(p_child_sort_key bit varying) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    v_child_sort_key                integer;
BEGIN
    if p_child_sort_key is null then
        v_child_sort_key := 0;
    else
        v_child_sort_key := tree_leaf_key_to_int(p_child_sort_key) + 1;
    end if;

    return int_to_tree_key(v_child_sort_key);
END;
$$;


ALTER FUNCTION public.tree_increment_key(p_child_sort_key bit varying) OWNER TO evex;

--
-- Name: tree_key_to_int(bit varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_key_to_int(p_tree_key bit varying, p_level integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
-- Convert the compressed key for the node at the given level to an 
-- integer.
DECLARE
  v_level         integer default 0;
  v_parent_pos    integer default 1;
  v_pos           integer default 1;
BEGIN

  -- Find the right key first
  while v_pos < length(p_tree_key) and v_level < p_level loop
    v_parent_pos := v_pos;
    v_level := v_level + 1;
    if substring(p_tree_key, v_pos, 1) = '1' then
      v_pos := v_pos + 32;
    else
      v_pos := v_pos + 8;
    end if;
  end loop;

  if v_level < p_level then
    raise exception 'tree_key_to_int: key is at a level less than %', p_level;
  end if;

  if substring(p_tree_key, v_parent_pos, 1) = '1' then
    return bittoint4(substring(p_tree_key, v_parent_pos + 1, 31));
  else
    return bittoint4(substring(p_tree_key, v_parent_pos, 8));
  end if;

END;
$$;


ALTER FUNCTION public.tree_key_to_int(p_tree_key bit varying, p_level integer) OWNER TO evex;

--
-- Name: tree_leaf_key_to_int(bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_leaf_key_to_int(p_tree_key bit varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
-- Convert the bitstring for the last, or leaf, node represented by this key
-- to an integer.
DECLARE
  v_leaf_pos      integer default 1;
  v_pos           integer default 1;
BEGIN

  -- Find the leaf key first
  while v_pos < length(p_tree_key) loop
    v_leaf_pos := v_pos;
    if substring(p_tree_key, v_pos, 1) = '1' then
      v_pos := v_pos + 32;
    else
      v_pos := v_pos + 8;
    end if;
  end loop;

  if substring(p_tree_key, v_leaf_pos, 1) = '1' then
    return bittoint4(substring(p_tree_key, v_leaf_pos + 1, 31));
  else
    return bittoint4(substring(p_tree_key, v_leaf_pos, 8));
  end if;

END;
$$;


ALTER FUNCTION public.tree_leaf_key_to_int(p_tree_key bit varying) OWNER TO evex;

--
-- Name: tree_left(bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_left(key bit varying) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Create a key less than or equal to that of any child of the
-- current key.
DECLARE
BEGIN
  if key is null then
    return 'X00'::varbit;
  else
    return key || 'X00'::varbit;
  end if;
END;
$$;


ALTER FUNCTION public.tree_left(key bit varying) OWNER TO evex;

--
-- Name: tree_level(bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_level(p_tree_key bit varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Return the tree level of the given key.  The root level is defined
-- to be at level one.
DECLARE
  v_pos                integer;        
  v_level              integer;
  
BEGIN

  if p_tree_key is null then
    return 0;
  end if;

  v_pos := 1;
  v_level := 0;

  while v_pos <= length(p_tree_key) loop
    v_level := v_level + 1;
    if substring(p_tree_key, v_pos, 1) = '1' then
      v_pos := v_pos + 32;
    else
      v_pos := v_pos + 8;
    end if;
  end loop;

  return v_level;
END;
$$;


ALTER FUNCTION public.tree_level(p_tree_key bit varying) OWNER TO evex;

--
-- Name: tree_next_key(bit varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_next_key(p_parent_key bit varying, p_child_value integer) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  v_child_value     integer;
BEGIN
-- Create a new child of the given key with a leaf key number one greater than
-- the child value parameter.  If the child value parameter is null, make the
-- child the first child of the parent.

  if p_child_value is null then
    v_child_value := 0;
  else
    v_child_value := p_child_value + 1;
  end if;

  if p_parent_key is null then
    return int_to_tree_key(v_child_value);
  else
    return p_parent_key || int_to_tree_key(v_child_value);
  end if;

END;
$$;


ALTER FUNCTION public.tree_next_key(p_parent_key bit varying, p_child_value integer) OWNER TO evex;

--
-- Name: tree_right(bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_right(key bit varying) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Create a key greater or equal to that of any child of the current key.
-- Used in BETWEEN expressions to select the subtree rooted at the given
-- key.
DECLARE
BEGIN
  if key is null then
    return 'XFFFFFFFF'::varbit;
  else
    return key || 'XFFFFFFFF'::varbit;
  end if;
END;
$$;


ALTER FUNCTION public.tree_right(key bit varying) OWNER TO evex;

--
-- Name: tree_root_key(bit varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.tree_root_key(p_tree_key bit varying) RETURNS bit varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
-- Return the tree_sortkey for the root node of the node with the 
-- given tree_sortkey.
DECLARE
BEGIN

  if substring(p_tree_key, 1, 1) = '1' then
      return substring(p_tree_key, 1, 32);
  else
      return substring(p_tree_key, 1, 8);
  end if;

END;
$$;


ALTER FUNCTION public.tree_root_key(p_tree_key bit varying) OWNER TO evex;

--
-- Name: trig_ec_cert_amount_remains(); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.trig_ec_cert_amount_remains() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        bal_amount_used         numeric;
        original_amount         numeric;
BEGIN
        select amount into original_amount
        from ec_gift_certificates where gift_certificate_id= NEW.certificate_id for update;

        select coalesce(sum(amount_used), 0) - coalesce(sum(amount_reinstated), 0)
        into bal_amount_used
        from ec_gift_certificate_usage
        where gift_certificate_id= NEW.gift_certificate_id;

        UPDATE ec_gift_certificates
        SET amount_remaining_p = case when amount > bal_amount_used then 't' else 'f' end
        WHERE gift_certificate_id = gift_certificate_rec.gift_certificate_id;
	return new;
END;
$$;


ALTER FUNCTION public.trig_ec_cert_amount_remains() OWNER TO evex;

--
-- Name: trigger_exists(character varying, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.trigger_exists(trigger_name character varying, on_table character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE 
BEGIN
        return count(*) > 0
          from pg_class c, pg_trigger t
         where c.relname = lower(on_table)
           and c.oid = t.tgrelid
           and t.tgname = lower(trigger_name);

END;
$$;


ALTER FUNCTION public.trigger_exists(trigger_name character varying, on_table character varying) OWNER TO evex;

--
-- Name: trigger_func_exists(character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.trigger_func_exists(trigger_name character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE 
BEGIN
        return count(*) = 1
          from pg_proc
         where proname = lower(trigger_name)
           and pronargs = 0;

END;
$$;


ALTER FUNCTION public.trigger_func_exists(trigger_name character varying) OWNER TO evex;

--
-- Name: trigger_type(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.trigger_type(tgtype integer) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  description       varchar;
  sep               varchar;
BEGIN

 if (tgtype & 2) > 0 then
    description := 'BEFORE ';
 else 
    description := 'AFTER ';
 end if;

 sep := '';

 if (tgtype & 4) > 0 then
    description := description || 'INSERT ';
    sep := 'OR ';
 end if;

 if (tgtype & 8) > 0 then
    description := description || sep || 'DELETE ';
    sep := 'OR ';
 end if;

 if (tgtype & 16) > 0 then
    description := description || sep || 'UPDATE ';
    sep := 'OR ';
 end if;

 if (tgtype & 1) > 0 then
    description := description || 'FOR EACH ROW';
 else
    description := description || 'STATEMENT';
 end if;

 return description;

END;
$$;


ALTER FUNCTION public.trigger_type(tgtype integer) OWNER TO evex;

--
-- Name: trunc(date, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.trunc(date, character varying) RETURNS date
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	p_date_in	alias for $1;	-- date_in
	p_field		alias for $2;	-- field

	v_date_out	date;
BEGIN
	select date_trunc("p_field",p_date_in) into v_date_out;
	return v_date_out;
END;$_$;


ALTER FUNCTION public.trunc(date, character varying) OWNER TO evex;

--
-- Name: user_group_member_add(integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.user_group_member_add(integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	p_group_id	alias for $1;
	p_user_id	alias for $2;
	p_role		alias for $3;

	v_rel_id		integer;
BEGIN
	v_rel_id := membership_rel__new(
		p_group_id,			-- object_id_one
		p_user_id,			-- object_id_two
		0,				-- creation_user
		null				-- creation_ip
	);
	return v_rel_id;
END;$_$;


ALTER FUNCTION public.user_group_member_add(integer, integer, character varying) OWNER TO evex;

--
-- Name: user_group_member_del(integer, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.user_group_member_del(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	row		RECORD;
	p_group_id	alias for $1;
	p_user_id	alias for $2;

	v_rel_id	integer;
BEGIN
	for row in 
		select	rel_id
		from	acs_rels
		where	object_id_one = p_group_id
			and object_id_two = p_user_id
	loop
		PERFORM membership_rel__delete(row.rel_id);
	end loop;

	return 0;
end;$_$;


ALTER FUNCTION public.user_group_member_del(integer, integer) OWNER TO evex;

--
-- Name: userinfo__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.userinfo__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    p_user_id ALIAS FOR $1;

BEGIN

  DELETE FROM user_ext_info WHERE user_id = p_user_id;

  RETURN 0;

END; $_$;


ALTER FUNCTION public.userinfo__delete(integer) OWNER TO evex;

--
-- Name: userinfo__new(integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.userinfo__new(p_userinfo_id integer, p_fbid character varying, p_user_id integer, p_phonenumber character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN

  INSERT INTO user_ext_info (
    userinfo_id,
    fbid,
    user_id,
    phonenumber
  ) VALUES (
    p_userinfo_id,
    p_fbid,
    p_user_id,
    p_phonenumber
  );

  RETURN 0;
END; $$;


ALTER FUNCTION public.userinfo__new(p_userinfo_id integer, p_fbid character varying, p_user_id integer, p_phonenumber character varying) OWNER TO evex;

--
-- Name: userinfo__update(integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.userinfo__update(p_userinfo_id integer, p_fbid character varying, p_user_id integer, p_phonenumber character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE

  BEGIN

    UPDATE user_ext_info SET 
      userinfo_id = p_userinfo_id,
      fbid = p_fbid,
      user_id = p_user_id,
      phonenumber = p_phonenumber
    WHERE userinfo_id = p_userinfo_id;
  
  RETURN 0;
END; $$;


ALTER FUNCTION public.userinfo__update(p_userinfo_id integer, p_fbid character varying, p_user_id integer, p_phonenumber character varying) OWNER TO evex;

--
-- Name: userinfo__update_purchased_plan(integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.userinfo__update_purchased_plan(p_user_id integer, purchased_plan character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN

  UPDATE user_ext_info SET purchased_plan = p_purchased_plan WHERE user_id = p_user_id;


  RETURN 0;
END; $$;


ALTER FUNCTION public.userinfo__update_purchased_plan(p_user_id integer, purchased_plan character varying) OWNER TO evex;

--
-- Name: users_email_image; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.users_email_image (
    email_image_id integer NOT NULL
);


ALTER TABLE public.users_email_image OWNER TO evex;

--
-- Name: users_email_imagei; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.users_email_imagei AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    users_email_image.email_image_id
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.users_email_image
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = users_email_image.email_image_id));


ALTER TABLE public.users_email_imagei OWNER TO evex;

--
-- Name: users_email_image_f(public.users_email_imagei); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.users_email_image_f(p_new public.users_email_imagei) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into users_email_image ( email_image_id ) values (v_revision_id);
    
   return;
   end;$$;


ALTER FUNCTION public.users_email_image_f(p_new public.users_email_imagei) OWNER TO evex;

--
-- Name: util__index_exists(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.util__index_exists(name text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      return exists (
       select 1 from pg_indexes where indexname = name);
END;
$$;


ALTER FUNCTION public.util__index_exists(name text) OWNER TO evex;

--
-- Name: util__logical_negation(boolean); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.util__logical_negation(true_or_false boolean) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
      IF true_or_false is null THEN
        return null;
      ELSE IF true_or_false = 'f' THEN
        return 't';   
      ELSE 
        return 'f';   
      END IF; END IF;
END;
$$;


ALTER FUNCTION public.util__logical_negation(true_or_false boolean) OWNER TO evex;

--
-- Name: util__multiple_nextval(character varying, integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.util__multiple_nextval(v_sequence_name character varying, v_count integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  a_sequence_values      text default ''; 
  v_rec                  record;
BEGIN
    for counter in 1..v_count loop
        for v_rec in EXECUTE 'select ' || quote_ident(v_sequence_name) || '.nextval as a_seq_val'
        LOOP
           a_sequence_values := a_sequence_values || '','' || v_rec.a_seq_val;
          exit;
        end loop;
    end loop;

    return substr(a_sequence_values, 2);
 
END;
$$;


ALTER FUNCTION public.util__multiple_nextval(v_sequence_name character varying, v_count integer) OWNER TO evex;

--
-- Name: util__table_column_exists(text, text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.util__table_column_exists(t_name text, c_name text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      return exists (
       select 1 from information_schema.columns c
         where c.table_name  = t_name 
           and c.column_name = c_name);
END;
$$;


ALTER FUNCTION public.util__table_column_exists(t_name text, c_name text) OWNER TO evex;

--
-- Name: util__table_exists(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.util__table_exists(name text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      return exists (
       select 1 from pg_class 
          where relname = name 
            and pg_table_is_visible(oid));
END;
$$;


ALTER FUNCTION public.util__table_exists(name text) OWNER TO evex;

--
-- Name: util__view_exists(text); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.util__view_exists(name text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
      return exists (
       select 1 from pg_views where viewname = name);
END;
$$;


ALTER FUNCTION public.util__view_exists(name text) OWNER TO evex;

--
-- Name: weblogger_blogroll_entry__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.weblogger_blogroll_entry__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_link_id alias for $1;
begin
    delete from weblogger_blogroll_entries
        where link_id = p_link_id;

    PERFORM acs_object__delete(p_link_id);
    return 0;
end;
$_$;


ALTER FUNCTION public.weblogger_blogroll_entry__delete(integer) OWNER TO evex;

--
-- Name: weblogger_blogroll_entry__name(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.weblogger_blogroll_entry__name(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
    p_link_id           alias for $1;
    v_name              varchar;
begin
    select name into v_name
        from weblogger_blogroll_entries
        where link_id = p_link_id;
    return v_name;
end;
$_$;


ALTER FUNCTION public.weblogger_blogroll_entry__name(integer) OWNER TO evex;

--
-- Name: weblogger_blogroll_entry__new(integer, integer, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.weblogger_blogroll_entry__new(integer, integer, character varying, character varying, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_link_id               alias for $1;
    p_package_id           alias for $2;
    p_name                 alias for $3;
    p_url           alias for $4;
    p_creation_user        alias for $5;
    p_creation_ip          alias for $6;
    v_link_id          integer;
begin
    v_link_id := acs_object__new (
        p_link_id,
        'weblogger_blogroll_entry',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id
    );

    insert into weblogger_blogroll_entries (
      link_id, 
      package_id,
      name,
      url
    ) values (
      v_link_id, 
      p_package_id,
      p_name,
      p_url
    );

    return v_link_id;   
end;
$_$;


ALTER FUNCTION public.weblogger_blogroll_entry__new(integer, integer, character varying, character varying, integer, character varying) OWNER TO evex;

--
-- Name: weblogger_channel__delete(integer); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.weblogger_channel__delete(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_channel_id alias for $1;
    subscr_rec         record;
begin
    -- delete rss_gen_subscrs which relate to this channel
    for subscr_rec in select subscr_id 
                         from rss_gen_subscrs
                         where summary_context_id = p_channel_id loop
        perform rss_gen_subscr__delete(subscr_rec.subscr_id);
    end loop;

    delete from weblogger_channels
        where channel_id = p_channel_id;
    PERFORM acs_object__delete(p_channel_id);
    return 0;
end;
$_$;


ALTER FUNCTION public.weblogger_channel__delete(integer) OWNER TO evex;

--
-- Name: weblogger_channel__new(integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.weblogger_channel__new(integer, integer, integer, integer, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
    p_channel_id           alias for $1;
    p_package_id           alias for $2;
    p_user_id		   alias for $3;
    p_creation_user        alias for $4;
    p_creation_ip          alias for $5;
    v_channel_id           integer;
begin
    v_channel_id := acs_object__new (
        p_channel_id,
        'weblogger_channel',
        current_timestamp,
        p_creation_user,
        p_creation_ip,
        p_package_id
    );

    insert into weblogger_channels (
      channel_id, 
      package_id,
      user_id      
    ) values (
      v_channel_id, 
      p_package_id,
      p_user_id
    );

    return v_channel_id;   
end;
$_$;


ALTER FUNCTION public.weblogger_channel__new(integer, integer, integer, integer, character varying) OWNER TO evex;

--
-- Name: xowiki_file; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_file (
    file_id integer NOT NULL
);


ALTER TABLE public.xowiki_file OWNER TO evex;

--
-- Name: xowiki_page; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_page (
    page_id integer NOT NULL,
    page_order text DEFAULT ''::text,
    creator text
);


ALTER TABLE public.xowiki_page OWNER TO evex;

--
-- Name: xowiki_filei; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_filei AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_file.file_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_file,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_file.file_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_filei OWNER TO evex;

--
-- Name: xowiki_file_f(public.xowiki_filei); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_file_f(p_new public.xowiki_filei) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    insert into xowiki_file ( file_id ) values (v_revision_id);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_file_f(p_new public.xowiki_filei) OWNER TO evex;

--
-- Name: xowiki_form; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_form (
    xowiki_form_id integer NOT NULL,
    form text DEFAULT ''::text,
    form_constraints text DEFAULT ''::text
);


ALTER TABLE public.xowiki_form OWNER TO evex;

--
-- Name: xowiki_page_template; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_page_template (
    page_template_id integer NOT NULL,
    anon_instances boolean DEFAULT false
);


ALTER TABLE public.xowiki_page_template OWNER TO evex;

--
-- Name: xowiki_formi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_formi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_form.xowiki_form_id,
    xowiki_form.form,
    xowiki_form.form_constraints,
    xowiki_page_template.page_template_id,
    xowiki_page_template.anon_instances,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_form,
    public.xowiki_page_template,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_form.xowiki_form_id) AND (acs_objects.object_id = xowiki_page_template.page_template_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_formi OWNER TO evex;

--
-- Name: xowiki_form_f(public.xowiki_formi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_form_f(p_new public.xowiki_formi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    insert into xowiki_page_template ( page_template_id, anon_instances ) values (v_revision_id, p_new.anon_instances);
    insert into xowiki_form ( xowiki_form_id, form, form_constraints ) values (v_revision_id, p_new.form, p_new.form_constraints);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_form_f(p_new public.xowiki_formi) OWNER TO evex;

--
-- Name: xowiki_form_page; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_form_page (
    xowiki_form_page_id integer NOT NULL,
    assignee integer,
    state text DEFAULT ''::text
);


ALTER TABLE public.xowiki_form_page OWNER TO evex;

--
-- Name: xowiki_page_instance; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_page_instance (
    page_instance_id integer NOT NULL,
    page_template integer,
    instance_attributes text DEFAULT ''::text
);


ALTER TABLE public.xowiki_page_instance OWNER TO evex;

--
-- Name: xowiki_form_pagei; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_form_pagei AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_form_page.xowiki_form_page_id,
    xowiki_form_page.assignee,
    xowiki_form_page.state,
    xowiki_page_instance.page_instance_id,
    xowiki_page_instance.page_template,
    xowiki_page_instance.instance_attributes,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_form_page,
    public.xowiki_page_instance,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_form_page.xowiki_form_page_id) AND (acs_objects.object_id = xowiki_page_instance.page_instance_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_form_pagei OWNER TO evex;

--
-- Name: xowiki_form_page_f(public.xowiki_form_pagei); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_form_page_f(p_new public.xowiki_form_pagei) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    insert into xowiki_page_instance ( page_instance_id, page_template, instance_attributes ) values (v_revision_id, p_new.page_template, p_new.instance_attributes);
    insert into xowiki_form_page ( xowiki_form_page_id, assignee, state ) values (v_revision_id, p_new.assignee, p_new.state);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_form_page_f(p_new public.xowiki_form_pagei) OWNER TO evex;

--
-- Name: xowiki_object; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_object (
    xowiki_object_id integer NOT NULL
);


ALTER TABLE public.xowiki_object OWNER TO evex;

--
-- Name: xowiki_plain_page; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_plain_page (
    ppage_id integer NOT NULL
);


ALTER TABLE public.xowiki_plain_page OWNER TO evex;

--
-- Name: xowiki_objecti; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_objecti AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_object.xowiki_object_id,
    xowiki_plain_page.ppage_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_object,
    public.xowiki_plain_page,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_object.xowiki_object_id) AND (acs_objects.object_id = xowiki_plain_page.ppage_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_objecti OWNER TO evex;

--
-- Name: xowiki_object_f(public.xowiki_objecti); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_object_f(p_new public.xowiki_objecti) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    insert into xowiki_plain_page ( ppage_id ) values (v_revision_id);
    insert into xowiki_object ( xowiki_object_id ) values (v_revision_id);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_object_f(p_new public.xowiki_objecti) OWNER TO evex;

--
-- Name: xowiki_pagei; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_pagei AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_pagei OWNER TO evex;

--
-- Name: xowiki_page_f(public.xowiki_pagei); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_page_f(p_new public.xowiki_pagei) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_page_f(p_new public.xowiki_pagei) OWNER TO evex;

--
-- Name: xowiki_page_instancei; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_page_instancei AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_page_instance.page_instance_id,
    xowiki_page_instance.page_template,
    xowiki_page_instance.instance_attributes,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_page_instance,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_page_instance.page_instance_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_page_instancei OWNER TO evex;

--
-- Name: xowiki_page_instance_f(public.xowiki_page_instancei); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_page_instance_f(p_new public.xowiki_page_instancei) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    insert into xowiki_page_instance ( page_instance_id, page_template, instance_attributes ) values (v_revision_id, p_new.page_template, p_new.instance_attributes);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_page_instance_f(p_new public.xowiki_page_instancei) OWNER TO evex;

--
-- Name: xowiki_page_templatei; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_page_templatei AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_page_template.page_template_id,
    xowiki_page_template.anon_instances,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_page_template,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_page_template.page_template_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_page_templatei OWNER TO evex;

--
-- Name: xowiki_page_template_f(public.xowiki_page_templatei); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_page_template_f(p_new public.xowiki_page_templatei) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    insert into xowiki_page_template ( page_template_id, anon_instances ) values (v_revision_id, p_new.anon_instances);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_page_template_f(p_new public.xowiki_page_templatei) OWNER TO evex;

--
-- Name: xowiki_plain_pagei; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_plain_pagei AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_plain_page.ppage_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_plain_page,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_plain_page.ppage_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_plain_pagei OWNER TO evex;

--
-- Name: xowiki_plain_page_f(public.xowiki_plain_pagei); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_plain_page_f(p_new public.xowiki_plain_pagei) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    insert into xowiki_plain_page ( ppage_id ) values (v_revision_id);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_plain_page_f(p_new public.xowiki_plain_pagei) OWNER TO evex;

--
-- Name: xowiki_podcast_item; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_podcast_item (
    podcast_item_id integer NOT NULL,
    pub_date timestamp without time zone,
    duration text,
    subtitle text,
    keywords text
);


ALTER TABLE public.xowiki_podcast_item OWNER TO evex;

--
-- Name: xowiki_podcast_itemi; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_podcast_itemi AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_podcast_item.podcast_item_id,
    xowiki_podcast_item.pub_date,
    xowiki_podcast_item.duration,
    xowiki_podcast_item.subtitle,
    xowiki_podcast_item.keywords,
    xowiki_file.file_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_text,
    public.xowiki_podcast_item,
    public.xowiki_file,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (acs_objects.object_id = xowiki_podcast_item.podcast_item_id) AND (acs_objects.object_id = xowiki_file.file_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_podcast_itemi OWNER TO evex;

--
-- Name: xowiki_podcast_item_f(public.xowiki_podcast_itemi); Type: FUNCTION; Schema: public; Owner: evex
--

CREATE FUNCTION public.xowiki_podcast_item_f(p_new public.xowiki_podcast_itemi) RETURNS void
    LANGUAGE plpgsql
    AS $$
             declare
               v_revision_id integer;
             begin

               select content_revision__new(
                                     p_new.title,
                                     p_new.description,
                                     p_new.publish_date,
                                     p_new.mime_type,
                                     p_new.nls_language,
                                     case when p_new.text is null 
                                              then p_new.data 
                                              else p_new.text
                                           end,
                                     content_symlink__resolve(p_new.item_id),
                                     p_new.revision_id,
                                     now(),
                                     p_new.creation_user, 
                                     p_new.creation_ip,
                                     null,                   -- content_length
                                     p_new.object_package_id
                ) into v_revision_id;
                insert into xowiki_page ( page_id, page_order, creator ) values (v_revision_id, p_new.page_order, p_new.creator);
    insert into xowiki_file ( file_id ) values (v_revision_id);
    insert into xowiki_podcast_item ( podcast_item_id, pub_date, duration, subtitle, keywords ) values (v_revision_id, p_new.pub_date, p_new.duration, p_new.subtitle, p_new.keywords);
    
   return;
   end;$$;


ALTER FUNCTION public.xowiki_podcast_item_f(p_new public.xowiki_podcast_itemi) OWNER TO evex;

--
-- Name: aa_test_final_results; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.aa_test_final_results (
    testcase_id character varying(512),
    package_key character varying(100),
    "timestamp" timestamp with time zone,
    passes integer,
    fails integer
);


ALTER TABLE public.aa_test_final_results OWNER TO evex;

--
-- Name: aa_test_results; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.aa_test_results (
    testcase_id character varying(512),
    package_key character varying(100),
    test_id integer,
    "timestamp" timestamp with time zone,
    result character varying(4),
    notes character varying(2000)
);


ALTER TABLE public.aa_test_results OWNER TO evex;

--
-- Name: acs_activities; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_activities (
    activity_id integer NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    html_p boolean DEFAULT false,
    status_summary character varying(255)
);


ALTER TABLE public.acs_activities OWNER TO evex;

--
-- Name: TABLE acs_activities; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_activities IS '
    Represents what happens during an event
';


--
-- Name: acs_activity_object_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_activity_object_map (
    activity_id integer NOT NULL,
    object_id integer NOT NULL
);


ALTER TABLE public.acs_activity_object_map OWNER TO evex;

--
-- Name: TABLE acs_activity_object_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_activity_object_map IS '
    Maps between an activity and multiple ACS objects.
';


--
-- Name: acs_attribute_descriptions; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_attribute_descriptions (
    object_type character varying(1000) NOT NULL,
    attribute_name character varying(100) NOT NULL,
    description_key character varying(100) NOT NULL,
    description text NOT NULL
);


ALTER TABLE public.acs_attribute_descriptions OWNER TO evex;

--
-- Name: t_acs_attribute_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.t_acs_attribute_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.t_acs_attribute_id_seq OWNER TO evex;

--
-- Name: acs_attribute_id_seq; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_attribute_id_seq AS
 SELECT nextval('public.t_acs_attribute_id_seq'::regclass) AS nextval;


ALTER TABLE public.acs_attribute_id_seq OWNER TO evex;

--
-- Name: t_acs_attribute_value_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.t_acs_attribute_value_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.t_acs_attribute_value_id_seq OWNER TO evex;

--
-- Name: acs_attribute_value_id_seq; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_attribute_value_id_seq AS
 SELECT nextval('public.t_acs_attribute_value_id_seq'::regclass) AS nextval;


ALTER TABLE public.acs_attribute_value_id_seq OWNER TO evex;

--
-- Name: acs_attribute_values; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_attribute_values (
    object_id integer NOT NULL,
    attribute_id integer NOT NULL,
    attr_value text
);


ALTER TABLE public.acs_attribute_values OWNER TO evex;

--
-- Name: TABLE acs_attribute_values; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_attribute_values IS '
  Instead of coercing everything into a big string, we could use
  a "union", i.e, a string column, a number column, a date column,
  and a discriminator.
';


--
-- Name: acs_attributes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_attributes (
    attribute_id integer NOT NULL,
    object_type character varying(1000) NOT NULL,
    table_name character varying(30),
    attribute_name character varying(100) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    pretty_plural character varying(100),
    sort_order integer NOT NULL,
    datatype character varying(50) NOT NULL,
    default_value text,
    min_n_values integer DEFAULT 1 NOT NULL,
    max_n_values integer DEFAULT 1 NOT NULL,
    storage character varying(13) DEFAULT 'type_specific'::character varying,
    static_p boolean DEFAULT false,
    column_name character varying(30),
    CONSTRAINT acs_attributes_max_n_values_ck CHECK ((max_n_values >= 0)),
    CONSTRAINT acs_attributes_min_n_values_ck CHECK ((min_n_values >= 0)),
    CONSTRAINT acs_attributes_n_values_ck CHECK ((min_n_values <= max_n_values)),
    CONSTRAINT acs_attributes_storage_ck CHECK (((storage)::text = ANY (ARRAY[('type_specific'::character varying)::text, ('generic'::character varying)::text])))
);


ALTER TABLE public.acs_attributes OWNER TO evex;

--
-- Name: TABLE acs_attributes; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_attributes IS '
 Each row in the <code>acs_attributes</code> table defines an
 attribute of the specified object type. Each object of this type
 must have a minimum of min_n_values values and a maximum of
 max_n_values for this attribute.
';


--
-- Name: COLUMN acs_attributes.table_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_attributes.table_name IS '
 If the data storage for the object type is arranged in a vertically
 partitioned manner, then this column should indicate in which table
 the attribute is stored.
';


--
-- Name: COLUMN acs_attributes.storage; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_attributes.storage IS '
 Indicates how values of this attribute are stored: either
 "type_specific" (i.e., in the table identified by
 object_type.table_name) or "generic" (i.e., in the
 acs_attribute_values table). (Or we could just have a column_name and,
 if it''s null, then assume that we''re using acs_attribute_values.)
';


--
-- Name: COLUMN acs_attributes.static_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_attributes.static_p IS '
 Determines whether this attribute is static. If so, only one copy of
 the attribute''s value exists for all objects of the same type. This
 value is stored in acs_static_attr_values table if storage_type is
 "generic". Otherwise, each object of this type can have its own
 distinct value for the attribute.
';


--
-- Name: COLUMN acs_attributes.column_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_attributes.column_name IS '
 If storage is "type_specific", column_name identifies the column in
 the table identified by object_type.table_name that holds the values
 of this attribute. If column_name is null, then we assume that
 attribute_name identifies a column in the table identified by
 object_type.table_name.
';


--
-- Name: acs_data_links; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_data_links (
    rel_id integer NOT NULL,
    object_id_one integer NOT NULL,
    object_id_two integer NOT NULL,
    relation_tag character varying(100)
);


ALTER TABLE public.acs_data_links OWNER TO evex;

--
-- Name: acs_data_links_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.acs_data_links_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acs_data_links_seq OWNER TO evex;

--
-- Name: acs_datatypes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_datatypes (
    datatype character varying(50) NOT NULL,
    max_n_values integer DEFAULT 1,
    database_type text,
    column_size text,
    column_check_expr text,
    column_output_function text,
    CONSTRAINT acs_datatypes_max_n_values_ck CHECK ((max_n_values > 0))
);


ALTER TABLE public.acs_datatypes OWNER TO evex;

--
-- Name: TABLE acs_datatypes; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_datatypes IS '
 Defines the set of available abstract datatypes for acs_attributes, along with
 an optional default mapping to a database type, size, and constraint to use if the
 attribute is created with create_attribute''s storage_type param set to "type_specific"
 and the create_storage_p param is set to true.  These defaults can be overwritten by
 the caller.

 The set of pre-defined datatypes is inspired by XForms
 (http://www.w3.org/TR/xforms-datamodel/).
';


--
-- Name: COLUMN acs_datatypes.max_n_values; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_datatypes.max_n_values IS '
 The maximum number of values that any attribute with this datatype
 can have. Of the predefined attribute types, only "boolean" specifies
 a non-null max_n_values, because it doesn''t make sense to have a
 boolean attribute with more than one value. There is no
 corresponding min_n_values column, because each attribute may be
 optional, i.e., min_n_values would always be zero.
';


--
-- Name: COLUMN acs_datatypes.database_type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_datatypes.database_type IS '
  The base database type corresponding to the abstract datatype.  For example "varchar" or
  "integer".
';


--
-- Name: COLUMN acs_datatypes.column_size; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_datatypes.column_size IS '
  Optional default column size specification to append to the base database type.  For
  example "1000" for the "string" abstract datatype, or "10,2" for "number".
';


--
-- Name: COLUMN acs_datatypes.column_check_expr; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_datatypes.column_check_expr IS '
  Optional check constraint expression to declare for the type_specific database column.  In
  Oracle, for instance, the abstract "boolean" type is declared "text", with a column
  check expression to restrict the values to "f" and "t".
';


--
-- Name: COLUMN acs_datatypes.column_output_function; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_datatypes.column_output_function IS '
  Function to call for this datatype when building a select view.  If not null, it will
  be called with an attribute name and is expected to return an expression on that
  attribute.  Example: date attributes will be transformed to calls to "to_char()".
';


--
-- Name: acs_enum_values; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_enum_values (
    attribute_id integer NOT NULL,
    enum_value character varying(1000) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    sort_order integer NOT NULL
);


ALTER TABLE public.acs_enum_values OWNER TO evex;

--
-- Name: acs_event_party_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_event_party_map (
    event_id integer NOT NULL,
    party_id integer NOT NULL
);


ALTER TABLE public.acs_event_party_map OWNER TO evex;

--
-- Name: TABLE acs_event_party_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_event_party_map IS '
        Maps a many-to-many relationship between events and parties.
';


--
-- Name: acs_events; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_events (
    event_id integer NOT NULL,
    name character varying(255),
    description text,
    html_p boolean,
    status_summary character varying(255),
    activity_id integer,
    timespan_id integer,
    recurrence_id integer,
    related_link_url text,
    related_link_text text,
    redirect_to_rel_link_p boolean
);


ALTER TABLE public.acs_events OWNER TO evex;

--
-- Name: TABLE acs_events; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_events IS '
    A relationship between a time span and an activity.
';


--
-- Name: COLUMN acs_events.name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_events.name IS '
        The name of the event.
';


--
-- Name: COLUMN acs_events.description; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_events.description IS '
        The description of the event.
';


--
-- Name: COLUMN acs_events.html_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_events.html_p IS '
        Whether or not the description is in HTML.
';


--
-- Name: COLUMN acs_events.status_summary; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_events.status_summary IS '
        Additional information to display along with the name.
';


--
-- Name: COLUMN acs_events.activity_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_events.activity_id IS '
    The activity associated with this event.
';


--
-- Name: COLUMN acs_events.timespan_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_events.timespan_id IS '
    The time span associated with this event.
';


--
-- Name: COLUMN acs_events.recurrence_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_events.recurrence_id IS '
    A description of how this event recurs.  If null, then this event does
    not recur.
';


--
-- Name: acs_events_activities; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_events_activities AS
 SELECT e.event_id,
    COALESCE(e.name, a.name) AS name,
    COALESCE(e.description, a.description) AS description,
    COALESCE(e.html_p, a.html_p) AS html_p,
    COALESCE(e.status_summary, a.status_summary) AS status_summary,
    e.activity_id,
    e.timespan_id,
    e.recurrence_id
   FROM public.acs_events e,
    public.acs_activities a
  WHERE (e.activity_id = a.activity_id);


ALTER TABLE public.acs_events_activities OWNER TO evex;

--
-- Name: VIEW acs_events_activities; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON VIEW public.acs_events_activities IS '
    This view pulls the event name and description from the underlying
    activity if necessary.
';


--
-- Name: time_intervals; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.time_intervals (
    interval_id integer NOT NULL,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    CONSTRAINT time_interval_date_order_ck CHECK ((start_date <= end_date))
);


ALTER TABLE public.time_intervals OWNER TO evex;

--
-- Name: TABLE time_intervals; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.time_intervals IS '
    A time interval is represented by two points in time.
';


--
-- Name: timespans; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.timespans (
    timespan_id integer NOT NULL,
    interval_id integer
);


ALTER TABLE public.timespans OWNER TO evex;

--
-- Name: TABLE timespans; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.timespans IS '
    Establishes a relationship between timespan_id and multiple time
    intervals.  Represents a range of moments at which an event can occur.
';


--
-- Name: acs_events_dates; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_events_dates AS
 SELECT e.event_id,
    e.name,
    e.description,
    e.html_p,
    e.status_summary,
    e.activity_id,
    e.timespan_id,
    e.recurrence_id,
    e.related_link_url,
    e.related_link_text,
    e.redirect_to_rel_link_p,
    t.start_date,
    t.end_date
   FROM public.acs_events e,
    public.timespans s,
    public.time_intervals t
  WHERE ((e.timespan_id = s.timespan_id) AND (s.interval_id = t.interval_id));


ALTER TABLE public.acs_events_dates OWNER TO evex;

--
-- Name: VIEW acs_events_dates; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON VIEW public.acs_events_dates IS '
    This view produces a separate row for each time interval in the timespan
    associated with an event.
';


--
-- Name: acs_func_defs; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_func_defs AS
 SELECT public.get_func_definition((pg_proc.proname)::character varying, pg_proc.proargtypes) AS definition,
    pg_proc.proname AS fname
   FROM pg_proc;


ALTER TABLE public.acs_func_defs OWNER TO evex;

--
-- Name: acs_func_headers; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_func_headers AS
 SELECT public.get_func_header((pg_proc.proname)::character varying, pg_proc.proargtypes) AS definition,
    pg_proc.proname AS fname
   FROM pg_proc;


ALTER TABLE public.acs_func_headers OWNER TO evex;

--
-- Name: acs_function_args; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_function_args (
    function character varying(100) NOT NULL,
    arg_seq integer NOT NULL,
    arg_name character varying(100),
    arg_default character varying(100)
);


ALTER TABLE public.acs_function_args OWNER TO evex;

--
-- Name: t_acs_log_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.t_acs_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.t_acs_log_id_seq OWNER TO evex;

--
-- Name: acs_log_id_seq; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_log_id_seq AS
 SELECT nextval('public.t_acs_log_id_seq'::regclass) AS nextval;


ALTER TABLE public.acs_log_id_seq OWNER TO evex;

--
-- Name: acs_logs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_logs (
    log_id integer NOT NULL,
    log_date timestamp with time zone DEFAULT now() NOT NULL,
    log_level character varying(20) NOT NULL,
    log_key character varying(100) NOT NULL,
    message text NOT NULL,
    CONSTRAINT acs_logs_log_level_ck CHECK (((log_level)::text = ANY (ARRAY[('notice'::character varying)::text, ('warn'::character varying)::text, ('error'::character varying)::text, ('debug'::character varying)::text])))
);


ALTER TABLE public.acs_logs OWNER TO evex;

--
-- Name: acs_magic_objects; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_magic_objects (
    name character varying(100) NOT NULL,
    object_id integer NOT NULL
);


ALTER TABLE public.acs_magic_objects OWNER TO evex;

--
-- Name: TABLE acs_magic_objects; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_magic_objects IS '
 This table allows us to provide semantic names for certain special
 objects like the site-wide organization, and the all users party.
';


--
-- Name: acs_mail_lite_bounce; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_mail_lite_bounce (
    party_id integer NOT NULL,
    bounce_count integer DEFAULT 1
);


ALTER TABLE public.acs_mail_lite_bounce OWNER TO evex;

--
-- Name: acs_mail_lite_bounce_notif; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_mail_lite_bounce_notif (
    party_id integer NOT NULL,
    notification_time timestamp with time zone DEFAULT now(),
    notification_count integer DEFAULT 0
);


ALTER TABLE public.acs_mail_lite_bounce_notif OWNER TO evex;

--
-- Name: acs_mail_lite_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.acs_mail_lite_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acs_mail_lite_id_seq OWNER TO evex;

--
-- Name: acs_mail_lite_mail_log; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_mail_lite_mail_log (
    party_id integer NOT NULL,
    last_mail_date timestamp with time zone DEFAULT now()
);


ALTER TABLE public.acs_mail_lite_mail_log OWNER TO evex;

--
-- Name: acs_mail_lite_queue; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_mail_lite_queue (
    message_id integer NOT NULL,
    creation_date text,
    locking_server text,
    to_addr text,
    cc_addr text,
    bcc_addr text,
    from_addr text,
    reply_to text,
    subject text,
    body text,
    package_id integer,
    file_ids text,
    filesystem_files text,
    delete_filesystem_files_p boolean,
    mime_type text,
    object_id integer,
    no_callback_p boolean,
    extraheaders text,
    use_sender_p boolean
);


ALTER TABLE public.acs_mail_lite_queue OWNER TO evex;

--
-- Name: acs_messages; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_messages (
    message_id integer NOT NULL,
    reply_to integer,
    sent_date timestamp with time zone NOT NULL,
    sender integer,
    rfc822_id character varying(250) NOT NULL,
    tree_sortkey bit varying
);


ALTER TABLE public.acs_messages OWNER TO evex;

--
-- Name: TABLE acs_messages; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_messages IS '
    A generic message which may be attached to any object in the system.
';


--
-- Name: COLUMN acs_messages.reply_to; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_messages.reply_to IS '
    Pointer to a message this message contains a reply to, for threading.
';


--
-- Name: COLUMN acs_messages.sent_date; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_messages.sent_date IS '
    The date the message was sent (may be distinct from when it was created
    or published in the system.)
';


--
-- Name: COLUMN acs_messages.sender; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_messages.sender IS '
    The person who sent the message (may be distinct from the person who
    entered the message in the system.)
';


--
-- Name: COLUMN acs_messages.rfc822_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_messages.rfc822_id IS '
    The RFC822 message-id of this message, for sending email.
';


--
-- Name: cr_items; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_items (
    item_id integer NOT NULL,
    parent_id integer NOT NULL,
    name character varying(400) NOT NULL,
    locale character varying(4),
    live_revision integer,
    latest_revision integer,
    publish_status character varying(40),
    content_type character varying(1000),
    storage_type public.cr_item_storage_type_enum DEFAULT 'text'::public.cr_item_storage_type_enum NOT NULL,
    storage_area_key character varying(100) DEFAULT 'CR_FILES'::character varying NOT NULL,
    tree_sortkey bit varying NOT NULL,
    max_child_sortkey bit varying,
    CONSTRAINT cr_items_publish_status_ck CHECK (((publish_status)::text = ANY (ARRAY[('production'::character varying)::text, ('ready'::character varying)::text, ('live'::character varying)::text, ('expired'::character varying)::text])))
);


ALTER TABLE public.cr_items OWNER TO evex;

--
-- Name: TABLE cr_items; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_items IS '
  Each content item has a row in this table, as well as a row in
  the acs_objects table.  The parent_id is used to place an
  item in a directory or place it within another container item.
';


--
-- Name: COLUMN cr_items.content_type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cr_items.content_type IS '
  The content type constrains the type of revision that may be
  added to this item (an item should have revisions of only one type).
  If null, then no revisions should be allowed.
';


--
-- Name: acs_messages_all; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_messages_all AS
 SELECT m.message_id,
    m.reply_to,
    m.sent_date,
    m.sender,
    m.rfc822_id,
    m.tree_sortkey,
    r.revision_id,
    r.title,
    r.mime_type,
    r.content
   FROM public.cr_items i,
    public.cr_revisions r,
    public.acs_messages m
  WHERE ((i.item_id = m.message_id) AND (r.revision_id = i.live_revision));


ALTER TABLE public.acs_messages_all OWNER TO evex;

--
-- Name: acs_messages_latest; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_messages_latest AS
 SELECT m.message_id,
    m.reply_to,
    m.sent_date,
    m.sender,
    m.rfc822_id,
    m.tree_sortkey,
    r.revision_id,
    r.title,
    r.mime_type,
    r.content
   FROM public.cr_items i,
    public.cr_revisions r,
    public.acs_messages m
  WHERE ((i.item_id = m.message_id) AND (r.revision_id = public.content_item__get_latest_revision(i.item_id)));


ALTER TABLE public.acs_messages_latest OWNER TO evex;

--
-- Name: acs_messages_outgoing; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_messages_outgoing (
    message_id integer NOT NULL,
    to_address character varying(1000) NOT NULL,
    grouping_id integer,
    wait_until timestamp with time zone NOT NULL
);


ALTER TABLE public.acs_messages_outgoing OWNER TO evex;

--
-- Name: TABLE acs_messages_outgoing; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_messages_outgoing IS '
    Set of messages to be sent to parties.  It is assumed that sending a
    message either queues it in a real MTA or fails, so no information about
    what''s been tried how many times is kept.
';


--
-- Name: COLUMN acs_messages_outgoing.to_address; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_messages_outgoing.to_address IS '
    The email address to send this message to.  Note that this will
    probably become a party_id again once upgrading a party to a user
    is possible.
';


--
-- Name: COLUMN acs_messages_outgoing.grouping_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_messages_outgoing.grouping_id IS '
    This identifier is used to group sets of messages to be sent as
    digests.  When a message is about to be sent, any other messages
    with the same grouping_id will be put together with it in a
    digest.  It is recommended but not required that an object id is
    used.  Bboard, for example, might use the forum id that the user''s
    subscribed to.  For instant (non-digest) updates, it would be
    appropriate to use null, which is never equal to anything else.
';


--
-- Name: COLUMN acs_messages_outgoing.wait_until; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_messages_outgoing.wait_until IS '
    Don''t schedule a send until after this date.  If another message with
    the same grouping ID is scheduled to be sent, then this message may be
    sent at the same time.  (So, for example, daily digests would be
    achieved by setting the grouping_id to the same value, and the wait_until
    value to the end of the current day.  As soon as one message in the group
    is to be sent, all will be sent.)
';


--
-- Name: acs_named_objects; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_named_objects (
    object_id integer NOT NULL,
    object_name character varying(200),
    package_id integer
);


ALTER TABLE public.acs_named_objects OWNER TO evex;

--
-- Name: acs_object_context_index; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_object_context_index (
    object_id integer NOT NULL,
    ancestor_id integer NOT NULL,
    n_generations integer NOT NULL,
    CONSTRAINT acs_obj_context_idx_n_gen_ck CHECK ((n_generations >= 0))
);


ALTER TABLE public.acs_object_context_index OWNER TO evex;

--
-- Name: acs_object_contexts; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_object_contexts AS
 SELECT acs_object_context_index.object_id,
    acs_object_context_index.ancestor_id,
    acs_object_context_index.n_generations
   FROM public.acs_object_context_index
  WHERE (acs_object_context_index.object_id <> acs_object_context_index.ancestor_id);


ALTER TABLE public.acs_object_contexts OWNER TO evex;

--
-- Name: acs_object_paths; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_object_paths AS
 SELECT acs_object_context_index.object_id,
    acs_object_context_index.ancestor_id,
    acs_object_context_index.n_generations
   FROM public.acs_object_context_index;


ALTER TABLE public.acs_object_paths OWNER TO evex;

--
-- Name: acs_permissions; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_permissions (
    object_id integer NOT NULL,
    grantee_id integer NOT NULL,
    privilege character varying(100) NOT NULL
);


ALTER TABLE public.acs_permissions OWNER TO evex;

--
-- Name: acs_permissions_all; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_permissions_all AS
 SELECT op.object_id,
    p.grantee_id,
    p.privilege
   FROM public.acs_object_paths op,
    public.acs_permissions p
  WHERE (op.ancestor_id = p.object_id);


ALTER TABLE public.acs_permissions_all OWNER TO evex;

--
-- Name: acs_privilege_descendant_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_privilege_descendant_map (
    privilege character varying(100) NOT NULL,
    descendant character varying(100) NOT NULL
);


ALTER TABLE public.acs_privilege_descendant_map OWNER TO evex;

--
-- Name: acs_object_grantee_priv_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_object_grantee_priv_map AS
 SELECT a.object_id,
    a.grantee_id,
    m.descendant AS privilege
   FROM public.acs_permissions_all a,
    public.acs_privilege_descendant_map m
  WHERE ((a.privilege)::text = (m.privilege)::text);


ALTER TABLE public.acs_object_grantee_priv_map OWNER TO evex;

--
-- Name: t_acs_object_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.t_acs_object_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.t_acs_object_id_seq OWNER TO evex;

--
-- Name: acs_object_id_seq; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_object_id_seq AS
 SELECT nextval('public.t_acs_object_id_seq'::regclass) AS nextval;


ALTER TABLE public.acs_object_id_seq OWNER TO evex;

--
-- Name: party_approved_member_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.party_approved_member_map (
    party_id integer NOT NULL,
    member_id integer NOT NULL,
    originating_rel_id integer NOT NULL
);


ALTER TABLE public.party_approved_member_map OWNER TO evex;

--
-- Name: acs_object_party_privilege_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_object_party_privilege_map AS
 SELECT c.object_id,
    pdm.descendant AS privilege,
    pamm.member_id AS party_id
   FROM public.acs_object_context_index c,
    public.acs_permissions p,
    public.acs_privilege_descendant_map pdm,
    public.party_approved_member_map pamm
  WHERE ((c.ancestor_id = p.object_id) AND ((pdm.privilege)::text = (p.privilege)::text) AND (pamm.party_id = p.grantee_id));


ALTER TABLE public.acs_object_party_privilege_map OWNER TO evex;

--
-- Name: acs_object_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_object_types (
    object_type character varying(1000) NOT NULL,
    supertype character varying(1000),
    abstract_p boolean DEFAULT false NOT NULL,
    pretty_name character varying(1000) NOT NULL,
    pretty_plural character varying(1000) NOT NULL,
    table_name character varying(30),
    id_column character varying(30),
    package_name character varying(30) NOT NULL,
    name_method character varying(100),
    type_extension_table character varying(30),
    dynamic_p boolean DEFAULT false,
    tree_sortkey bit varying,
    status_column character varying(30),
    type_column character varying(30),
    status_type_table character varying(30),
    type_category_type character varying(50),
    status_category_type character varying(50),
    object_type_gif text DEFAULT 'default_object_type_gif'::text,
    CONSTRAINT acs_object_types_table_id_name_ck CHECK ((((table_name IS NULL) AND (id_column IS NULL)) OR ((table_name IS NOT NULL) AND (id_column IS NOT NULL))))
);


ALTER TABLE public.acs_object_types OWNER TO evex;

--
-- Name: TABLE acs_object_types; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_object_types IS '
 Each row in the acs_object_types table represents a distinct class
 of objects. For each instance of any acs_object_type, there is a
 corresponding row in the acs_objects table. Essentially,
 acs_objects.object_id supersedes the on_which_table/on_what_id pair
 that ACS 3.x used as the system-wide identifier for heterogeneous
 objects. The value of having a system-wide identifier for
 heterogeneous objects is that it helps us provide general solutions
 for common problems like access control, workflow, categorppization,
 and search. (Note that this framework is not overly restrictive,
 because it doesn''t force every type of object to be represented in
 the acs_object_types table.) Each acs_object_type has:
 * Attributes (stored in the acs_attributes table)
   Examples:
   * the "user" object_type has "email" and "password" attributes
   * the "content_item" object_type has "title" and "body" attributes
 * Relationship types (stored in the acs_rel_types table)
   Examples:
   * "a team has one team leader who is a user" (in other words,
     instances of the "team" object_type must have one "team leader"
     relationship to an instance of the "user" object_type)
   * "a content item may have zero or authors who are people or
     organizations, i.e., parties" (in other words, instances of
     the "content_item" object_type may have zero or more "author"
     relationships to instances of the "party" object_type)
 Possible extensions include automatic versioning, logical deletion,
 and auditing.
';


--
-- Name: COLUMN acs_object_types.supertype; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.supertype IS '
 The object_type of which this object_type is a specialization (if
 any). For example, the supertype of the "user" object_type is
 "person". An object_type inherits the attributes and relationship
 rules of its supertype, though it can add constraints to the
 attributes and/or it can override the relationship rules. For
 instance, the "person" object_type has an optional "email" attribute,
 while its "user" subtype makes "email" mandatory.
';


--
-- Name: COLUMN acs_object_types.abstract_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.abstract_p IS '
 ...
 If the object_type is not abstract, then all of its attributes must
 have a non-null storage specified.
';


--
-- Name: COLUMN acs_object_types.table_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.table_name IS '
 The name of the type-specific table in which the values of attributes
 specific to this object_type are stored, if any.
';


--
-- Name: COLUMN acs_object_types.id_column; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.id_column IS '
 The name of the primary key column in the table identified by
 table_name.
';


--
-- Name: COLUMN acs_object_types.name_method; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.name_method IS '
 The name of a stored function that takes an object_id as an argument
 and returns a varchar2: the corresponding object name. This column is
 required to implement the polymorphic behavior of the acs.object_name()
 function.
';


--
-- Name: COLUMN acs_object_types.type_extension_table; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.type_extension_table IS '
 Object types (and their subtypes) that require more type-specific
 data than the fields already existing in acs_object_types may name
 a table in which that data is stored.  The table should be keyed
 by the associated object_type.  For example, a row in the group_types
 table stores a default approval policy for every user group of that type.
 In this example, the group_types table has a primary key named
 group_type that references acs_object_types.  If a subtype of groups
 for example, lab_courses, has its own type-specific data, it could be
 maintained in a table called lab_course_types, with a primary key named
 lab_course_type that references group_types.  This provides the same
 functionality as static class fields in an object-oriented programming language.
';


--
-- Name: COLUMN acs_object_types.dynamic_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.dynamic_p IS '
  This flag is used to identify object types created dynamically
  (e.g. through a web interface). Dynamically created object types can
  be administered differently. For example, the group type admin pages
  only allow users to add attributes or otherwise modify dynamic
  object types. This column is still experimental and may not be supported in the
  future. That is the reason it is not yet part of the API.
';


--
-- Name: COLUMN acs_object_types.status_column; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.status_column IS 'Defines the column in the status_type_table which stores the category_id for the STATUS of an object of this object_type.';


--
-- Name: COLUMN acs_object_types.type_column; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.type_column IS 'Defines the column in the status_type_table which stores the category_id for the TYPE of an object of this object_type.';


--
-- Name: COLUMN acs_object_types.status_type_table; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.status_type_table IS 'Defines the table which stores the STATUS and TYPE of the object_type. Defaults to the table_namee of the object_type';


--
-- Name: COLUMN acs_object_types.type_category_type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.type_category_type IS 'Defines the category_type from im_categories which contains the options for the TYPE of the object';


--
-- Name: COLUMN acs_object_types.object_type_gif; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_types.object_type_gif IS 'Image for the object_type';


--
-- Name: acs_object_type_supertype_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_object_type_supertype_map AS
 SELECT ot1.object_type,
    ot2.object_type AS ancestor_type
   FROM public.acs_object_types ot1,
    public.acs_object_types ot2
  WHERE (((ot1.object_type)::text <> (ot2.object_type)::text) AND ((ot1.tree_sortkey >= ot2.tree_sortkey) AND (ot1.tree_sortkey <= public.tree_right(ot2.tree_sortkey))));


ALTER TABLE public.acs_object_type_supertype_map OWNER TO evex;

--
-- Name: acs_object_type_attributes; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_object_type_attributes AS
 SELECT all_types.object_type,
    all_types.ancestor_type,
    attr.attribute_id,
    attr.table_name,
    attr.attribute_name,
    attr.pretty_name,
    attr.pretty_plural,
    attr.sort_order,
    attr.datatype,
    attr.default_value,
    attr.min_n_values,
    attr.max_n_values,
    attr.storage,
    attr.static_p,
    attr.column_name
   FROM public.acs_attributes attr,
    ( SELECT map.object_type,
            map.ancestor_type
           FROM public.acs_object_type_supertype_map map,
            public.acs_object_types t
          WHERE ((map.object_type)::text = (t.object_type)::text)
        UNION ALL
         SELECT t.object_type,
            t.object_type AS ancestor_type
           FROM public.acs_object_types t) all_types
  WHERE ((attr.object_type)::text = (all_types.ancestor_type)::text);


ALTER TABLE public.acs_object_type_attributes OWNER TO evex;

--
-- Name: acs_object_type_tables; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_object_type_tables (
    object_type character varying(1000) NOT NULL,
    table_name character varying(30) NOT NULL,
    id_column character varying(30)
);


ALTER TABLE public.acs_object_type_tables OWNER TO evex;

--
-- Name: TABLE acs_object_type_tables; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_object_type_tables IS '
 This table is used for objects that want to vertically partition
 their data storage, for example user_demographics stores a set of
 optional columns that belong to a user object.
';


--
-- Name: COLUMN acs_object_type_tables.id_column; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.acs_object_type_tables.id_column IS '
 If this is null then the id column is assumed to have the same name
 as the primary table.
';


--
-- Name: acs_permissions_lock; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_permissions_lock (
    lck integer
);


ALTER TABLE public.acs_permissions_lock OWNER TO evex;

--
-- Name: acs_privilege_hierarchy_index; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_privilege_hierarchy_index (
    privilege character varying(100) NOT NULL,
    child_privilege character varying(100) NOT NULL,
    tree_sortkey bit varying
);


ALTER TABLE public.acs_privilege_hierarchy_index OWNER TO evex;

--
-- Name: acs_privileges; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_privileges (
    privilege character varying(100) NOT NULL,
    pretty_name character varying(100),
    pretty_plural character varying(100)
);


ALTER TABLE public.acs_privileges OWNER TO evex;

--
-- Name: TABLE acs_privileges; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_privileges IS '
 Privileges share a global namespace. This is to avoid a
 situation where granting the foo privilege on one type of object can
 have an entirely different meaning than granting the foo privilege on
 another type of object.
';


--
-- Name: acs_privilege_descendant_map_view; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_privilege_descendant_map_view AS
 SELECT DISTINCT h1.privilege,
    h2.child_privilege AS descendant
   FROM public.acs_privilege_hierarchy_index h1,
    public.acs_privilege_hierarchy_index h2
  WHERE ((h2.tree_sortkey >= h1.tree_sortkey) AND (h2.tree_sortkey <= public.tree_right(h1.tree_sortkey)))
UNION
 SELECT acs_privileges.privilege,
    acs_privileges.privilege AS descendant
   FROM public.acs_privileges;


ALTER TABLE public.acs_privilege_descendant_map_view OWNER TO evex;

--
-- Name: acs_privilege_hierarchy; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_privilege_hierarchy (
    privilege character varying(100) NOT NULL,
    child_privilege character varying(100) NOT NULL
);


ALTER TABLE public.acs_privilege_hierarchy OWNER TO evex;

--
-- Name: TABLE acs_privilege_hierarchy; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_privilege_hierarchy IS '
 The acs_privilege_hierarchy gives us an easy way to say: The foo
 privilege is a superset of the bar privilege.
';


--
-- Name: acs_reference_repositories; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_reference_repositories (
    repository_id integer NOT NULL,
    table_name character varying(100) NOT NULL,
    internal_data_p boolean,
    package_name character varying(100),
    last_update timestamp with time zone,
    source character varying(1000),
    source_url character varying(255),
    effective_date timestamp with time zone,
    expiry_date timestamp with time zone,
    maintainer_id integer,
    lob integer
);


ALTER TABLE public.acs_reference_repositories OWNER TO evex;

--
-- Name: t_acs_rel_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.t_acs_rel_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.t_acs_rel_id_seq OWNER TO evex;

--
-- Name: acs_rel_id_seq; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_rel_id_seq AS
 SELECT nextval('public.t_acs_rel_id_seq'::regclass) AS nextval;


ALTER TABLE public.acs_rel_id_seq OWNER TO evex;

--
-- Name: acs_rel_roles; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_rel_roles (
    role character varying(100) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    pretty_plural character varying(100) NOT NULL
);


ALTER TABLE public.acs_rel_roles OWNER TO evex;

--
-- Name: acs_rel_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_rel_types (
    rel_type character varying(1000) NOT NULL,
    object_type_one character varying(1000) NOT NULL,
    role_one character varying(100),
    min_n_rels_one integer DEFAULT 0 NOT NULL,
    max_n_rels_one integer,
    object_type_two character varying(1000) NOT NULL,
    role_two character varying(100),
    min_n_rels_two integer DEFAULT 0 NOT NULL,
    max_n_rels_two integer,
    composable_p boolean DEFAULT true NOT NULL,
    CONSTRAINT acs_rel_types_max_n_1_ck CHECK ((max_n_rels_one >= 0)),
    CONSTRAINT acs_rel_types_max_n_2_ck CHECK ((max_n_rels_two >= 0)),
    CONSTRAINT acs_rel_types_min_n_1_ck CHECK ((min_n_rels_one >= 0)),
    CONSTRAINT acs_rel_types_min_n_2_ck CHECK ((min_n_rels_two >= 0)),
    CONSTRAINT acs_rel_types_n_rels_one_ck CHECK ((min_n_rels_one <= max_n_rels_one)),
    CONSTRAINT acs_rel_types_n_rels_two_ck CHECK ((min_n_rels_two <= max_n_rels_two))
);


ALTER TABLE public.acs_rel_types OWNER TO evex;

--
-- Name: TABLE acs_rel_types; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_rel_types IS '
 Each row in <code>acs_rel_types</code> represents a type of
 relationship between objects. For example, the following DML
 statement:
 <blockquote><pre>
 insert into acs_rel_types
  (rel_type,
   object_type_one, role_one, min_n_rels_one, max_n_rels_one,
   object_type_two, role_two, min_n_rels_two, max_n_rels_two)
 values
  (''employment'',
   ''person'', ''employee'', 0, null,
   ''company'', ''employer'', 0, null)
 </pre></blockquote>
 defines an "employment" relationship type that can be expressed in
 in natural language as:
 <blockquote>
 A person may be the employee of zero or more companies, and a company
 may be the employer of zero or more people.
 </blockquote>
';


--
-- Name: acs_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_rels (
    rel_id integer NOT NULL,
    rel_type character varying(100) NOT NULL,
    object_id_one integer NOT NULL,
    object_id_two integer NOT NULL
);


ALTER TABLE public.acs_rels OWNER TO evex;

--
-- Name: TABLE acs_rels; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_rels IS '
 The acs_rels table is essentially a generic mapping table for
 acs_objects. Once we come up with a way to associate attributes with
 relationship types, we could replace many of the ACS 3.x mapping
 tables like user_content_map, user_group_map, and
 user_group_type_modules_map with this one table. Much application
 logic consists of asking questions like "Does object X have a
 relationship of type Y to object Z?" where all that differs is
 X, Y, and Z. Thus, the value of consolidating many mapping tables
 into one is that we can provide a generic API for defining and
 querying relationships. In addition, we may need to design a way to
 enable "type_specific" storage for relationships (i.e., foreign key
 columns for one-to-many relationships and custom mapping tables for
 many-to-many relationships), instead of only supporting "generic"
 storage in the acs_rels table. This would parallel what we do with
 acs_attributes.
';


--
-- Name: acs_sc_bindings; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_sc_bindings (
    contract_id integer,
    impl_id integer
);


ALTER TABLE public.acs_sc_bindings OWNER TO evex;

--
-- Name: acs_sc_contracts; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_sc_contracts (
    contract_id integer NOT NULL,
    contract_name character varying(1000) NOT NULL,
    contract_desc text NOT NULL
);


ALTER TABLE public.acs_sc_contracts OWNER TO evex;

--
-- Name: acs_sc_impl_aliases; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_sc_impl_aliases (
    impl_id integer,
    impl_name character varying(100),
    impl_contract_name character varying(1000),
    impl_operation_name character varying(100),
    impl_alias character varying(100),
    impl_pl character varying(100)
);


ALTER TABLE public.acs_sc_impl_aliases OWNER TO evex;

--
-- Name: acs_sc_impls; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_sc_impls (
    impl_id integer NOT NULL,
    impl_name character varying(100),
    impl_pretty_name character varying(200),
    impl_owner_name character varying(1000),
    impl_contract_name character varying(1000)
);


ALTER TABLE public.acs_sc_impls OWNER TO evex;

--
-- Name: acs_sc_msg_type_elements; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_sc_msg_type_elements (
    msg_type_id integer,
    element_name character varying(100),
    element_msg_type_id integer,
    element_msg_type_isset_p boolean,
    element_pos integer
);


ALTER TABLE public.acs_sc_msg_type_elements OWNER TO evex;

--
-- Name: acs_sc_msg_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_sc_msg_types (
    msg_type_id integer NOT NULL,
    msg_type_name character varying(100)
);


ALTER TABLE public.acs_sc_msg_types OWNER TO evex;

--
-- Name: acs_sc_operations; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_sc_operations (
    contract_id integer,
    operation_id integer NOT NULL,
    contract_name character varying(1000),
    operation_name character varying(100),
    operation_desc text NOT NULL,
    operation_iscachable_p boolean,
    operation_nargs integer,
    operation_inputtype_id integer,
    operation_outputtype_id integer
);


ALTER TABLE public.acs_sc_operations OWNER TO evex;

--
-- Name: acs_static_attr_values; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.acs_static_attr_values (
    object_type character varying(1000) NOT NULL,
    attribute_id integer NOT NULL,
    attr_value text
);


ALTER TABLE public.acs_static_attr_values OWNER TO evex;

--
-- Name: TABLE acs_static_attr_values; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.acs_static_attr_values IS '
  Stores static values for the object attributes. One row per object
  type.
';


--
-- Name: parties; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.parties (
    party_id integer NOT NULL,
    email character varying(100),
    url character varying(200)
);


ALTER TABLE public.parties OWNER TO evex;

--
-- Name: TABLE parties; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.parties IS '
 Party is the supertype of person and organization. It exists because
 many other types of object can have relationships to parties.
';


--
-- Name: COLUMN parties.url; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.parties.url IS '
 We store url here so that we can always make party names hyperlinks
 without joining to any other table.
';


--
-- Name: persons; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.persons (
    person_id integer NOT NULL,
    first_names character varying(100) NOT NULL,
    last_name character varying(100) NOT NULL,
    bio text,
    portrait_checkdate date,
    portrait_file character varying(400),
    demo_group character varying(50),
    demo_password character varying(50)
);


ALTER TABLE public.persons OWNER TO evex;

--
-- Name: TABLE persons; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.persons IS '
 Need to handle titles like Mr., Ms., Mrs., Dr., etc. and suffixes
 like M.D., Ph.D., Jr., Sr., III, IV, etc.
';


--
-- Name: users; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.users (
    user_id integer NOT NULL,
    authority_id integer,
    username character varying(100) NOT NULL,
    screen_name character varying(100),
    priv_name integer DEFAULT 0 NOT NULL,
    priv_email integer DEFAULT 5 NOT NULL,
    email_verified_p boolean DEFAULT true,
    email_bouncing_p boolean DEFAULT false NOT NULL,
    no_alerts_until timestamp with time zone,
    last_visit timestamp with time zone,
    second_to_last_visit timestamp with time zone,
    n_sessions integer DEFAULT 1 NOT NULL,
    password character(40),
    salt character(40),
    password_question character varying(1000),
    password_answer character varying(1000),
    password_changed_date timestamp with time zone,
    auth_token character varying(100),
    skin_id integer DEFAULT 0
);


ALTER TABLE public.users OWNER TO evex;

--
-- Name: TABLE users; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.users IS '
 The creation_date and creation_ip columns inherited from acs_objects
 indicate when and from where the user registered. How do we apply a
 constraint ("email must not be null") to the parent type?
';


--
-- Name: COLUMN users.no_alerts_until; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.users.no_alerts_until IS '
 For suppressing email alerts
';


--
-- Name: COLUMN users.last_visit; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.users.last_visit IS '
 Set when user reappears at site
';


--
-- Name: COLUMN users.second_to_last_visit; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.users.second_to_last_visit IS '
 This is what most pages query against (since last_visit will only be
 a few minutes old for most pages in a session)
';


--
-- Name: COLUMN users.n_sessions; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.users.n_sessions IS '
 How many times this user has visited
';


--
-- Name: acs_users_all; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.acs_users_all AS
 SELECT pa.party_id,
    pa.email,
    pa.url,
    pe.person_id,
    pe.first_names,
    pe.last_name,
    pe.bio,
    u.user_id,
    u.authority_id,
    u.username,
    u.screen_name,
    u.priv_name,
    u.priv_email,
    u.email_verified_p,
    u.email_bouncing_p,
    u.no_alerts_until,
    u.last_visit,
    u.second_to_last_visit,
    u.n_sessions,
    u.password,
    u.salt,
    u.password_question,
    u.password_answer,
    u.password_changed_date,
    u.auth_token
   FROM public.parties pa,
    public.persons pe,
    public.users u
  WHERE ((pa.party_id = pe.person_id) AND (pe.person_id = u.user_id));


ALTER TABLE public.acs_users_all OWNER TO evex;

--
-- Name: ad_locale_user_prefs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ad_locale_user_prefs (
    user_id integer,
    package_id integer,
    locale character varying(30) NOT NULL
);


ALTER TABLE public.ad_locale_user_prefs OWNER TO evex;

--
-- Name: ad_locales; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ad_locales (
    locale character varying(30) NOT NULL,
    language character(3) NOT NULL,
    country character(2) NOT NULL,
    variant character varying(30),
    label character varying(200) NOT NULL,
    nls_language character varying(30) NOT NULL,
    nls_territory character varying(30),
    nls_charset character varying(30),
    mime_charset character varying(30),
    default_p boolean DEFAULT false,
    enabled_p boolean DEFAULT true
);


ALTER TABLE public.ad_locales OWNER TO evex;

--
-- Name: TABLE ad_locales; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.ad_locales IS '
  An OpenACS locale is identified by a language and country.
  Locale definitions in Oracle consist of a language, and optionally
  territory and character set.  (Languages are associated with default
  territories and character sets when not defined).  The formats
  for numbers, currency, dates, etc. are determined by the territory.
  language is the shortest ISO 639 code (lowercase).
  country is two letter (uppercase) abbrev is ISO 3166 country code
  mime_charset is IANA charset name
  nls_charset is  Oracle charset name
';


--
-- Name: ad_template_sample_users; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ad_template_sample_users (
    user_id integer NOT NULL,
    first_name character varying(20),
    last_name character varying(20),
    address1 character varying(40),
    address2 character varying(40),
    city character varying(40),
    state character varying(2)
);


ALTER TABLE public.ad_template_sample_users OWNER TO evex;

--
-- Name: ad_template_sample_users_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ad_template_sample_users_seq
    START WITH 5
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ad_template_sample_users_seq OWNER TO evex;

--
-- Name: ad_template_sample_users_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ad_template_sample_users_sequence AS
 SELECT nextval('public.ad_template_sample_users_seq'::regclass) AS nextval;


ALTER TABLE public.ad_template_sample_users_sequence OWNER TO evex;

--
-- Name: admin_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.admin_rels (
    rel_id integer NOT NULL
);


ALTER TABLE public.admin_rels OWNER TO evex;

--
-- Name: all_object_party_privilege_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.all_object_party_privilege_map AS
 SELECT acs_object_party_privilege_map.object_id,
    acs_object_party_privilege_map.privilege,
    acs_object_party_privilege_map.party_id
   FROM public.acs_object_party_privilege_map;


ALTER TABLE public.all_object_party_privilege_map OWNER TO evex;

--
-- Name: cr_child_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_child_rels (
    rel_id integer NOT NULL,
    parent_id integer NOT NULL,
    child_id integer NOT NULL,
    relation_tag character varying(100),
    order_n integer
);


ALTER TABLE public.cr_child_rels OWNER TO evex;

--
-- Name: TABLE cr_child_rels; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_child_rels IS '
  Provides for richer parent-child relationships than the simple
  link encapsulated in the primary table.  May be subclassed to provide
  additional attributes.
';


--
-- Name: all_photo_images; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.all_photo_images AS
 SELECT i.item_id,
    ccr.relation_tag,
    im.image_id,
    im.width,
    im.height,
    p.pa_photo_id,
    p.caption,
    p.story,
    p.user_filename,
    p.camera_model,
    p.date_taken,
    p.flash,
    p.focal_length,
    p.exposure_time,
    p.aperture,
    p.focus_distance,
    p.metering,
    p.sha256,
    p.photographer
   FROM public.cr_items i,
    public.cr_items i2,
    public.pa_photos p,
    public.cr_child_rels ccr,
    public.images im
  WHERE ((i.item_id = ccr.parent_id) AND (p.pa_photo_id = i.live_revision) AND (ccr.child_id = i2.item_id) AND (i2.live_revision = im.image_id));


ALTER TABLE public.all_photo_images OWNER TO evex;

--
-- Name: ams_attribute_items; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_attribute_items (
    attribute_id integer NOT NULL,
    ams_attribute_id integer NOT NULL,
    widget character varying(100) NOT NULL,
    dynamic_p boolean DEFAULT false NOT NULL,
    deprecated_p boolean DEFAULT false NOT NULL,
    help_text character varying(50)
);


ALTER TABLE public.ams_attribute_items OWNER TO evex;

--
-- Name: ams_attribute_values; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_attribute_values (
    object_id integer NOT NULL,
    attribute_id integer NOT NULL,
    value_id integer NOT NULL
);


ALTER TABLE public.ams_attribute_values OWNER TO evex;

--
-- Name: ams_attributes; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ams_attributes AS
 SELECT acs_attributes.attribute_id,
    acs_attributes.object_type,
    acs_attributes.table_name,
    acs_attributes.attribute_name,
    acs_attributes.pretty_name,
    acs_attributes.pretty_plural,
    acs_attributes.sort_order,
    acs_attributes.datatype,
    acs_attributes.default_value,
    acs_attributes.min_n_values,
    acs_attributes.max_n_values,
    acs_attributes.storage,
    acs_attributes.static_p,
    acs_attributes.column_name,
    ams_attribute_items.ams_attribute_id,
    ams_attribute_items.widget,
    ams_attribute_items.dynamic_p,
    ams_attribute_items.deprecated_p
   FROM (public.acs_attributes
     LEFT JOIN public.ams_attribute_items ON ((acs_attributes.attribute_id = ams_attribute_items.attribute_id)));


ALTER TABLE public.ams_attributes OWNER TO evex;

--
-- Name: ams_list_attribute_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_list_attribute_map (
    list_id integer NOT NULL,
    attribute_id integer NOT NULL,
    sort_order integer NOT NULL,
    required_p boolean NOT NULL,
    section_heading character varying(200),
    html_options character varying(1000)
);


ALTER TABLE public.ams_list_attribute_map OWNER TO evex;

--
-- Name: ams_lists; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_lists (
    list_id integer NOT NULL,
    package_key character varying(100) NOT NULL,
    object_type character varying(1000) NOT NULL,
    list_name character varying(100) NOT NULL,
    pretty_name character varying(200) NOT NULL,
    description character varying(200),
    description_mime_type character varying(200)
);


ALTER TABLE public.ams_lists OWNER TO evex;

--
-- Name: ams_numbers; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_numbers (
    value_id integer NOT NULL,
    number numeric NOT NULL
);


ALTER TABLE public.ams_numbers OWNER TO evex;

--
-- Name: ams_option_ids; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_option_ids (
    value_id integer NOT NULL
);


ALTER TABLE public.ams_option_ids OWNER TO evex;

--
-- Name: ams_option_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_option_types (
    option_id integer NOT NULL,
    attribute_id integer NOT NULL,
    option character varying(200) NOT NULL,
    sort_order integer NOT NULL,
    deprecated_p boolean DEFAULT false NOT NULL
);


ALTER TABLE public.ams_option_types OWNER TO evex;

--
-- Name: ams_options; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_options (
    value_id integer NOT NULL,
    option_id integer NOT NULL
);


ALTER TABLE public.ams_options OWNER TO evex;

--
-- Name: ams_texts; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_texts (
    value_id integer NOT NULL,
    text text NOT NULL,
    text_format character varying(200) DEFAULT 'text/plain'::character varying NOT NULL
);


ALTER TABLE public.ams_texts OWNER TO evex;

--
-- Name: ams_times; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_times (
    value_id integer NOT NULL,
    "time" timestamp with time zone NOT NULL
);


ALTER TABLE public.ams_times OWNER TO evex;

--
-- Name: ams_widgets; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ams_widgets (
    widget character varying(100) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    value_method character varying(100),
    active_p boolean
);


ALTER TABLE public.ams_widgets OWNER TO evex;

--
-- Name: anon_func_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.anon_func_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.anon_func_seq OWNER TO evex;

--
-- Name: apm_applications; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_applications (
    application_id integer NOT NULL
);


ALTER TABLE public.apm_applications OWNER TO evex;

--
-- Name: TABLE apm_applications; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_applications IS '
This table records data on all of the applications registered in OpenACS.
';


--
-- Name: apm_package_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_package_types (
    package_key character varying(100) NOT NULL,
    pretty_name character varying(100) NOT NULL,
    pretty_plural character varying(100),
    package_uri character varying(1500) NOT NULL,
    package_type character varying(300),
    spec_file_path character varying(1500),
    spec_file_mtime integer,
    initial_install_p boolean DEFAULT false NOT NULL,
    singleton_p boolean DEFAULT false NOT NULL,
    implements_subsite_p boolean DEFAULT false NOT NULL,
    inherit_templates_p boolean DEFAULT true NOT NULL,
    CONSTRAINT apm_packages_pack_type_ck CHECK (((package_type)::text = ANY (ARRAY[('apm_application'::character varying)::text, ('apm_service'::character varying)::text])))
);


ALTER TABLE public.apm_package_types OWNER TO evex;

--
-- Name: TABLE apm_package_types; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_package_types IS '
 This table holds additional knowledge level attributes for the
 apm_package type and its subtypes.
';


--
-- Name: COLUMN apm_package_types.package_key; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_types.package_key IS '
 The package_key is what we call the package on this system.
';


--
-- Name: COLUMN apm_package_types.package_uri; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_types.package_uri IS '
 The package URI indicates where the package can be downloaded and 
 is a unique identifier for the package.
';


--
-- Name: COLUMN apm_package_types.spec_file_path; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_types.spec_file_path IS '
 The path to the package specification file.
';


--
-- Name: COLUMN apm_package_types.spec_file_mtime; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_types.spec_file_mtime IS '
 The last time a spec file was modified.  This information is maintained in the 
database so that if a user changes the specification file by editing the file
(as opposed to using the UI, the system can read the .info file and update
the information in the database appropriately.
';


--
-- Name: COLUMN apm_package_types.initial_install_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_types.initial_install_p IS '
 Indicates if the package should be installed during initial installation,
 in other words whether or not this package is part of the OpenACS core.
';


--
-- Name: COLUMN apm_package_types.singleton_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_types.singleton_p IS '
 Indicates if the package can be used for subsites.  If this is set to 
 ''t'', the package can be enabled for any subsite.  Otherwise, it is 
 restricted to the acs-admin/ subsite.
';


--
-- Name: COLUMN apm_package_types.implements_subsite_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_types.implements_subsite_p IS '
  If true, this package implements subsite semantics, typically by extending the
  acs-subsite package.  Used by the admin "mount subsite" UI, the request processor (for
  setting ad_conn''s subsite_* attributes), etc.
';


--
-- Name: COLUMN apm_package_types.inherit_templates_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_types.inherit_templates_p IS '
  If true, inherit templates from packages this package extends.  If false, only
  templates in this package''s www subdirectory tree will be mapped to URLs by the
  request processor.
';


--
-- Name: apm_package_versions; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_package_versions (
    version_id integer NOT NULL,
    package_key character varying(100) NOT NULL,
    version_name character varying(100) NOT NULL,
    version_uri character varying(1500) NOT NULL,
    summary character varying(3000),
    description_format character varying(100),
    description text,
    release_date timestamp with time zone,
    vendor character varying(500),
    vendor_uri character varying(1500),
    enabled_p boolean DEFAULT false NOT NULL,
    installed_p boolean DEFAULT false NOT NULL,
    tagged_p boolean DEFAULT false NOT NULL,
    imported_p boolean DEFAULT false NOT NULL,
    data_model_loaded_p boolean DEFAULT false NOT NULL,
    cvs_import_results text,
    activation_date timestamp with time zone,
    deactivation_date timestamp with time zone,
    item_id integer,
    content_length integer,
    distribution_uri character varying(1500),
    distribution_date timestamp with time zone,
    auto_mount character varying(50) DEFAULT NULL::character varying,
    CONSTRAINT apm_package_vers_desc_for_ck CHECK (((description_format)::text = ANY (ARRAY[('text/html'::character varying)::text, ('text/plain'::character varying)::text])))
);


ALTER TABLE public.apm_package_versions OWNER TO evex;

--
-- Name: TABLE apm_package_versions; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_package_versions IS '
 The table apm_package_versions contains one row for each version of each package
 we know about, e.g., acs-kernel-3.3, acs-kernel-3.3.1, bboard-1.0,
 bboard-1.0.1, etc.
';


--
-- Name: COLUMN apm_package_versions.version_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.version_name IS '
A version number consists of: 
   1.A major version number. 
   2.Optionally, up to three minor version numbers. 
   3.One of the following: 
         The letter d, indicating a development-only version.
         The letter a, indicating an alpha release.
         The letter b, indicating a beta release. 
         No letter at all, indicating a final release.
In addition, the letters d, a, and b may be followed by another integer, indicating a version within the release. 
For those who like regular expressions: 
     version_number := integer (''.'' integer){0,3} ((''d''|''a''|''b'') integer?)?
So the following is a valid progression for version numbers: 
     0.9d, 0.9d1, 0.9a1, 0.9b1, 0.9b2, 0.9, 1.0, 1.0.1, 1.1b1, 1.1
';


--
-- Name: COLUMN apm_package_versions.version_uri; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.version_uri IS '
  This column should uniquely identify a package version.  This URI should in practice be a URL at which this specific
version can be downloaded.  
';


--
-- Name: COLUMN apm_package_versions.summary; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.summary IS '
Type a brief, one-sentence-or-less summary of the functionality of 
your package.  The summary should begin with a capital letter 
and end with a period. 
XXX (bquinn): Move to Content Repository?
';


--
-- Name: COLUMN apm_package_versions.description_format; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.description_format IS '
 Must indicate whether the description is plain text or HTML.
';


--
-- Name: COLUMN apm_package_versions.description; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.description IS '
Type a one-paragraph description of your package. This is probably analogous 
to the first paragraph in your package''s documentation.  This is used to describe
the system to users considering installing it.
';


--
-- Name: COLUMN apm_package_versions.release_date; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.release_date IS '
This tracks when the package was released. Releasing a package means
freezing the code and files, creating an archive, and making the
package available for donwload. XXX (bquinn): I''m skeptical about the
usefulness of storing this information here.
';


--
-- Name: COLUMN apm_package_versions.vendor; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.vendor IS '
If the package is being released by a company or some kind of organization, 
its name should go here.
';


--
-- Name: COLUMN apm_package_versions.vendor_uri; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.vendor_uri IS '
This should be a URL pointing to the vendor.
';


--
-- Name: COLUMN apm_package_versions.enabled_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.enabled_p IS '
 Is the version scheduled to be loaded at startup?
';


--
-- Name: COLUMN apm_package_versions.installed_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.installed_p IS '
 Is the version actually present in the filesystem?
';


--
-- Name: COLUMN apm_package_versions.tagged_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.tagged_p IS '
 Have we ever assigned all the files in this version a CVS tag.
 XXX (bquinn): deprecated.  CVS management should not be through
 this table.
';


--
-- Name: COLUMN apm_package_versions.imported_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.imported_p IS '
 Did we perform a vendor import on this version?
 XXX (bquinn): deprecated.  CVS management should not be through
 this table.
';


--
-- Name: COLUMN apm_package_versions.data_model_loaded_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.data_model_loaded_p IS '
 Have we brought the data model up to date for this version.
 XXX (bquinn): deprecated.  Its not useful to track this information.
';


--
-- Name: COLUMN apm_package_versions.cvs_import_results; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.cvs_import_results IS '
 Store the results of an attempted CVS import.
 XXX (bquinn): deprecated.  CVS management should not be through
 this table.
';


--
-- Name: COLUMN apm_package_versions.activation_date; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.activation_date IS '
 When was the version last enabled?
 XXX (bquinn): do we really care about this enough to keep the information around?
';


--
-- Name: COLUMN apm_package_versions.deactivation_date; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.deactivation_date IS '
 When was the version last disabled?
 XXX (bquinn): do we really care about this enough to keep the information around?
';


--
-- Name: COLUMN apm_package_versions.item_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.item_id IS '
 item_id is a reference to the distribution_tarball which is stored in the content
 repository.
';


--
-- Name: COLUMN apm_package_versions.distribution_uri; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.distribution_uri IS '
 Where was the distribution tarball downloaded from.
';


--
-- Name: COLUMN apm_package_versions.distribution_date; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.distribution_date IS '
 When was the distribution tarball downloaded.
';


--
-- Name: COLUMN apm_package_versions.auto_mount; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_versions.auto_mount IS '
 A dir under the main site site node where an instance of the package will be mounted
 automatically upon installation. Useful for site-wide services that need mounting
 such as general-comments and notifications.
';


--
-- Name: apm_package_version_info; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.apm_package_version_info AS
 SELECT v.package_key,
    t.package_uri,
    t.pretty_name,
    t.singleton_p,
    t.initial_install_p,
    t.inherit_templates_p,
    t.implements_subsite_p,
    v.version_id,
    v.version_name,
    v.version_uri,
    v.summary,
    v.description_format,
    v.description,
    v.release_date,
    v.vendor,
    v.vendor_uri,
    v.auto_mount,
    v.enabled_p,
    v.installed_p,
    v.tagged_p,
    v.imported_p,
    v.data_model_loaded_p,
    v.activation_date,
    v.deactivation_date,
    COALESCE(v.content_length, 0) AS tarball_length,
    v.distribution_uri,
    v.distribution_date
   FROM public.apm_package_types t,
    public.apm_package_versions v
  WHERE ((v.package_key)::text = (t.package_key)::text);


ALTER TABLE public.apm_package_version_info OWNER TO evex;

--
-- Name: apm_enabled_package_versions; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.apm_enabled_package_versions AS
 SELECT apm_package_version_info.package_key,
    apm_package_version_info.package_uri,
    apm_package_version_info.pretty_name,
    apm_package_version_info.singleton_p,
    apm_package_version_info.initial_install_p,
    apm_package_version_info.inherit_templates_p,
    apm_package_version_info.implements_subsite_p,
    apm_package_version_info.version_id,
    apm_package_version_info.version_name,
    apm_package_version_info.version_uri,
    apm_package_version_info.summary,
    apm_package_version_info.description_format,
    apm_package_version_info.description,
    apm_package_version_info.release_date,
    apm_package_version_info.vendor,
    apm_package_version_info.vendor_uri,
    apm_package_version_info.auto_mount,
    apm_package_version_info.enabled_p,
    apm_package_version_info.installed_p,
    apm_package_version_info.tagged_p,
    apm_package_version_info.imported_p,
    apm_package_version_info.data_model_loaded_p,
    apm_package_version_info.activation_date,
    apm_package_version_info.deactivation_date,
    apm_package_version_info.tarball_length,
    apm_package_version_info.distribution_uri,
    apm_package_version_info.distribution_date
   FROM public.apm_package_version_info
  WHERE (apm_package_version_info.enabled_p = true);


ALTER TABLE public.apm_enabled_package_versions OWNER TO evex;

--
-- Name: apm_package_callbacks; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_package_callbacks (
    version_id integer,
    type character varying(40),
    proc character varying(300)
);


ALTER TABLE public.apm_package_callbacks OWNER TO evex;

--
-- Name: TABLE apm_package_callbacks; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_package_callbacks IS '
  This table holds names of Tcl procedures to invoke at the time (before or after) the package is
  installed, instantiated, or mounted.        
';


--
-- Name: COLUMN apm_package_callbacks.type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_callbacks.type IS '
  Indicates when the callback proc should be invoked, for example after-install. Valid
  values are given by the Tcl proc apm_supported_callback_types.
';


--
-- Name: COLUMN apm_package_callbacks.proc; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_callbacks.proc IS '
  Name of the Tcl proc.
';


--
-- Name: apm_package_db_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_package_db_types (
    db_type_key character varying(50) NOT NULL,
    pretty_db_name character varying(200) NOT NULL
);


ALTER TABLE public.apm_package_db_types OWNER TO evex;

--
-- Name: TABLE apm_package_db_types; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_package_db_types IS '
  A list of all the different kinds of database engines that an APM package can
  support.  This table is initialized in acs-tcl/tcl/apm-init.tcl rather than in
  PL/SQL in order to guarantee that the list of supported database engines is
  consistent between the bootstrap code and the package manager.
';


--
-- Name: apm_package_dependencies; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_package_dependencies (
    dependency_id integer NOT NULL,
    version_id integer NOT NULL,
    dependency_type character varying(20) NOT NULL,
    service_uri character varying(1500) NOT NULL,
    service_version character varying(100) NOT NULL,
    CONSTRAINT apm_package_deps_type_ck CHECK (((dependency_type)::text = ANY (ARRAY[('embeds'::character varying)::text, ('extends'::character varying)::text, ('provides'::character varying)::text, ('requires'::character varying)::text])))
);


ALTER TABLE public.apm_package_dependencies OWNER TO evex;

--
-- Name: TABLE apm_package_dependencies; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_package_dependencies IS '
 This table indicates what services are provided or required by a particular version.
';


--
-- Name: COLUMN apm_package_dependencies.service_version; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_package_dependencies.service_version IS '
 The restrictions on service version should match those on apm_package_versions.version_name.
';


--
-- Name: apm_package_owners; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_package_owners (
    version_id integer,
    owner_uri character varying(1500),
    owner_name character varying(200) NOT NULL,
    sort_key integer
);


ALTER TABLE public.apm_package_owners OWNER TO evex;

--
-- Name: TABLE apm_package_owners; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_package_owners IS '
 This table tracks all of the owners of a particular package, and their email information.  The sort_key column
 manages the order of the authors.
';


--
-- Name: apm_package_version_attr; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_package_version_attr (
    version_id integer NOT NULL,
    attribute_name character varying(100) NOT NULL,
    attribute_value character varying(4000)
);


ALTER TABLE public.apm_package_version_attr OWNER TO evex;

--
-- Name: apm_packages; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_packages (
    package_id integer NOT NULL,
    package_key character varying(100),
    instance_name character varying(300) NOT NULL,
    default_locale character varying(30)
);


ALTER TABLE public.apm_packages OWNER TO evex;

--
-- Name: TABLE apm_packages; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_packages IS '
   This table maintains the list of all package instances in the sytem. 
';


--
-- Name: COLUMN apm_packages.instance_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_packages.instance_name IS '
   This column enables a name to associated with each instance of package.  This enables the storage
of a human-readable distinction between different package instances.  This is useful
if a site admin wishes to name an instance of an application, e.g. bboard, for a subsite.  The admin
might create one instance, "Boston Public Bboard" for managing public forums for the Boston subsite,
and "Boston Private Bboard" for managing private forums for the Boston subsite.
';


--
-- Name: apm_parameter_values; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_parameter_values (
    value_id integer NOT NULL,
    package_id integer,
    parameter_id integer,
    attr_value text
);


ALTER TABLE public.apm_parameter_values OWNER TO evex;

--
-- Name: TABLE apm_parameter_values; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_parameter_values IS '
 This table holds the values of parameters for package instances.
';


--
-- Name: COLUMN apm_parameter_values.attr_value; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_parameter_values.attr_value IS '
 This column holds the value for the instance parameter.
';


--
-- Name: apm_parameters; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_parameters (
    parameter_id integer NOT NULL,
    package_key character varying(100) NOT NULL,
    parameter_name character varying(100) NOT NULL,
    description character varying(2000),
    section_name character varying(200),
    datatype character varying(100) NOT NULL,
    scope character varying(10) DEFAULT 'instance'::character varying NOT NULL,
    default_value text,
    min_n_values integer DEFAULT 1 NOT NULL,
    max_n_values integer DEFAULT 1 NOT NULL,
    CONSTRAINT apm_parameters_datatype_ck CHECK (((datatype)::text = ANY (ARRAY[('number'::character varying)::text, ('string'::character varying)::text, ('text'::character varying)::text]))),
    CONSTRAINT apm_parameters_max_n_values_ck CHECK ((max_n_values >= 0)),
    CONSTRAINT apm_parameters_min_n_values_ck CHECK ((min_n_values >= 0)),
    CONSTRAINT apm_parameters_scope_ck CHECK (((scope)::text = ANY (ARRAY[('global'::character varying)::text, ('instance'::character varying)::text]))),
    CONSTRAINT apm_paramters_n_values_ck CHECK ((min_n_values <= max_n_values))
);


ALTER TABLE public.apm_parameters OWNER TO evex;

--
-- Name: TABLE apm_parameters; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_parameters IS '
  This table stores information about parameters on packages.  Every package parameter
is specific to a particular package instance and is queryable with the Tcl call 
parameter::get.
';


--
-- Name: COLUMN apm_parameters.parameter_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_parameters.parameter_name IS '
  This is the name of the parameter, for example "DebugP."
';


--
-- Name: COLUMN apm_parameters.description; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_parameters.description IS '
  A human readable description of what the parameter is used for.
';


--
-- Name: COLUMN apm_parameters.datatype; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_parameters.datatype IS '
 Acceptable datatypes for parameters.  Currently only numbers and strings.
 XXX (bquinn): Integrate with acs objects metadata system.  It is not 
 currently so integrated because of fluctuations with the general 
 storage mechanism during development.
';


--
-- Name: COLUMN apm_parameters.scope; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_parameters.scope IS '
  If the scope is "global", only one value of the parameter exists for the entire site.
  If "instance", each package instance has its own value.
';


--
-- Name: COLUMN apm_parameters.default_value; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_parameters.default_value IS '
  The default value that any package instance will inherit unless otherwise
  specified. 
';


--
-- Name: COLUMN apm_parameters.min_n_values; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_parameters.min_n_values IS '
  The minimum number of values that this parameter can take.  Zero values means
  that the default is always enforced (but is somewhat pointless).  One value means that
  it can only be set to one value.  Increasing this number beyond one enables associating 
  a list of values with a parameter.  
  XXX (bquinn): More than one value is not supported by parameter::get call at this time.
';


--
-- Name: COLUMN apm_parameters.max_n_values; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.apm_parameters.max_n_values IS '
The maximum number of values that any attribute with this datatype
 can have. 
';


--
-- Name: apm_services; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.apm_services (
    service_id integer NOT NULL
);


ALTER TABLE public.apm_services OWNER TO evex;

--
-- Name: TABLE apm_services; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.apm_services IS '
This table records data on all of the services registered in OpenACS. 
';


--
-- Name: application_groups; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.application_groups (
    group_id integer NOT NULL,
    package_id integer
);


ALTER TABLE public.application_groups OWNER TO evex;

--
-- Name: group_element_index; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.group_element_index (
    group_id integer NOT NULL,
    element_id integer NOT NULL,
    rel_id integer NOT NULL,
    container_id integer NOT NULL,
    rel_type character varying(1000) NOT NULL,
    ancestor_rel_type character varying(100) NOT NULL,
    CONSTRAINT group_element_index_ant_rt_ck CHECK (((ancestor_rel_type)::text = ANY (ARRAY[('composition_rel'::character varying)::text, ('membership_rel'::character varying)::text])))
);


ALTER TABLE public.group_element_index OWNER TO evex;

--
-- Name: TABLE group_element_index; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.group_element_index IS '
 This table is for internal use by the parties system.  It as an auxiliary
 table, a denormalization of data, that is used to improve performance.
 Do not query on this table or insert into it.  Query on group_element_map
 instead.  And insert by using the API''s for membership_rel, composition_rel, 
 or some sub-type of those relationship types.
';


--
-- Name: group_element_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.group_element_map AS
 SELECT group_element_index.group_id,
    group_element_index.element_id,
    group_element_index.rel_id,
    group_element_index.container_id,
    group_element_index.rel_type,
    group_element_index.ancestor_rel_type
   FROM public.group_element_index;


ALTER TABLE public.group_element_map OWNER TO evex;

--
-- Name: application_group_element_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.application_group_element_map AS
 SELECT g.package_id,
    g.group_id,
    m.element_id,
    m.container_id,
    m.rel_id,
    m.rel_type,
    m.ancestor_rel_type
   FROM public.application_groups g,
    public.group_element_map m
  WHERE (g.group_id = m.group_id);


ALTER TABLE public.application_group_element_map OWNER TO evex;

--
-- Name: app_group_distinct_element_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.app_group_distinct_element_map AS
 SELECT DISTINCT application_group_element_map.package_id,
    application_group_element_map.group_id,
    application_group_element_map.element_id
   FROM public.application_group_element_map;


ALTER TABLE public.app_group_distinct_element_map OWNER TO evex;

--
-- Name: app_group_distinct_rel_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.app_group_distinct_rel_map AS
 SELECT DISTINCT application_group_element_map.package_id,
    application_group_element_map.group_id,
    application_group_element_map.rel_id,
    application_group_element_map.rel_type,
    application_group_element_map.ancestor_rel_type
   FROM public.application_group_element_map;


ALTER TABLE public.app_group_distinct_rel_map OWNER TO evex;

--
-- Name: rel_segments; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.rel_segments (
    segment_id integer NOT NULL,
    segment_name character varying(230) NOT NULL,
    group_id integer NOT NULL,
    rel_type character varying(100) NOT NULL
);


ALTER TABLE public.rel_segments OWNER TO evex;

--
-- Name: TABLE rel_segments; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.rel_segments IS '
  Defines relational segments. Each relational segment is a pair of
  <code>group_id</code> / <code>rel_type</code>, or, in english, the
  parties that have a relation of type rel_type to group_id.
';


--
-- Name: COLUMN rel_segments.segment_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rel_segments.segment_name IS '
  The user-entered name of the relational segment.
';


--
-- Name: COLUMN rel_segments.group_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rel_segments.group_id IS '
  The group for which this segment was created.
';


--
-- Name: COLUMN rel_segments.rel_type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rel_segments.rel_type IS '
  The relationship type used to define elements in this segment.
';


--
-- Name: application_group_segments; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.application_group_segments AS
 SELECT g.package_id,
    s.segment_id,
    s.group_id,
    s.rel_type,
    s.segment_name
   FROM public.application_groups g,
    public.group_element_map m,
    public.rel_segments s
  WHERE ((g.group_id = m.group_id) AND (m.element_id = s.group_id))
UNION ALL
 SELECT g.package_id,
    s.segment_id,
    s.group_id,
    s.rel_type,
    s.segment_name
   FROM public.application_groups g,
    public.rel_segments s
  WHERE (g.group_id = s.group_id);


ALTER TABLE public.application_group_segments OWNER TO evex;

--
-- Name: attachments; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.attachments (
    object_id integer NOT NULL,
    item_id integer NOT NULL,
    approved_p character(1) DEFAULT 't'::bpchar NOT NULL,
    CONSTRAINT attachments_approved_p_ck CHECK ((approved_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.attachments OWNER TO evex;

--
-- Name: attachments_fs_root_folder_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.attachments_fs_root_folder_map (
    package_id integer NOT NULL,
    folder_id integer NOT NULL
);


ALTER TABLE public.attachments_fs_root_folder_map OWNER TO evex;

--
-- Name: auth_authorities; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.auth_authorities (
    authority_id integer NOT NULL,
    short_name character varying(255),
    pretty_name character varying(4000),
    help_contact_text character varying(4000),
    help_contact_text_format character varying(200),
    enabled_p boolean DEFAULT true NOT NULL,
    sort_order integer NOT NULL,
    auth_impl_id integer,
    pwd_impl_id integer,
    forgotten_pwd_url character varying(4000),
    change_pwd_url character varying(4000),
    register_impl_id integer,
    register_url character varying(4000),
    user_info_impl_id integer,
    get_doc_impl_id integer,
    process_doc_impl_id integer,
    batch_sync_enabled_p boolean DEFAULT false NOT NULL,
    allow_user_entered_info_p boolean DEFAULT false NOT NULL,
    search_impl_id integer
);


ALTER TABLE public.auth_authorities OWNER TO evex;

--
-- Name: COLUMN auth_authorities.help_contact_text; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.auth_authorities.help_contact_text IS '
    Contact information (phone, email, etc.) to be displayed
    as a last resort when people are having problems with an authority.
';


--
-- Name: COLUMN auth_authorities.forgotten_pwd_url; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.auth_authorities.forgotten_pwd_url IS '
    Any username in this url must be on the syntax foo={username}
    and {username} will be replaced with the real username
';


--
-- Name: COLUMN auth_authorities.change_pwd_url; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.auth_authorities.change_pwd_url IS '
    Any username in this url must be on the syntax foo={username}
    and {username} will be replaced with the real username
';


--
-- Name: auth_batch_job_entries; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.auth_batch_job_entries (
    entry_id integer NOT NULL,
    job_id integer,
    entry_time timestamp with time zone DEFAULT now(),
    operation character varying(100),
    username character varying(100),
    user_id integer,
    success_p boolean NOT NULL,
    message text,
    element_messages text,
    CONSTRAINT auth_batch_jobs_entries_op_ck CHECK (((operation)::text = ANY (ARRAY[('insert'::character varying)::text, ('update'::character varying)::text, ('delete'::character varying)::text])))
);


ALTER TABLE public.auth_batch_job_entries OWNER TO evex;

--
-- Name: auth_batch_job_entry_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.auth_batch_job_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.auth_batch_job_entry_id_seq OWNER TO evex;

--
-- Name: auth_batch_jobs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.auth_batch_jobs (
    job_id integer NOT NULL,
    job_start_time timestamp with time zone DEFAULT now(),
    job_end_time timestamp with time zone,
    interactive_p boolean NOT NULL,
    snapshot_p boolean,
    authority_id integer,
    message text,
    creation_user integer,
    doc_start_time timestamp with time zone,
    doc_end_time timestamp with time zone,
    doc_status text,
    doc_message text,
    document text
);


ALTER TABLE public.auth_batch_jobs OWNER TO evex;

--
-- Name: auth_batch_jobs_job_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.auth_batch_jobs_job_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.auth_batch_jobs_job_id_seq OWNER TO evex;

--
-- Name: auth_driver_params; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.auth_driver_params (
    authority_id integer NOT NULL,
    impl_id integer NOT NULL,
    key character varying(200) NOT NULL,
    value text
);


ALTER TABLE public.auth_driver_params OWNER TO evex;

SET default_with_oids = true;

--
-- Name: banners; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.banners (
    banner_id integer NOT NULL,
    name character varying,
    url character varying,
    sort_order integer
);


ALTER TABLE public.banners OWNER TO evex;

--
-- Name: cal_item_type_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.cal_item_type_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cal_item_type_seq OWNER TO evex;

SET default_with_oids = false;

--
-- Name: cal_item_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cal_item_types (
    item_type_id integer NOT NULL,
    calendar_id integer NOT NULL,
    type character varying(100) NOT NULL
);


ALTER TABLE public.cal_item_types OWNER TO evex;

--
-- Name: cal_items; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cal_items (
    cal_item_id integer NOT NULL,
    on_which_calendar integer,
    item_type_id integer
);


ALTER TABLE public.cal_items OWNER TO evex;

--
-- Name: TABLE cal_items; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cal_items IS '
        Table cal_items maps the ownership relation between 
        an cal_item_id to calendars. Each cal_item is owned
        by a calendar
';


--
-- Name: COLUMN cal_items.cal_item_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cal_items.cal_item_id IS '
        Primary Key
';


--
-- Name: COLUMN cal_items.on_which_calendar; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cal_items.on_which_calendar IS '
        Mapping to calendar. Each cal_item is owned
        by a calendar
';


--
-- Name: cal_party_prefs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cal_party_prefs (
    calendar_id integer,
    party_id integer,
    default_view character varying(10) DEFAULT 'day'::character varying,
    default_duration integer DEFAULT 60,
    daily_start numeric(2,0) DEFAULT 7,
    daily_end numeric(2,0) DEFAULT 18,
    time_zone integer,
    first_day_of_week character varying(9) DEFAULT 'Sunday'::character varying,
    CONSTRAINT cal_party_prefs_time_zone_check CHECK ((time_zone > 0)),
    CONSTRAINT cal_pty_prefs_1st_day_ck CHECK (((first_day_of_week)::text = ANY (ARRAY[('Sunday'::character varying)::text, ('Monday'::character varying)::text, ('Tuesday'::character varying)::text, ('Wednesday'::character varying)::text, ('Thursday'::character varying)::text, ('Friday'::character varying)::text, ('Saturday'::character varying)::text]))),
    CONSTRAINT cal_pty_prefs_daily_end CHECK (((daily_end < (24)::numeric) AND (daily_end > (0)::numeric))),
    CONSTRAINT cal_pty_prefs_daily_start CHECK (((daily_start < (24)::numeric) AND (daily_start > ('-1'::integer)::numeric))),
    CONSTRAINT cal_pty_prefs_default_duration CHECK ((default_duration > 0)),
    CONSTRAINT cal_pty_prefs_default_view_ck CHECK (((default_view)::text = ANY (ARRAY[('list'::character varying)::text, ('day'::character varying)::text, ('week'::character varying)::text, ('month'::character varying)::text, ('year'::character varying)::text])))
);


ALTER TABLE public.cal_party_prefs OWNER TO evex;

--
-- Name: TABLE cal_party_prefs; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cal_party_prefs IS '
        Table cal_user_prefs would stores custom information
        about each indivdual user. This would include time zone
        which is the first day of the week, monday or sunday, 
        and the likes. 
';


--
-- Name: COLUMN cal_party_prefs.party_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cal_party_prefs.party_id IS '
        Maps to a party
';


--
-- Name: COLUMN cal_party_prefs.default_view; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cal_party_prefs.default_view IS '
        default_view stores whether the user wants
        list, month, day, week, or year as his/her default view. 
';


--
-- Name: COLUMN cal_party_prefs.default_duration; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cal_party_prefs.default_duration IS '
        the default number of minutes for each appointment
';


--
-- Name: COLUMN cal_party_prefs.daily_start; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cal_party_prefs.daily_start IS '
        the default start time in daily view in military time 00 - 23
        default to 07 or 7 am
';


--
-- Name: COLUMN cal_party_prefs.daily_end; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cal_party_prefs.daily_end IS '
        the default end time in daily view in military time 00 - 23
        default to 18 or 6 pm
';


--
-- Name: COLUMN cal_party_prefs.first_day_of_week; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cal_party_prefs.first_day_of_week IS '
        Which day of the week will be displayed first in month and week view    
';


--
-- Name: calendars; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.calendars (
    calendar_id integer NOT NULL,
    calendar_name character varying(200),
    owner_id integer,
    package_id integer,
    private_p boolean DEFAULT false,
    CONSTRAINT calendars_private_p_ck CHECK ((private_p = ANY (ARRAY[true, false])))
);


ALTER TABLE public.calendars OWNER TO evex;

--
-- Name: TABLE calendars; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.calendars IS '
        Table calendars maps the many to many relationship betweens
        calendar and its owners. 
';


--
-- Name: COLUMN calendars.calendar_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.calendars.calendar_id IS '
        Primary Key
';


--
-- Name: COLUMN calendars.calendar_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.calendars.calendar_name IS '
        the name of the calendar. This would be unique to avoid confusion
';


--
-- Name: COLUMN calendars.owner_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.calendars.owner_id IS '
        the individual or party that owns the calendar
';


--
-- Name: COLUMN calendars.package_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.calendars.package_id IS '
        keep track of package instances
';


--
-- Name: categories; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.categories (
    category_id integer NOT NULL,
    tree_id integer,
    parent_id integer,
    deprecated_p boolean DEFAULT false,
    left_ind integer,
    right_ind integer
);


ALTER TABLE public.categories OWNER TO evex;

--
-- Name: TABLE categories; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.categories IS '
  Information about the categories in the tree structure.
';


--
-- Name: COLUMN categories.category_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.categories.category_id IS '
  ID of a category.
';


--
-- Name: COLUMN categories.tree_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.categories.tree_id IS '
  ID of a tree (see category_trees).
';


--
-- Name: COLUMN categories.parent_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.categories.parent_id IS '
  Points to a parent category in the tree or null (if topmost category).
';


--
-- Name: COLUMN categories.deprecated_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.categories.deprecated_p IS '
  Marks categories to be no longer supported.
';


--
-- Name: COLUMN categories.left_ind; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.categories.left_ind IS '
  Left index in nested set structure of a tree.
';


--
-- Name: COLUMN categories.right_ind; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.categories.right_ind IS '
  Right index in nested set structure of a tree.
';


--
-- Name: category_links; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_links (
    link_id integer NOT NULL,
    from_category_id integer NOT NULL,
    to_category_id integer NOT NULL
);


ALTER TABLE public.category_links OWNER TO evex;

--
-- Name: TABLE category_links; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_links IS '
  Stores directed graph of linked categories. If category A
  and category B are linked, then any categorization on A
  will result in an additional categorization in B.
';


--
-- Name: COLUMN category_links.link_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_links.link_id IS '
  Primary key.
';


--
-- Name: COLUMN category_links.from_category_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_links.from_category_id IS '
  Category the link is coming from. Any categorization in this
  category will trigger a categorization in the other category.
';


--
-- Name: COLUMN category_links.to_category_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_links.to_category_id IS '
  Category the link is coming to. Any categorization in the other
  category will trigger a categorization in this category.
';


--
-- Name: category_links_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.category_links_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.category_links_id_seq OWNER TO evex;

--
-- Name: category_object_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_object_map (
    category_id integer NOT NULL,
    object_id integer NOT NULL
);


ALTER TABLE public.category_object_map OWNER TO evex;

--
-- Name: TABLE category_object_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_object_map IS '
  Maps categories to objects and thus categorizes and object.
';


--
-- Name: COLUMN category_object_map.category_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_object_map.category_id IS '
  ID of the mapped category (see categories).
';


--
-- Name: COLUMN category_object_map.object_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_object_map.object_id IS '
  ID of the mapped object.
';


--
-- Name: category_object_map_tree; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.category_object_map_tree AS
 SELECT c.category_id,
    c.tree_id,
    m.object_id
   FROM public.category_object_map m,
    public.categories c
  WHERE (c.category_id = m.category_id);


ALTER TABLE public.category_object_map_tree OWNER TO evex;

--
-- Name: category_search; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_search (
    query_id integer NOT NULL,
    search_text character varying(200) NOT NULL,
    locale character varying(5) NOT NULL,
    queried_count integer DEFAULT 1 NOT NULL,
    last_queried timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.category_search OWNER TO evex;

--
-- Name: TABLE category_search; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_search IS '
  Stores users multilingual search texts for category synonyms.
';


--
-- Name: COLUMN category_search.query_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search.query_id IS '
  Primary key.
';


--
-- Name: COLUMN category_search.search_text; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search.search_text IS '
  Actual search text in given language.
';


--
-- Name: COLUMN category_search.locale; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search.locale IS '
  Language of the search text.
';


--
-- Name: COLUMN category_search.queried_count; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search.queried_count IS '
  Counts how often this search text has been used by users.
';


--
-- Name: COLUMN category_search.last_queried; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search.last_queried IS '
  Date of last usage of this search text.
  A sweeper will delete search texts not used for a while.
';


--
-- Name: category_search_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.category_search_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.category_search_id_seq OWNER TO evex;

--
-- Name: category_search_index; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_search_index (
    query_id integer NOT NULL,
    trigram character(3) NOT NULL
);


ALTER TABLE public.category_search_index OWNER TO evex;

--
-- Name: TABLE category_search_index; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_search_index IS '
  Stores the search text cut down in portions of 3 characters
  to be used in search.
';


--
-- Name: COLUMN category_search_index.query_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search_index.query_id IS '
  Id of the search text refered to.
';


--
-- Name: COLUMN category_search_index.trigram; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search_index.trigram IS '
  3 character part of the search text.
';


--
-- Name: category_search_results; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_search_results (
    query_id integer NOT NULL,
    synonym_id integer NOT NULL,
    similarity integer NOT NULL
);


ALTER TABLE public.category_search_results OWNER TO evex;

--
-- Name: TABLE category_search_results; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_search_results IS '
  Stores the result of a users search in synonyms,
  stores matching synonyms and their degree of similarity
  to the search text.
';


--
-- Name: COLUMN category_search_results.query_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search_results.query_id IS '
  Id of the search text.
';


--
-- Name: COLUMN category_search_results.synonym_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search_results.synonym_id IS '
  Id of the synonym found.
';


--
-- Name: COLUMN category_search_results.similarity; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_search_results.similarity IS '
  Percent of similarity between search text and found synonym.
';


--
-- Name: category_synonym_index; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_synonym_index (
    synonym_id integer NOT NULL,
    trigram character(3) NOT NULL
);


ALTER TABLE public.category_synonym_index OWNER TO evex;

--
-- Name: TABLE category_synonym_index; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_synonym_index IS '
  Stores the synonym cut down in portions of 3 characters
  to be used in search.
';


--
-- Name: COLUMN category_synonym_index.synonym_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_synonym_index.synonym_id IS '
  Id of the synonym refered to.
';


--
-- Name: COLUMN category_synonym_index.trigram; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_synonym_index.trigram IS '
  3 character part of the synonym.
';


--
-- Name: category_synonyms; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_synonyms (
    synonym_id integer NOT NULL,
    category_id integer NOT NULL,
    locale character varying(5) NOT NULL,
    name character varying(100) NOT NULL,
    synonym_p boolean DEFAULT true
);


ALTER TABLE public.category_synonyms OWNER TO evex;

--
-- Name: TABLE category_synonyms; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_synonyms IS '
  Stores multilingual synonyms of the categories.
';


--
-- Name: COLUMN category_synonyms.synonym_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_synonyms.synonym_id IS '
  Primary key.
';


--
-- Name: COLUMN category_synonyms.category_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_synonyms.category_id IS '
  Category the synonyms are refering to.
';


--
-- Name: COLUMN category_synonyms.locale; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_synonyms.locale IS '
  Language of the synonym.
';


--
-- Name: COLUMN category_synonyms.name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_synonyms.name IS '
  Actual synonym of the category in given language.
';


--
-- Name: COLUMN category_synonyms.synonym_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_synonyms.synonym_p IS '
  Marks if the entry is a synonym to be edited by user or is a copy
  of a category translation and cannot be edited directly.
';


--
-- Name: category_synonyms_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.category_synonyms_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.category_synonyms_id_seq OWNER TO evex;

--
-- Name: category_temp; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_temp (
    category_id integer
);


ALTER TABLE public.category_temp OWNER TO evex;

--
-- Name: TABLE category_temp; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_temp IS '
  Used mainly for multi-dimensional browsing to use only bind vars
  in queries
';


--
-- Name: category_translations; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_translations (
    category_id integer NOT NULL,
    locale character varying(5) NOT NULL,
    name character varying(200),
    description character varying(4000)
);


ALTER TABLE public.category_translations OWNER TO evex;

--
-- Name: TABLE category_translations; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_translations IS '
  Translations for names and descriptions of categories in different languages.
';


--
-- Name: COLUMN category_translations.category_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_translations.category_id IS '
  ID of a category (see categories).
';


--
-- Name: COLUMN category_translations.locale; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_translations.locale IS '
  ACS-Lang style locale if language ad country.
';


--
-- Name: COLUMN category_translations.name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_translations.name IS '
  Name of the category in the specified language.
';


--
-- Name: COLUMN category_translations.description; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_translations.description IS '
  Description of the category in the specified language.
';


--
-- Name: category_tree_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_tree_map (
    tree_id integer NOT NULL,
    object_id integer NOT NULL,
    subtree_category_id integer,
    assign_single_p boolean DEFAULT false,
    require_category_p boolean DEFAULT false,
    widget character varying(20)
);


ALTER TABLE public.category_tree_map OWNER TO evex;

--
-- Name: TABLE category_tree_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_tree_map IS '
  Maps trees to objects (usually package instances) so that
  other objects can be categorized.
';


--
-- Name: COLUMN category_tree_map.tree_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_map.tree_id IS '
  ID of the mapped tree (see category_trees).
';


--
-- Name: COLUMN category_tree_map.object_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_map.object_id IS '
  ID of the mapped object (usually an apm_package if trees are to be used
  in a whole package instance, i.e. file-storage).
';


--
-- Name: COLUMN category_tree_map.subtree_category_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_map.subtree_category_id IS '
  If a subtree is mapped, then this is the ID of the category on top
  of the subtree, null otherwise.
';


--
-- Name: COLUMN category_tree_map.assign_single_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_map.assign_single_p IS '
  Are the users allowed to assign multiple or only a single category
  to objects?
';


--
-- Name: COLUMN category_tree_map.require_category_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_map.require_category_p IS '
  Do the users have to assign at least one category to objects?
';


--
-- Name: COLUMN category_tree_map.widget; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_map.widget IS '
  What widget do we want to use for this cateogry?
';


--
-- Name: category_tree_translations; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_tree_translations (
    tree_id integer NOT NULL,
    locale character varying(5) NOT NULL,
    name character varying(50) NOT NULL,
    description character varying(1000)
);


ALTER TABLE public.category_tree_translations OWNER TO evex;

--
-- Name: TABLE category_tree_translations; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_tree_translations IS '
  Translations for names and descriptions of trees in different languages.
';


--
-- Name: COLUMN category_tree_translations.tree_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_translations.tree_id IS '
  ID of a tree (see category_trees).
';


--
-- Name: COLUMN category_tree_translations.locale; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_translations.locale IS '
  ACS-Lang style locale if language ad country.
';


--
-- Name: COLUMN category_tree_translations.name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_translations.name IS '
  Name of the tree in the specified language.
';


--
-- Name: COLUMN category_tree_translations.description; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_tree_translations.description IS '
  Description of the tree in the specified language.
';


--
-- Name: category_trees; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.category_trees (
    tree_id integer NOT NULL,
    site_wide_p boolean DEFAULT true
);


ALTER TABLE public.category_trees OWNER TO evex;

--
-- Name: TABLE category_trees; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.category_trees IS '
  This is general data for each category tree.
';


--
-- Name: COLUMN category_trees.tree_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_trees.tree_id IS '
  ID of a tree.
';


--
-- Name: COLUMN category_trees.site_wide_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.category_trees.site_wide_p IS '
  Declares if a tree is site-wide or local (only usable by users/groups
  that have permissions).
';


--
-- Name: group_member_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.group_member_map AS
 SELECT group_element_map.group_id,
    group_element_map.element_id AS member_id,
    group_element_map.rel_id,
    group_element_map.container_id,
    group_element_map.rel_type
   FROM public.group_element_map
  WHERE ((group_element_map.ancestor_rel_type)::text = 'membership_rel'::text);


ALTER TABLE public.group_member_map OWNER TO evex;

--
-- Name: membership_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.membership_rels (
    rel_id integer NOT NULL,
    member_state character varying(20),
    CONSTRAINT membership_rels_member_state_ck CHECK (((member_state)::text = ANY (ARRAY[('merged'::character varying)::text, ('approved'::character varying)::text, ('needs approval'::character varying)::text, ('banned'::character varying)::text, ('rejected'::character varying)::text, ('deleted'::character varying)::text])))
);


ALTER TABLE public.membership_rels OWNER TO evex;

--
-- Name: cc_users; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.cc_users AS
 SELECT o.object_id,
    o.object_type,
    o.title,
    o.package_id,
    o.context_id,
    o.security_inherit_p,
    o.creation_user,
    o.creation_date,
    o.creation_ip,
    o.last_modified,
    o.modifying_user,
    o.modifying_ip,
    pa.party_id,
    pa.email,
    pa.url,
    pe.person_id,
    pe.first_names,
    pe.last_name,
    pe.bio,
    u.user_id,
    u.authority_id,
    u.username,
    u.screen_name,
    u.priv_name,
    u.priv_email,
    u.email_verified_p,
    u.email_bouncing_p,
    u.no_alerts_until,
    u.last_visit,
    u.second_to_last_visit,
    u.n_sessions,
    u.password,
    u.salt,
    u.password_question,
    u.password_answer,
    u.password_changed_date,
    u.auth_token,
    mr.member_state,
    mr.rel_id
   FROM public.acs_objects o,
    public.parties pa,
    public.persons pe,
    public.users u,
    public.group_member_map m,
    public.membership_rels mr
  WHERE ((o.object_id = pa.party_id) AND (pa.party_id = pe.person_id) AND (pe.person_id = u.user_id) AND (u.user_id = m.member_id) AND (m.group_id = public.acs__magic_object_id('registered_users'::character varying)) AND (m.rel_id = mr.rel_id) AND (m.container_id = m.group_id) AND ((m.rel_type)::text = 'membership_rel'::text));


ALTER TABLE public.cc_users OWNER TO evex;

--
-- Name: comp_or_member_rel_types; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.comp_or_member_rel_types AS
 SELECT o.object_type AS rel_type
   FROM public.acs_object_types o,
    public.acs_object_types o1
  WHERE (((o1.object_type)::text = ANY (ARRAY[('composition_rel'::character varying)::text, ('membership_rel'::character varying)::text])) AND ((o.tree_sortkey >= o1.tree_sortkey) AND (o.tree_sortkey <= public.tree_right(o1.tree_sortkey))));


ALTER TABLE public.comp_or_member_rel_types OWNER TO evex;

--
-- Name: composition_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.composition_rels (
    rel_id integer NOT NULL
);


ALTER TABLE public.composition_rels OWNER TO evex;

--
-- Name: rel_constraints; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.rel_constraints (
    constraint_id integer NOT NULL,
    constraint_name character varying(100) NOT NULL,
    rel_segment integer NOT NULL,
    rel_side character(3) DEFAULT 'two'::bpchar NOT NULL,
    required_rel_segment integer NOT NULL,
    CONSTRAINT rel_constraints_rel_side_ck CHECK ((rel_side = ANY (ARRAY['one'::bpchar, 'two'::bpchar])))
);


ALTER TABLE public.rel_constraints OWNER TO evex;

--
-- Name: TABLE rel_constraints; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.rel_constraints IS '
  Defines relational constraints. The relational constraints system is
  intended to support applications in modelling and applying
  constraint rules on inter-party relatinships based on relational
  party segmentation.
';


--
-- Name: COLUMN rel_constraints.constraint_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rel_constraints.constraint_name IS '
  The user-defined name of this constraint.
';


--
-- Name: COLUMN rel_constraints.rel_segment; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rel_constraints.rel_segment IS '
  The segment for which the constraint is defined.
';


--
-- Name: COLUMN rel_constraints.rel_side; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rel_constraints.rel_side IS '
  The side of the relation the constraint applies to.
';


--
-- Name: COLUMN rel_constraints.required_rel_segment; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rel_constraints.required_rel_segment IS '
  The segment in which elements must be in to satisfy the constraint.
';


--
-- Name: rel_segment_party_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_segment_party_map AS
 SELECT rs.segment_id,
    gem.element_id AS party_id,
    gem.rel_id,
    gem.rel_type,
    gem.group_id,
    gem.container_id,
    gem.ancestor_rel_type
   FROM public.rel_segments rs,
    public.group_element_map gem,
    public.acs_object_types ot1,
    public.acs_object_types ot2
  WHERE ((gem.group_id = rs.group_id) AND ((ot1.object_type)::text = (gem.rel_type)::text) AND ((ot2.object_type)::text = (rs.rel_type)::text) AND ((ot1.tree_sortkey >= ot2.tree_sortkey) AND (ot1.tree_sortkey <= public.tree_right(ot2.tree_sortkey))));


ALTER TABLE public.rel_segment_party_map OWNER TO evex;

--
-- Name: constrained_rels1; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.constrained_rels1 AS
 SELECT rel.constraint_id,
    rel.constraint_name,
    r.rel_id,
    r.container_id,
    r.party_id,
    r.rel_type,
    rel.rel_segment,
    rel.rel_side,
    rel.required_rel_segment
   FROM public.rel_constraints rel,
    public.rel_segment_party_map r
  WHERE ((rel.rel_side = 'one'::bpchar) AND (rel.rel_segment = r.segment_id));


ALTER TABLE public.constrained_rels1 OWNER TO evex;

--
-- Name: constrained_rels2; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.constrained_rels2 AS
 SELECT rel.constraint_id,
    rel.constraint_name,
    r.rel_id,
    r.container_id,
    r.party_id,
    r.rel_type,
    rel.rel_segment,
    rel.rel_side,
    rel.required_rel_segment
   FROM public.rel_constraints rel,
    public.rel_segment_party_map r
  WHERE ((rel.rel_side = 'two'::bpchar) AND (rel.rel_segment = r.segment_id));


ALTER TABLE public.constrained_rels2 OWNER TO evex;

--
-- Name: content_item_globals; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.content_item_globals AS
 SELECT '-100'::integer AS c_root_folder_id;


ALTER TABLE public.content_item_globals OWNER TO evex;

--
-- Name: content_template_globals; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.content_template_globals AS
 SELECT '-200'::integer AS c_root_folder_id;


ALTER TABLE public.content_template_globals OWNER TO evex;

--
-- Name: countries; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.countries (
    default_name character varying(100) NOT NULL,
    iso character(2) NOT NULL
);


ALTER TABLE public.countries OWNER TO evex;

--
-- Name: TABLE countries; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.countries IS '
    This is the country code/english name table from ISO 3166.
';


--
-- Name: COLUMN countries.default_name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.countries.default_name IS '
    This is admittedly a violation of 3NF but it is more efficient and helps with non-translated values.
See country.sql for more comments.
';


--
-- Name: country_codes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.country_codes (
    iso character(2) NOT NULL,
    country_name character varying(150) NOT NULL
);


ALTER TABLE public.country_codes OWNER TO evex;

--
-- Name: cr_content_mime_type_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_content_mime_type_map (
    content_type character varying(1000) NOT NULL,
    mime_type character varying(200) NOT NULL
);


ALTER TABLE public.cr_content_mime_type_map OWNER TO evex;

--
-- Name: TABLE cr_content_mime_type_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_content_mime_type_map IS '
  A mapping table that restricts the MIME types associated with a 
  content type.
';


--
-- Name: cr_content_text; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_content_text (
    revision_id integer NOT NULL,
    content integer
);


ALTER TABLE public.cr_content_text OWNER TO evex;

--
-- Name: TABLE cr_content_text; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_content_text IS '
  A temporary table for holding text extracted from the content blob.
  Provides a workaround for the fact that blob_to_string(content) has
  4000 character limit.
';


--
-- Name: cr_doc_filter; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_doc_filter (
    revision_id integer NOT NULL,
    content integer
);


ALTER TABLE public.cr_doc_filter OWNER TO evex;

--
-- Name: TABLE cr_doc_filter; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_doc_filter IS '
  A temporary table for holding binary documents that are to be converted
  into HTML (or plain text) prior to insertion into the repository.
';


--
-- Name: cr_extension_mime_type_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_extension_mime_type_map (
    extension character varying(200) NOT NULL,
    mime_type character varying(200)
);


ALTER TABLE public.cr_extension_mime_type_map OWNER TO evex;

--
-- Name: TABLE cr_extension_mime_type_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_extension_mime_type_map IS '
  a mapping table for extension to mime_type in db version of ns_guesstype data
';


--
-- Name: cr_extlinks; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_extlinks (
    extlink_id integer NOT NULL,
    url character varying(1000) NOT NULL,
    label character varying(1000) NOT NULL,
    description text
);


ALTER TABLE public.cr_extlinks OWNER TO evex;

--
-- Name: TABLE cr_extlinks; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_extlinks IS '
  Extlinks are pointers to items anywhere on the web which the publisher wishes
  to categorize, index and relate to items in the content repository.
';


--
-- Name: cr_files_to_delete; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_files_to_delete (
    path character varying(250),
    storage_area_key character varying(100)
);


ALTER TABLE public.cr_files_to_delete OWNER TO evex;

--
-- Name: TABLE cr_files_to_delete; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_files_to_delete IS '
  Table to store files to be deleted by a scheduled sweep.
  Since binaries are stored in filesystem and attributes in database,
  need a way to delete both atomically.  So any process to delete file-system cr_revisions,
  copies the file path to this table as part of the delete transaction.  Sweep
  run later to remove the files from filesystem once database info is successfully deleted.
';


--
-- Name: cr_folder_type_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_folder_type_map (
    folder_id integer NOT NULL,
    content_type character varying(1000) NOT NULL
);


ALTER TABLE public.cr_folder_type_map OWNER TO evex;

--
-- Name: TABLE cr_folder_type_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_folder_type_map IS '
  A one-to-many mapping table of content folders to content types. 
  Basically, this table restricts the content types a folder may contain.
  Future releases will add numeric and tagged constraints similar to
  thos available for content types.  
';


--
-- Name: cr_folders; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_folders (
    folder_id integer NOT NULL,
    label character varying(1000),
    description text,
    has_child_folders boolean DEFAULT false,
    has_child_symlinks boolean DEFAULT false,
    package_id integer
);


ALTER TABLE public.cr_folders OWNER TO evex;

--
-- Name: TABLE cr_folders; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_folders IS '
  Folders are used to support a virtual file system within the content
  repository.
';


--
-- Name: cr_item_keyword_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_item_keyword_map (
    item_id integer NOT NULL,
    keyword_id integer NOT NULL
);


ALTER TABLE public.cr_item_keyword_map OWNER TO evex;

--
-- Name: cr_item_publish_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_item_publish_audit (
    item_id integer,
    old_revision integer,
    new_revision integer,
    old_status character varying(40),
    new_status character varying(40),
    publish_date timestamp with time zone NOT NULL
);


ALTER TABLE public.cr_item_publish_audit OWNER TO evex;

--
-- Name: TABLE cr_item_publish_audit; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_item_publish_audit IS '
  An audit table (populated by a trigger on cr_items.live_revision)
  that is used to keep track of the publication history of an item.
';


--
-- Name: cr_item_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_item_rels (
    rel_id integer NOT NULL,
    item_id integer,
    related_object_id integer,
    relation_tag character varying(100),
    order_n integer
);


ALTER TABLE public.cr_item_rels OWNER TO evex;

--
-- Name: TABLE cr_item_rels; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_item_rels IS '
  Describes all relations from one item to any number of other
  objects.
';


--
-- Name: COLUMN cr_item_rels.relation_tag; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cr_item_rels.relation_tag IS '
  A token for lightweight classification of item relationships.
  If additional attributes are required, then a subtype of
  item_rel may be created.
';


--
-- Name: COLUMN cr_item_rels.order_n; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cr_item_rels.order_n IS '
  Optional column for specifying a sort order.  Note that the ordering
  method is application-dependent (it may be by relation type or
  across multiple relation types).
';


--
-- Name: cr_item_template_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_item_template_map (
    item_id integer NOT NULL,
    template_id integer NOT NULL,
    use_context character varying(100) NOT NULL
);


ALTER TABLE public.cr_item_template_map OWNER TO evex;

--
-- Name: TABLE cr_item_template_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_item_template_map IS '
  Allows a template to be assigned to a specific item.
';


--
-- Name: cr_keywords; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_keywords (
    keyword_id integer NOT NULL,
    parent_id integer,
    heading character varying(600) NOT NULL,
    description text,
    has_children boolean,
    tree_sortkey bit varying
);


ALTER TABLE public.cr_keywords OWNER TO evex;

--
-- Name: TABLE cr_keywords; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_keywords IS '
  Stores a subject taxonomy for classifying content items, analogous
  to the system used by a library.
';


--
-- Name: COLUMN cr_keywords.heading; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cr_keywords.heading IS '
  A subject heading.  This will become a message ID in the next
  release so it should never be referenced directly (only through
  the API)
';


--
-- Name: COLUMN cr_keywords.description; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cr_keywords.description IS '
  Description of a subject heading.  This will be a message ID in the next
  release so it should never be referenced directly (only through
  the API)
';


--
-- Name: cr_locales; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_locales (
    locale character varying(4) NOT NULL,
    label character varying(200) NOT NULL,
    nls_language character varying(30) NOT NULL,
    nls_territory character varying(30),
    nls_charset character varying(30)
);


ALTER TABLE public.cr_locales OWNER TO evex;

--
-- Name: TABLE cr_locales; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_locales IS '
  Locale definitions in Oracle consist of a language, and optionally
  territory and character set.  (Languages are associated with default
  territories and character sets when not defined).  The formats
  for numbers, currency, dates, etc. are determined by the territory.

  The cr_locales table is deprecated for OpenACS 5.2, and will be removed in OpenACS 6 (TIP #66)
';


--
-- Name: cr_mime_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_mime_types (
    label character varying(200),
    mime_type character varying(200) NOT NULL,
    file_extension character varying(200)
);


ALTER TABLE public.cr_mime_types OWNER TO evex;

--
-- Name: TABLE cr_mime_types; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_mime_types IS '
  file_extension is not used to recognize MIME types, but to associate
  a file extension to the file after its MIME type is specified.
';


--
-- Name: cr_release_periods; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_release_periods (
    item_id integer NOT NULL,
    start_when timestamp with time zone DEFAULT now(),
    end_when timestamp with time zone DEFAULT (now() + '20 years'::interval)
);


ALTER TABLE public.cr_release_periods OWNER TO evex;

--
-- Name: cr_symlinks; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_symlinks (
    symlink_id integer NOT NULL,
    target_id integer NOT NULL,
    label character varying(1000)
);


ALTER TABLE public.cr_symlinks OWNER TO evex;

--
-- Name: TABLE cr_symlinks; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_symlinks IS '
  Symlinks are pointers to items within the content repository.
';


--
-- Name: cr_resolved_items; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.cr_resolved_items AS
 SELECT i.parent_id,
    i.item_id,
    i.name,
        CASE
            WHEN (s.target_id IS NULL) THEN 'f'::text
            ELSE 't'::text
        END AS is_symlink,
    COALESCE(s.target_id, i.item_id) AS resolved_id,
    s.label
   FROM (public.cr_items i
     LEFT JOIN public.cr_symlinks s ON ((i.item_id = s.symlink_id)));


ALTER TABLE public.cr_resolved_items OWNER TO evex;

--
-- Name: cr_revision_attributes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_revision_attributes (
    revision_id integer NOT NULL,
    attributes text
);


ALTER TABLE public.cr_revision_attributes OWNER TO evex;

--
-- Name: COLUMN cr_revision_attributes.attributes; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cr_revision_attributes.attributes IS '
  An XML document representing the compiled attributes for a revision
';


--
-- Name: cr_revisionsx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.cr_revisionsx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id));


ALTER TABLE public.cr_revisionsx OWNER TO evex;

--
-- Name: cr_scheduled_release_job; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_scheduled_release_job (
    job_id integer,
    last_exec timestamp with time zone
);


ALTER TABLE public.cr_scheduled_release_job OWNER TO evex;

--
-- Name: TABLE cr_scheduled_release_job; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_scheduled_release_job IS '
  One-row table to track job ID of scheduled release update.
';


--
-- Name: cr_scheduled_release_log; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_scheduled_release_log (
    exec_date timestamp with time zone DEFAULT now() NOT NULL,
    items_released integer NOT NULL,
    items_expired integer NOT NULL,
    err_num integer,
    err_msg character varying(500)
);


ALTER TABLE public.cr_scheduled_release_log OWNER TO evex;

--
-- Name: TABLE cr_scheduled_release_log; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_scheduled_release_log IS '
  Maintains a record, including any exceptions that may
  have aborted processing, for each scheduled update of live content.
';


--
-- Name: cr_template_use_contexts; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_template_use_contexts (
    use_context character varying(100) NOT NULL
);


ALTER TABLE public.cr_template_use_contexts OWNER TO evex;

--
-- Name: TABLE cr_template_use_contexts; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_template_use_contexts IS '
  A simple table (for now) for constraining template use contexts.
';


--
-- Name: cr_templates; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_templates (
    template_id integer NOT NULL
);


ALTER TABLE public.cr_templates OWNER TO evex;

--
-- Name: TABLE cr_templates; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_templates IS '
  Templates are a special class of text objects that are used for specifying
  the layout of a content item.  They may be mapped to content types for
  defaults, or may be mapped to individual content items.
';


--
-- Name: cr_type_children; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_type_children (
    parent_type character varying(1000) NOT NULL,
    child_type character varying(1000) NOT NULL,
    relation_tag character varying(100) NOT NULL,
    min_n integer,
    max_n integer
);


ALTER TABLE public.cr_type_children OWNER TO evex;

--
-- Name: TABLE cr_type_children; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_type_children IS '
  Constrains the allowable content types which a content type may
  contain.
';


--
-- Name: cr_type_relations; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_type_relations (
    content_type character varying(1000) NOT NULL,
    target_type character varying(1000) NOT NULL,
    relation_tag character varying(100) NOT NULL,
    min_n integer,
    max_n integer
);


ALTER TABLE public.cr_type_relations OWNER TO evex;

--
-- Name: TABLE cr_type_relations; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_type_relations IS '
  Constrains the allowable object types to which a content type may
  relate (see above).
';


--
-- Name: cr_type_template_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_type_template_map (
    content_type character varying(1000) NOT NULL,
    template_id integer NOT NULL,
    use_context character varying(100) NOT NULL,
    is_default boolean DEFAULT false
);


ALTER TABLE public.cr_type_template_map OWNER TO evex;

--
-- Name: TABLE cr_type_template_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_type_template_map IS '
  A simple mapping template among content types and templates.
  Used to determine the default template to use in any particular
  context, as well as for building any UI that allows publishers
  to choose from a palette of templates.
';


--
-- Name: COLUMN cr_type_template_map.use_context; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.cr_type_template_map.use_context IS '
  A token to indicate the context in which a template is appropriate, 
  such as admin or public.  Should be constrained when it becomes
  clearer how this will be used.
';


--
-- Name: cr_xml_doc_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.cr_xml_doc_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cr_xml_doc_seq OWNER TO evex;

--
-- Name: cr_xml_docs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.cr_xml_docs (
    doc_id integer NOT NULL,
    doc text
);


ALTER TABLE public.cr_xml_docs OWNER TO evex;

--
-- Name: TABLE cr_xml_docs; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.cr_xml_docs IS '
  A temporary table for holding uploaded XML documents for the
  duration of a transaction, until they can be inserted into
  the content repository.
';


--
-- Name: currency_codes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.currency_codes (
    iso character(3) NOT NULL,
    currency_name character varying(200) NOT NULL,
    supported_p character(1) DEFAULT 'f'::bpchar,
    symbol character varying(10),
    rounding_factor integer DEFAULT 100,
    CONSTRAINT currency_codes_supported_check CHECK ((supported_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.currency_codes OWNER TO evex;

--
-- Name: dav_site_node_folder_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.dav_site_node_folder_map (
    node_id integer,
    folder_id integer,
    enabled_p boolean
);


ALTER TABLE public.dav_site_node_folder_map OWNER TO evex;

--
-- Name: diagram_dummy_logs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.diagram_dummy_logs (
    x1 timestamp with time zone,
    y1 integer,
    x2 timestamp with time zone,
    y2 integer,
    x3 timestamp with time zone,
    y3 integer
);


ALTER TABLE public.diagram_dummy_logs OWNER TO evex;

--
-- Name: dual; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.dual AS
 SELECT now() AS sysdate;


ALTER TABLE public.dual OWNER TO evex;

--
-- Name: ec_action_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_action_id_seq OWNER TO evex;

--
-- Name: ec_action_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_action_id_sequence AS
 SELECT nextval('public.ec_action_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_action_id_sequence OWNER TO evex;

--
-- Name: ec_address_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_address_id_seq OWNER TO evex;

--
-- Name: ec_address_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_address_id_sequence AS
 SELECT nextval('public.ec_address_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_address_id_sequence OWNER TO evex;

--
-- Name: ec_addresses; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_addresses (
    address_id integer NOT NULL,
    user_id integer NOT NULL,
    address_type character varying(20) NOT NULL,
    attn character varying(100),
    line1 character varying(100),
    line2 character varying(100),
    city character varying(100),
    usps_abbrev character(2),
    zip_code character varying(10),
    phone character varying(30),
    country_code character(2),
    full_state_name character varying(30),
    phone_time character varying(10)
);


ALTER TABLE public.ec_addresses OWNER TO evex;

--
-- Name: ec_admin_settings; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_admin_settings (
    admin_setting_id integer NOT NULL,
    base_shipping_cost numeric,
    default_shipping_per_item numeric,
    weight_shipping_cost numeric,
    add_exp_base_shipping_cost numeric,
    add_exp_amount_per_item numeric,
    add_exp_amount_by_weight numeric,
    default_template integer DEFAULT 1 NOT NULL,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_admin_settings OWNER TO evex;

--
-- Name: ec_admin_settings_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_admin_settings_audit (
    admin_setting_id integer,
    base_shipping_cost numeric,
    default_shipping_per_item numeric,
    weight_shipping_cost numeric,
    add_exp_base_shipping_cost numeric,
    add_exp_amount_per_item numeric,
    add_exp_amount_by_weight numeric,
    default_template integer,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_admin_settings_audit OWNER TO evex;

--
-- Name: ec_automatic_email_log; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_automatic_email_log (
    user_identification_id integer NOT NULL,
    email_template_id integer NOT NULL,
    order_id integer,
    shipment_id integer,
    gift_certificate_id integer,
    date_sent timestamp without time zone
);


ALTER TABLE public.ec_automatic_email_log OWNER TO evex;

--
-- Name: ec_canned_response_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_canned_response_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_canned_response_id_seq OWNER TO evex;

--
-- Name: ec_canned_response_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_canned_response_id_sequence AS
 SELECT nextval('public.ec_canned_response_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_canned_response_id_sequence OWNER TO evex;

--
-- Name: ec_canned_responses; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_canned_responses (
    response_id integer NOT NULL,
    one_line character varying(100) NOT NULL,
    response_text character varying(4000) NOT NULL
);


ALTER TABLE public.ec_canned_responses OWNER TO evex;

--
-- Name: ec_cat_mailing_lists; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_cat_mailing_lists (
    user_id integer NOT NULL,
    category_id integer,
    subcategory_id integer,
    subsubcategory_id integer
);


ALTER TABLE public.ec_cat_mailing_lists OWNER TO evex;

--
-- Name: ec_categories; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_categories (
    category_id integer NOT NULL,
    category_name character varying(100),
    sort_key numeric,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_categories OWNER TO evex;

--
-- Name: ec_categories_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_categories_audit (
    category_id integer,
    category_name character varying(100),
    sort_key numeric,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_categories_audit OWNER TO evex;

--
-- Name: ec_category_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_category_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_category_id_seq OWNER TO evex;

--
-- Name: ec_category_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_category_id_sequence AS
 SELECT nextval('public.ec_category_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_category_id_sequence OWNER TO evex;

--
-- Name: ec_category_product_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_category_product_map (
    product_id integer NOT NULL,
    category_id integer NOT NULL,
    publisher_favorite_p boolean,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_category_product_map OWNER TO evex;

--
-- Name: ec_category_product_map_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_category_product_map_audit (
    product_id integer,
    category_id integer,
    publisher_favorite_p boolean,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_category_product_map_audit OWNER TO evex;

--
-- Name: ec_category_template_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_category_template_map (
    category_id integer NOT NULL,
    template_id integer NOT NULL
);


ALTER TABLE public.ec_category_template_map OWNER TO evex;

--
-- Name: ec_creditcard_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_creditcard_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_creditcard_id_seq OWNER TO evex;

--
-- Name: ec_creditcard_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_creditcard_id_sequence AS
 SELECT nextval('public.ec_creditcard_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_creditcard_id_sequence OWNER TO evex;

--
-- Name: ec_creditcards; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_creditcards (
    creditcard_id integer NOT NULL,
    user_id integer NOT NULL,
    creditcard_type character(1),
    creditcard_number character varying(16),
    creditcard_last_four character(4),
    creditcard_expire character(5),
    billing_address integer,
    failed_p boolean DEFAULT false
);


ALTER TABLE public.ec_creditcards OWNER TO evex;

--
-- Name: ec_cs_action_info_used_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_cs_action_info_used_map (
    action_id integer NOT NULL,
    info_used character varying(100) NOT NULL
);


ALTER TABLE public.ec_cs_action_info_used_map OWNER TO evex;

--
-- Name: ec_cs_issue_type_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_cs_issue_type_map (
    issue_id integer NOT NULL,
    issue_type character varying(40) NOT NULL
);


ALTER TABLE public.ec_cs_issue_type_map OWNER TO evex;

--
-- Name: ec_custom_p_field_values_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_custom_p_field_values_audit (
    product_id integer,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false,
    brandname character varying(200),
    brandmodel character varying(200),
    brandmodelnumber integer,
    comission character varying(200),
    commission character varying(200)
);


ALTER TABLE public.ec_custom_p_field_values_audit OWNER TO evex;

--
-- Name: ec_custom_product_field_values; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_custom_product_field_values (
    product_id integer NOT NULL,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL,
    brandname character varying(200),
    brandmodel character varying(200),
    brandmodelnumber integer,
    comission character varying(200),
    commission character varying(200)
);


ALTER TABLE public.ec_custom_product_field_values OWNER TO evex;

--
-- Name: ec_custom_product_fields; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_custom_product_fields (
    field_identifier character varying(100) NOT NULL,
    field_name character varying(100),
    default_value character varying(100),
    column_type character varying(100),
    creation_date timestamp with time zone,
    active_p boolean DEFAULT true,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_custom_product_fields OWNER TO evex;

--
-- Name: ec_custom_product_fields_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_custom_product_fields_audit (
    field_identifier character varying(100),
    field_name character varying(100),
    default_value character varying(100),
    column_type character varying(100),
    creation_date timestamp with time zone,
    active_p boolean DEFAULT true,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_custom_product_fields_audit OWNER TO evex;

--
-- Name: ec_customer_serv_interactions; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_customer_serv_interactions (
    interaction_id integer NOT NULL,
    customer_service_rep integer,
    user_identification_id integer NOT NULL,
    interaction_date timestamp with time zone,
    interaction_originator character varying(20) NOT NULL,
    interaction_type character varying(30) NOT NULL,
    interaction_headers character varying(4000)
);


ALTER TABLE public.ec_customer_serv_interactions OWNER TO evex;

--
-- Name: ec_customer_service_actions; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_customer_service_actions (
    action_id integer NOT NULL,
    issue_id integer NOT NULL,
    interaction_id integer NOT NULL,
    action_details character varying(4000),
    follow_up_required character varying(4000)
);


ALTER TABLE public.ec_customer_service_actions OWNER TO evex;

--
-- Name: ec_customer_service_issues; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_customer_service_issues (
    issue_id integer NOT NULL,
    user_identification_id integer NOT NULL,
    order_id integer,
    gift_certificate_id integer,
    open_date timestamp with time zone NOT NULL,
    close_date timestamp with time zone,
    closed_by integer,
    deleted_p boolean DEFAULT false
);


ALTER TABLE public.ec_customer_service_issues OWNER TO evex;

--
-- Name: ec_gift_certificates; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_gift_certificates (
    gift_certificate_id integer NOT NULL,
    gift_certificate_state character varying(50) NOT NULL,
    amount numeric NOT NULL,
    amount_remaining_p boolean DEFAULT true,
    issue_date timestamp with time zone,
    authorized_date timestamp with time zone,
    claimed_date timestamp with time zone,
    issued_by integer,
    purchased_by integer,
    expires timestamp with time zone,
    user_id integer,
    claim_check character varying(50),
    certificate_message character varying(200),
    certificate_to character varying(100),
    certificate_from character varying(100),
    recipient_email character varying(100),
    voided_date timestamp with time zone,
    voided_by integer,
    reason_for_void character varying(4000),
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL,
    CONSTRAINT ec_gift_certificates_check CHECK (((user_id IS NOT NULL) OR (claim_check IS NOT NULL)))
);


ALTER TABLE public.ec_gift_certificates OWNER TO evex;

--
-- Name: ec_gift_certificates_issued; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_gift_certificates_issued AS
 SELECT ec_gift_certificates.gift_certificate_id,
    ec_gift_certificates.gift_certificate_state,
    ec_gift_certificates.amount,
    ec_gift_certificates.amount_remaining_p,
    ec_gift_certificates.issue_date,
    ec_gift_certificates.authorized_date,
    ec_gift_certificates.claimed_date,
    ec_gift_certificates.issued_by,
    ec_gift_certificates.purchased_by,
    ec_gift_certificates.expires,
    ec_gift_certificates.user_id,
    ec_gift_certificates.claim_check,
    ec_gift_certificates.certificate_message,
    ec_gift_certificates.certificate_to,
    ec_gift_certificates.certificate_from,
    ec_gift_certificates.recipient_email,
    ec_gift_certificates.voided_date,
    ec_gift_certificates.voided_by,
    ec_gift_certificates.reason_for_void,
    ec_gift_certificates.last_modified,
    ec_gift_certificates.last_modifying_user,
    ec_gift_certificates.modified_ip_address
   FROM public.ec_gift_certificates
  WHERE (((ec_gift_certificates.gift_certificate_state)::text = 'authorized'::text) AND (ec_gift_certificates.issued_by IS NOT NULL));


ALTER TABLE public.ec_gift_certificates_issued OWNER TO evex;

--
-- Name: ec_customer_service_reps; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_customer_service_reps AS
 SELECT cc_users.object_id,
    cc_users.object_type,
    cc_users.title,
    cc_users.package_id,
    cc_users.context_id,
    cc_users.security_inherit_p,
    cc_users.creation_user,
    cc_users.creation_date,
    cc_users.creation_ip,
    cc_users.last_modified,
    cc_users.modifying_user,
    cc_users.modifying_ip,
    cc_users.party_id,
    cc_users.email,
    cc_users.url,
    cc_users.person_id,
    cc_users.first_names,
    cc_users.last_name,
    cc_users.bio,
    cc_users.user_id,
    cc_users.authority_id,
    cc_users.username,
    cc_users.screen_name,
    cc_users.priv_name,
    cc_users.priv_email,
    cc_users.email_verified_p,
    cc_users.email_bouncing_p,
    cc_users.no_alerts_until,
    cc_users.last_visit,
    cc_users.second_to_last_visit,
    cc_users.n_sessions,
    cc_users.password,
    cc_users.salt,
    cc_users.password_question,
    cc_users.password_answer,
    cc_users.password_changed_date,
    cc_users.auth_token,
    cc_users.member_state,
    cc_users.rel_id
   FROM public.cc_users
  WHERE ((cc_users.user_id IN ( SELECT ec_customer_serv_interactions.customer_service_rep
           FROM public.ec_customer_serv_interactions)) OR (cc_users.user_id IN ( SELECT ec_gift_certificates_issued.issued_by
           FROM public.ec_gift_certificates_issued)));


ALTER TABLE public.ec_customer_service_reps OWNER TO evex;

--
-- Name: ec_email_template_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_email_template_id_seq
    START WITH 7
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_email_template_id_seq OWNER TO evex;

--
-- Name: ec_email_template_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_email_template_id_sequence AS
 SELECT nextval('public.ec_email_template_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_email_template_id_sequence OWNER TO evex;

--
-- Name: ec_email_templates; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_email_templates (
    email_template_id integer NOT NULL,
    title character varying(100),
    subject character varying(200),
    message character varying(4000),
    variables character varying(1000),
    when_sent character varying(1000),
    issue_type_list character varying(100),
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_email_templates OWNER TO evex;

--
-- Name: ec_email_templates_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_email_templates_audit (
    email_template_id integer,
    title character varying(100),
    subject character varying(200),
    message character varying(4000),
    variables character varying(1000),
    when_sent character varying(1000),
    issue_type_list character varying(100),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_email_templates_audit OWNER TO evex;

--
-- Name: ec_financial_transactions; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_financial_transactions (
    transaction_id character varying(20) NOT NULL,
    refunded_transaction_id character varying(20),
    order_id integer,
    shipment_id integer,
    refund_id integer,
    gift_certificate_id integer,
    creditcard_id integer NOT NULL,
    transaction_amount numeric NOT NULL,
    refunded_amount numeric,
    transaction_type character varying(6) NOT NULL,
    to_be_captured_p boolean,
    inserted_date timestamp with time zone NOT NULL,
    authorized_date timestamp with time zone,
    to_be_captured_date timestamp with time zone,
    marked_date timestamp with time zone,
    refunded_date timestamp with time zone,
    failed_p boolean DEFAULT false,
    CONSTRAINT ec_financial_transactions_check CHECK (((order_id IS NOT NULL) OR (gift_certificate_id IS NOT NULL))),
    CONSTRAINT ec_financial_transactions_transaction_type_check CHECK (((transaction_type)::text = ANY (ARRAY[('charge'::character varying)::text, ('refund'::character varying)::text])))
);


ALTER TABLE public.ec_financial_transactions OWNER TO evex;

--
-- Name: ec_fin_transactions_reportable; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_fin_transactions_reportable AS
 SELECT ec_financial_transactions.transaction_id,
    ec_financial_transactions.refunded_transaction_id,
    ec_financial_transactions.order_id,
    ec_financial_transactions.shipment_id,
    ec_financial_transactions.refund_id,
    ec_financial_transactions.gift_certificate_id,
    ec_financial_transactions.creditcard_id,
    ec_financial_transactions.transaction_amount,
    ec_financial_transactions.refunded_amount,
    ec_financial_transactions.transaction_type,
    ec_financial_transactions.to_be_captured_p,
    ec_financial_transactions.inserted_date,
    ec_financial_transactions.authorized_date,
    ec_financial_transactions.to_be_captured_date,
    ec_financial_transactions.marked_date,
    ec_financial_transactions.refunded_date,
    ec_financial_transactions.failed_p
   FROM public.ec_financial_transactions
  WHERE ((((ec_financial_transactions.transaction_type)::text = 'charge'::text) AND (ec_financial_transactions.to_be_captured_p = true) AND (ec_financial_transactions.failed_p = false)) OR (((ec_financial_transactions.transaction_type)::text = 'refund'::text) AND (ec_financial_transactions.failed_p = false)));


ALTER TABLE public.ec_fin_transactions_reportable OWNER TO evex;

--
-- Name: ec_gift_cert_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_gift_cert_id_seq
    START WITH 1000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_gift_cert_id_seq OWNER TO evex;

--
-- Name: ec_gift_cert_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_gift_cert_id_sequence AS
 SELECT nextval('public.ec_gift_cert_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_gift_cert_id_sequence OWNER TO evex;

--
-- Name: ec_gift_certificate_usage; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_gift_certificate_usage (
    gift_certificate_id integer NOT NULL,
    order_id integer,
    amount_used numeric,
    used_date timestamp with time zone,
    amount_reinstated numeric,
    reinstated_date timestamp without time zone
);


ALTER TABLE public.ec_gift_certificate_usage OWNER TO evex;

--
-- Name: ec_gift_certificates_approved; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_gift_certificates_approved AS
 SELECT ec_gift_certificates.gift_certificate_id,
    ec_gift_certificates.gift_certificate_state,
    ec_gift_certificates.amount,
    ec_gift_certificates.amount_remaining_p,
    ec_gift_certificates.issue_date,
    ec_gift_certificates.authorized_date,
    ec_gift_certificates.claimed_date,
    ec_gift_certificates.issued_by,
    ec_gift_certificates.purchased_by,
    ec_gift_certificates.expires,
    ec_gift_certificates.user_id,
    ec_gift_certificates.claim_check,
    ec_gift_certificates.certificate_message,
    ec_gift_certificates.certificate_to,
    ec_gift_certificates.certificate_from,
    ec_gift_certificates.recipient_email,
    ec_gift_certificates.voided_date,
    ec_gift_certificates.voided_by,
    ec_gift_certificates.reason_for_void,
    ec_gift_certificates.last_modified,
    ec_gift_certificates.last_modifying_user,
    ec_gift_certificates.modified_ip_address
   FROM public.ec_gift_certificates
  WHERE ((ec_gift_certificates.gift_certificate_state)::text = 'authorized'::text);


ALTER TABLE public.ec_gift_certificates_approved OWNER TO evex;

--
-- Name: ec_gift_certificates_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_gift_certificates_audit (
    gift_certificate_id integer,
    gift_certificate_state character varying(50),
    amount numeric,
    issue_date timestamp with time zone,
    authorized_date timestamp with time zone,
    issued_by integer,
    purchased_by integer,
    expires timestamp with time zone,
    user_id integer,
    claim_check character varying(50),
    certificate_message character varying(200),
    certificate_to character varying(100),
    certificate_from character varying(100),
    recipient_email character varying(100),
    voided_date timestamp with time zone,
    voided_by integer,
    reason_for_void character varying(4000),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_gift_certificates_audit OWNER TO evex;

--
-- Name: ec_gift_certificates_purchased; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_gift_certificates_purchased AS
 SELECT ec_gift_certificates.gift_certificate_id,
    ec_gift_certificates.gift_certificate_state,
    ec_gift_certificates.amount,
    ec_gift_certificates.amount_remaining_p,
    ec_gift_certificates.issue_date,
    ec_gift_certificates.authorized_date,
    ec_gift_certificates.claimed_date,
    ec_gift_certificates.issued_by,
    ec_gift_certificates.purchased_by,
    ec_gift_certificates.expires,
    ec_gift_certificates.user_id,
    ec_gift_certificates.claim_check,
    ec_gift_certificates.certificate_message,
    ec_gift_certificates.certificate_to,
    ec_gift_certificates.certificate_from,
    ec_gift_certificates.recipient_email,
    ec_gift_certificates.voided_date,
    ec_gift_certificates.voided_by,
    ec_gift_certificates.reason_for_void,
    ec_gift_certificates.last_modified,
    ec_gift_certificates.last_modifying_user,
    ec_gift_certificates.modified_ip_address
   FROM public.ec_gift_certificates
  WHERE ((ec_gift_certificates.gift_certificate_state)::text = 'authorized'::text);


ALTER TABLE public.ec_gift_certificates_purchased OWNER TO evex;

--
-- Name: ec_interaction_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_interaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_interaction_id_seq OWNER TO evex;

--
-- Name: ec_interaction_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_interaction_id_sequence AS
 SELECT nextval('public.ec_interaction_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_interaction_id_sequence OWNER TO evex;

--
-- Name: ec_issue_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_issue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_issue_id_seq OWNER TO evex;

--
-- Name: ec_issue_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_issue_id_sequence AS
 SELECT nextval('public.ec_issue_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_issue_id_sequence OWNER TO evex;

--
-- Name: ec_item_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_item_id_seq OWNER TO evex;

--
-- Name: ec_item_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_item_id_sequence AS
 SELECT nextval('public.ec_item_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_item_id_sequence OWNER TO evex;

--
-- Name: ec_items; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_items (
    item_id integer NOT NULL,
    order_id integer NOT NULL,
    product_id integer NOT NULL,
    color_choice character varying(4000),
    size_choice character varying(4000),
    style_choice character varying(4000),
    shipment_id integer,
    in_cart_date timestamp with time zone,
    voided_date timestamp with time zone,
    voided_by integer,
    expired_date timestamp with time zone,
    item_state character varying(50) DEFAULT 'in_basket'::character varying,
    received_back_date timestamp with time zone,
    price_charged numeric,
    price_refunded numeric,
    shipping_charged numeric,
    shipping_refunded numeric,
    price_tax_charged numeric,
    price_tax_refunded numeric,
    shipping_tax_charged numeric,
    shipping_tax_refunded numeric,
    price_name character varying(30),
    refund_id integer,
    cs_comments character varying(4000)
);


ALTER TABLE public.ec_items OWNER TO evex;

--
-- Name: ec_shipments; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_shipments (
    shipment_id integer NOT NULL,
    order_id integer NOT NULL,
    address_id integer,
    shipment_date timestamp with time zone NOT NULL,
    expected_arrival_date timestamp with time zone,
    carrier character varying(50),
    tracking_number character varying(24),
    actual_arrival_date timestamp with time zone,
    actual_arrival_detail character varying(4000),
    shippable_p boolean DEFAULT true,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20)
);


ALTER TABLE public.ec_shipments OWNER TO evex;

--
-- Name: ec_items_money_view; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_items_money_view AS
 SELECT i.shipment_id,
    i.order_id,
    s.shipment_date,
    (COALESCE(sum(i.price_charged), (0)::numeric) - COALESCE(sum(i.price_refunded), (0)::numeric)) AS bal_price_charged,
    (COALESCE(sum(i.shipping_charged), (0)::numeric) - COALESCE(sum(i.shipping_refunded), (0)::numeric)) AS bal_shipping_charged,
    (((COALESCE(sum(i.price_tax_charged), (0)::numeric) - COALESCE(sum(i.price_tax_refunded), (0)::numeric)) + COALESCE(sum(i.shipping_tax_charged), (0)::numeric)) - COALESCE(sum(i.shipping_tax_refunded), (0)::numeric)) AS bal_tax_charged
   FROM public.ec_items i,
    public.ec_shipments s
  WHERE ((i.shipment_id = s.shipment_id) AND ((i.item_state)::text <> 'void'::text))
  GROUP BY i.order_id, i.shipment_id, s.shipment_date;


ALTER TABLE public.ec_items_money_view OWNER TO evex;

--
-- Name: ec_items_refundable; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_items_refundable AS
 SELECT ec_items.item_id,
    ec_items.order_id,
    ec_items.product_id,
    ec_items.color_choice,
    ec_items.size_choice,
    ec_items.style_choice,
    ec_items.shipment_id,
    ec_items.in_cart_date,
    ec_items.voided_date,
    ec_items.voided_by,
    ec_items.expired_date,
    ec_items.item_state,
    ec_items.received_back_date,
    ec_items.price_charged,
    ec_items.price_refunded,
    ec_items.shipping_charged,
    ec_items.shipping_refunded,
    ec_items.price_tax_charged,
    ec_items.price_tax_refunded,
    ec_items.shipping_tax_charged,
    ec_items.shipping_tax_refunded,
    ec_items.price_name,
    ec_items.refund_id,
    ec_items.cs_comments
   FROM public.ec_items
  WHERE (((ec_items.item_state)::text = ANY (ARRAY[('shipped'::character varying)::text, ('arrived'::character varying)::text])) AND (ec_items.refund_id IS NULL));


ALTER TABLE public.ec_items_refundable OWNER TO evex;

--
-- Name: ec_items_reportable; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_items_reportable AS
 SELECT ec_items.item_id,
    ec_items.order_id,
    ec_items.product_id,
    ec_items.color_choice,
    ec_items.size_choice,
    ec_items.style_choice,
    ec_items.shipment_id,
    ec_items.in_cart_date,
    ec_items.voided_date,
    ec_items.voided_by,
    ec_items.expired_date,
    ec_items.item_state,
    ec_items.received_back_date,
    ec_items.price_charged,
    ec_items.price_refunded,
    ec_items.shipping_charged,
    ec_items.shipping_refunded,
    ec_items.price_tax_charged,
    ec_items.price_tax_refunded,
    ec_items.shipping_tax_charged,
    ec_items.shipping_tax_refunded,
    ec_items.price_name,
    ec_items.refund_id,
    ec_items.cs_comments
   FROM public.ec_items
  WHERE ((ec_items.item_state)::text = ANY (ARRAY[('to_be_shipped'::character varying)::text, ('shipped'::character varying)::text, ('arrived'::character varying)::text]));


ALTER TABLE public.ec_items_reportable OWNER TO evex;

--
-- Name: ec_items_shippable; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_items_shippable AS
 SELECT ec_items.item_id,
    ec_items.order_id,
    ec_items.product_id,
    ec_items.color_choice,
    ec_items.size_choice,
    ec_items.style_choice,
    ec_items.shipment_id,
    ec_items.in_cart_date,
    ec_items.voided_date,
    ec_items.voided_by,
    ec_items.expired_date,
    ec_items.item_state,
    ec_items.received_back_date,
    ec_items.price_charged,
    ec_items.price_refunded,
    ec_items.shipping_charged,
    ec_items.shipping_refunded,
    ec_items.price_tax_charged,
    ec_items.price_tax_refunded,
    ec_items.shipping_tax_charged,
    ec_items.shipping_tax_refunded,
    ec_items.price_name,
    ec_items.refund_id,
    ec_items.cs_comments
   FROM public.ec_items
  WHERE ((ec_items.item_state)::text = 'to_be_shipped'::text);


ALTER TABLE public.ec_items_shippable OWNER TO evex;

--
-- Name: ec_offer_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_offer_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_offer_seq OWNER TO evex;

--
-- Name: ec_offer_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_offer_sequence AS
 SELECT nextval('public.ec_offer_seq'::regclass) AS nextval;


ALTER TABLE public.ec_offer_sequence OWNER TO evex;

--
-- Name: ec_offers; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_offers (
    offer_id integer NOT NULL,
    product_id integer NOT NULL,
    retailer_location_id integer NOT NULL,
    store_sku integer,
    retailer_premiums character varying(500),
    price numeric NOT NULL,
    shipping numeric,
    shipping_unavailable_p boolean,
    stock_status character(1),
    special_offer_p boolean,
    special_offer_html character varying(500),
    offer_begins timestamp with time zone NOT NULL,
    offer_ends timestamp with time zone NOT NULL,
    deleted_p boolean DEFAULT false,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL,
    CONSTRAINT ec_offers_stock_status_check CHECK ((stock_status = ANY (ARRAY['o'::bpchar, 'q'::bpchar, 'm'::bpchar, 's'::bpchar, 'i'::bpchar])))
);


ALTER TABLE public.ec_offers OWNER TO evex;

--
-- Name: ec_offers_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_offers_audit (
    offer_id integer,
    product_id integer,
    retailer_location_id integer,
    store_sku integer,
    retailer_premiums character varying(500),
    price numeric,
    shipping numeric,
    shipping_unavailable_p boolean,
    stock_status character(1),
    special_offer_p boolean,
    special_offer_html character varying(500),
    offer_begins timestamp with time zone,
    offer_ends timestamp with time zone,
    deleted_p boolean DEFAULT false,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false,
    CONSTRAINT ec_offers_audit_stock_status_check CHECK ((stock_status = ANY (ARRAY['o'::bpchar, 'q'::bpchar, 'm'::bpchar, 's'::bpchar, 'i'::bpchar])))
);


ALTER TABLE public.ec_offers_audit OWNER TO evex;

--
-- Name: ec_offers_current; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_offers_current AS
 SELECT ec_offers.offer_id,
    ec_offers.product_id,
    ec_offers.retailer_location_id,
    ec_offers.store_sku,
    ec_offers.retailer_premiums,
    ec_offers.price,
    ec_offers.shipping,
    ec_offers.shipping_unavailable_p,
    ec_offers.stock_status,
    ec_offers.special_offer_p,
    ec_offers.special_offer_html,
    ec_offers.offer_begins,
    ec_offers.offer_ends,
    ec_offers.deleted_p,
    ec_offers.last_modified,
    ec_offers.last_modifying_user,
    ec_offers.modified_ip_address
   FROM public.ec_offers
  WHERE ((ec_offers.deleted_p = false) AND (now() >= ec_offers.offer_begins) AND (now() <= ec_offers.offer_ends));


ALTER TABLE public.ec_offers_current OWNER TO evex;

--
-- Name: ec_order_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_order_id_seq
    START WITH 3000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_order_id_seq OWNER TO evex;

--
-- Name: ec_order_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_order_id_sequence AS
 SELECT nextval('public.ec_order_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_order_id_sequence OWNER TO evex;

--
-- Name: ec_orders; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_orders (
    order_id integer NOT NULL,
    user_id integer,
    user_session_id integer,
    order_state character varying(50) DEFAULT 'in_basket'::character varying NOT NULL,
    tax_exempt_p boolean DEFAULT false,
    shipping_method character varying(20),
    shipping_address integer,
    creditcard_id integer,
    in_basket_date timestamp with time zone,
    confirmed_date timestamp with time zone,
    authorized_date timestamp with time zone,
    voided_date timestamp with time zone,
    expired_date timestamp with time zone,
    shipping_charged numeric,
    shipping_refunded numeric,
    shipping_tax_charged numeric,
    shipping_tax_refunded numeric,
    cs_comments character varying(4000),
    reason_for_void character varying(4000),
    voided_by integer,
    saved_p boolean,
    CONSTRAINT ec_orders_check CHECK (((user_id IS NOT NULL) OR (user_session_id IS NOT NULL)))
);


ALTER TABLE public.ec_orders OWNER TO evex;

--
-- Name: ec_orders_reportable; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_orders_reportable AS
 SELECT ec_orders.order_id,
    ec_orders.user_id,
    ec_orders.user_session_id,
    ec_orders.order_state,
    ec_orders.tax_exempt_p,
    ec_orders.shipping_method,
    ec_orders.shipping_address,
    ec_orders.creditcard_id,
    ec_orders.in_basket_date,
    ec_orders.confirmed_date,
    ec_orders.authorized_date,
    ec_orders.voided_date,
    ec_orders.expired_date,
    ec_orders.shipping_charged,
    ec_orders.shipping_refunded,
    ec_orders.shipping_tax_charged,
    ec_orders.shipping_tax_refunded,
    ec_orders.cs_comments,
    ec_orders.reason_for_void,
    ec_orders.voided_by,
    ec_orders.saved_p
   FROM public.ec_orders
  WHERE (((ec_orders.order_state)::text <> 'in_basket'::text) AND ((ec_orders.order_state)::text <> 'void'::text));


ALTER TABLE public.ec_orders_reportable OWNER TO evex;

--
-- Name: ec_orders_shippable; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_orders_shippable AS
 SELECT ec_orders.order_id,
    ec_orders.user_id,
    ec_orders.user_session_id,
    ec_orders.order_state,
    ec_orders.tax_exempt_p,
    ec_orders.shipping_method,
    ec_orders.shipping_address,
    ec_orders.creditcard_id,
    ec_orders.in_basket_date,
    ec_orders.confirmed_date,
    ec_orders.authorized_date,
    ec_orders.voided_date,
    ec_orders.expired_date,
    ec_orders.shipping_charged,
    ec_orders.shipping_refunded,
    ec_orders.shipping_tax_charged,
    ec_orders.shipping_tax_refunded,
    ec_orders.cs_comments,
    ec_orders.reason_for_void,
    ec_orders.voided_by,
    ec_orders.saved_p
   FROM public.ec_orders
  WHERE ((ec_orders.order_state)::text = ANY (ARRAY[('authorized'::character varying)::text, ('partially_fulfilled'::character varying)::text]));


ALTER TABLE public.ec_orders_shippable OWNER TO evex;

--
-- Name: ec_picklist_item_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_picklist_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_picklist_item_id_seq OWNER TO evex;

--
-- Name: ec_picklist_item_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_picklist_item_id_sequence AS
 SELECT nextval('public.ec_picklist_item_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_picklist_item_id_sequence OWNER TO evex;

--
-- Name: ec_picklist_items; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_picklist_items (
    picklist_item_id integer NOT NULL,
    picklist_item character varying(100),
    picklist_name character varying(100),
    sort_key numeric,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_picklist_items OWNER TO evex;

--
-- Name: ec_picklist_items_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_picklist_items_audit (
    picklist_item_id integer,
    picklist_item character varying(100),
    picklist_name character varying(100),
    sort_key numeric,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_picklist_items_audit OWNER TO evex;

--
-- Name: ec_problem_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_problem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_problem_id_seq OWNER TO evex;

--
-- Name: ec_problem_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_problem_id_sequence AS
 SELECT nextval('public.ec_problem_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_problem_id_sequence OWNER TO evex;

--
-- Name: ec_problems_log; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_problems_log (
    problem_id integer NOT NULL,
    problem_date timestamp with time zone,
    problem_details character varying(4000),
    order_id integer,
    gift_certificate_id integer,
    resolved_date timestamp with time zone,
    resolved_by integer
);


ALTER TABLE public.ec_problems_log OWNER TO evex;

--
-- Name: ec_product_comment_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_product_comment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_product_comment_id_seq OWNER TO evex;

--
-- Name: ec_product_comment_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_product_comment_id_sequence AS
 SELECT nextval('public.ec_product_comment_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_product_comment_id_sequence OWNER TO evex;

--
-- Name: ec_product_comments; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_comments (
    comment_id integer NOT NULL,
    product_id integer NOT NULL,
    user_id integer NOT NULL,
    user_comment character varying(4000),
    one_line_summary character varying(300),
    rating numeric,
    approved_p boolean,
    comment_date timestamp with time zone,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_product_comments OWNER TO evex;

--
-- Name: ec_product_comments_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_comments_audit (
    comment_id integer,
    product_id integer,
    user_id integer,
    user_comment character varying(4000),
    one_line_summary character varying(300),
    rating numeric,
    approved_p boolean,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_product_comments_audit OWNER TO evex;

--
-- Name: ec_product_links; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_links (
    product_a integer NOT NULL,
    product_b integer NOT NULL,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_product_links OWNER TO evex;

--
-- Name: ec_product_links_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_links_audit (
    product_a integer,
    product_b integer,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_product_links_audit OWNER TO evex;

--
-- Name: ec_product_purchase_comb; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_purchase_comb (
    product_id integer NOT NULL,
    product_0 integer,
    product_1 integer,
    product_2 integer,
    product_3 integer,
    product_4 integer
);


ALTER TABLE public.ec_product_purchase_comb OWNER TO evex;

--
-- Name: ec_product_recommend_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_recommend_audit (
    recommendation_id integer,
    product_id integer,
    user_class_id integer,
    recommendation_text character varying(4000),
    active_p boolean DEFAULT true,
    category_id integer,
    subcategory_id integer,
    subsubcategory_id integer,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_product_recommend_audit OWNER TO evex;

--
-- Name: ec_product_recommendations; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_recommendations (
    recommendation_id integer NOT NULL,
    product_id integer NOT NULL,
    user_class_id integer,
    recommendation_text character varying(4000),
    active_p boolean DEFAULT true,
    category_id integer,
    subcategory_id integer,
    subsubcategory_id integer,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_product_recommendations OWNER TO evex;

--
-- Name: ec_product_review_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_product_review_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_product_review_id_seq OWNER TO evex;

--
-- Name: ec_product_review_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_product_review_id_sequence AS
 SELECT nextval('public.ec_product_review_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_product_review_id_sequence OWNER TO evex;

--
-- Name: ec_product_reviews; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_reviews (
    review_id integer NOT NULL,
    product_id integer NOT NULL,
    author_name character varying(100),
    publication character varying(100),
    review_date timestamp with time zone,
    review text,
    display_p boolean,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_product_reviews OWNER TO evex;

--
-- Name: ec_product_reviews_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_reviews_audit (
    review_id integer,
    product_id integer,
    author_name character varying(100),
    publication character varying(100),
    review_date timestamp with time zone,
    review text,
    display_p boolean,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_product_reviews_audit OWNER TO evex;

--
-- Name: ec_product_series_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_series_map (
    series_id integer NOT NULL,
    component_id integer NOT NULL,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_product_series_map OWNER TO evex;

--
-- Name: ec_product_series_map_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_series_map_audit (
    series_id integer,
    component_id integer,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_product_series_map_audit OWNER TO evex;

--
-- Name: ec_product_u_c_prices_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_u_c_prices_audit (
    product_id integer,
    user_class_id integer,
    price numeric,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_product_u_c_prices_audit OWNER TO evex;

--
-- Name: ec_product_user_class_prices; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_product_user_class_prices (
    product_id integer NOT NULL,
    user_class_id integer NOT NULL,
    price numeric,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_product_user_class_prices OWNER TO evex;

--
-- Name: ec_products; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_products (
    product_id integer NOT NULL,
    sku character varying(100),
    product_name character varying(200),
    creation_date timestamp with time zone DEFAULT now() NOT NULL,
    one_line_description character varying(400),
    detailed_description character varying(4000),
    search_keywords character varying(4000),
    price numeric,
    no_shipping_avail_p boolean DEFAULT false,
    shipping numeric,
    shipping_additional numeric,
    weight numeric,
    dirname character varying(200),
    present_p boolean DEFAULT true,
    active_p boolean DEFAULT true,
    available_date timestamp with time zone DEFAULT now() NOT NULL,
    announcements character varying(4000),
    announcements_expire timestamp with time zone,
    url character varying(300),
    template_id integer,
    stock_status character(1),
    color_list character varying(4000),
    size_list character varying(4000),
    style_list character varying(4000),
    email_on_purchase_list character varying(4000),
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL,
    CONSTRAINT ec_products_stock_status_check CHECK ((stock_status = ANY (ARRAY['o'::bpchar, 'q'::bpchar, 'm'::bpchar, 's'::bpchar, 'i'::bpchar])))
);


ALTER TABLE public.ec_products OWNER TO evex;

--
-- Name: ec_products_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_products_audit (
    product_id integer,
    product_name character varying(200),
    creation_date timestamp with time zone,
    one_line_description character varying(400),
    detailed_description character varying(4000),
    search_keywords character varying(4000),
    price numeric,
    shipping numeric,
    shipping_additional numeric,
    weight numeric,
    dirname character varying(200),
    present_p boolean DEFAULT true,
    active_p boolean DEFAULT true,
    available_date timestamp with time zone,
    announcements character varying(4000),
    announcements_expire timestamp with time zone,
    url character varying(300),
    template_id integer,
    stock_status character(1),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false,
    CONSTRAINT ec_products_audit_stock_status_check CHECK ((stock_status = ANY (ARRAY['o'::bpchar, 'q'::bpchar, 'm'::bpchar, 's'::bpchar, 'i'::bpchar])))
);


ALTER TABLE public.ec_products_audit OWNER TO evex;

--
-- Name: ec_products_displayable; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_products_displayable AS
 SELECT ec_products.product_id,
    ec_products.sku,
    ec_products.product_name,
    ec_products.creation_date,
    ec_products.one_line_description,
    ec_products.detailed_description,
    ec_products.search_keywords,
    ec_products.price,
    ec_products.no_shipping_avail_p,
    ec_products.shipping,
    ec_products.shipping_additional,
    ec_products.weight,
    ec_products.dirname,
    ec_products.present_p,
    ec_products.active_p,
    ec_products.available_date,
    ec_products.announcements,
    ec_products.announcements_expire,
    ec_products.url,
    ec_products.template_id,
    ec_products.stock_status,
    ec_products.color_list,
    ec_products.size_list,
    ec_products.style_list,
    ec_products.email_on_purchase_list,
    ec_products.last_modified,
    ec_products.last_modifying_user,
    ec_products.modified_ip_address
   FROM public.ec_products
  WHERE (ec_products.active_p = true);


ALTER TABLE public.ec_products_displayable OWNER TO evex;

--
-- Name: ec_products_searchable; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_products_searchable AS
 SELECT ec_products.product_id,
    ec_products.sku,
    ec_products.product_name,
    ec_products.creation_date,
    ec_products.one_line_description,
    ec_products.detailed_description,
    ec_products.search_keywords,
    ec_products.price,
    ec_products.no_shipping_avail_p,
    ec_products.shipping,
    ec_products.shipping_additional,
    ec_products.weight,
    ec_products.dirname,
    ec_products.present_p,
    ec_products.active_p,
    ec_products.available_date,
    ec_products.announcements,
    ec_products.announcements_expire,
    ec_products.url,
    ec_products.template_id,
    ec_products.stock_status,
    ec_products.color_list,
    ec_products.size_list,
    ec_products.style_list,
    ec_products.email_on_purchase_list,
    ec_products.last_modified,
    ec_products.last_modifying_user,
    ec_products.modified_ip_address
   FROM public.ec_products
  WHERE ((ec_products.active_p = true) AND (ec_products.present_p = true));


ALTER TABLE public.ec_products_searchable OWNER TO evex;

--
-- Name: ec_recommendation_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_recommendation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_recommendation_id_seq OWNER TO evex;

--
-- Name: ec_recommendation_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_recommendation_id_sequence AS
 SELECT nextval('public.ec_recommendation_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_recommendation_id_sequence OWNER TO evex;

--
-- Name: ec_subcategories; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_subcategories (
    subcategory_id integer NOT NULL,
    category_id integer NOT NULL,
    subcategory_name character varying(100),
    sort_key numeric,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_subcategories OWNER TO evex;

--
-- Name: ec_subcategories_augmented; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_subcategories_augmented AS
 SELECT subs.subcategory_id,
    subs.category_id,
    subs.subcategory_name,
    subs.sort_key,
    subs.last_modified,
    subs.last_modifying_user,
    subs.modified_ip_address,
    cats.category_name
   FROM public.ec_subcategories subs,
    public.ec_categories cats
  WHERE (subs.category_id = cats.category_id);


ALTER TABLE public.ec_subcategories_augmented OWNER TO evex;

--
-- Name: ec_subsubcategories; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_subsubcategories (
    subsubcategory_id integer NOT NULL,
    subcategory_id integer NOT NULL,
    subsubcategory_name character varying(100),
    sort_key numeric,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_subsubcategories OWNER TO evex;

--
-- Name: ec_subsubcategories_augmented; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_subsubcategories_augmented AS
 SELECT subsubs.subsubcategory_id,
    subsubs.subcategory_id,
    subsubs.subsubcategory_name,
    subsubs.sort_key,
    subsubs.last_modified,
    subsubs.last_modifying_user,
    subsubs.modified_ip_address,
    subs.subcategory_name,
    cats.category_id,
    cats.category_name
   FROM public.ec_subsubcategories subsubs,
    public.ec_subcategories subs,
    public.ec_categories cats
  WHERE ((subsubs.subcategory_id = subs.subcategory_id) AND (subs.category_id = cats.category_id));


ALTER TABLE public.ec_subsubcategories_augmented OWNER TO evex;

--
-- Name: ec_recommendations_cats_view; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_recommendations_cats_view AS
 SELECT recs.recommendation_id,
    recs.product_id,
    recs.user_class_id,
    recs.recommendation_text,
    recs.active_p,
    recs.category_id,
    recs.subcategory_id,
    recs.subsubcategory_id,
    recs.last_modified,
    recs.last_modifying_user,
    recs.modified_ip_address,
    COALESCE(cats.category_id, subs.category_id, subsubs.category_id) AS the_category_id,
    COALESCE(cats.category_name, subs.category_name, subsubs.category_name) AS the_category_name,
    COALESCE(subs.subcategory_id, subsubs.subcategory_id) AS the_subcategory_id,
    COALESCE(subs.subcategory_name, subsubs.subcategory_name) AS the_subcategory_name,
    subsubs.subsubcategory_id AS the_subsubcategory_id,
    subsubs.subsubcategory_name AS the_subsubcategory_name
   FROM (((public.ec_product_recommendations recs
     LEFT JOIN public.ec_categories cats USING (category_id))
     LEFT JOIN public.ec_subcategories_augmented subs USING (subcategory_id))
     LEFT JOIN public.ec_subsubcategories_augmented subsubs ON ((recs.subsubcategory_id = subsubs.subcategory_id)));


ALTER TABLE public.ec_recommendations_cats_view OWNER TO evex;

--
-- Name: ec_refunds; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_refunds (
    refund_id integer NOT NULL,
    order_id integer NOT NULL,
    refund_amount numeric NOT NULL,
    refund_date timestamp with time zone NOT NULL,
    refunded_by integer NOT NULL,
    refund_reasons character varying(4000)
);


ALTER TABLE public.ec_refunds OWNER TO evex;

--
-- Name: ec_retailer_location_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_retailer_location_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_retailer_location_seq OWNER TO evex;

--
-- Name: ec_retailer_location_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_retailer_location_sequence AS
 SELECT nextval('public.ec_retailer_location_seq'::regclass) AS nextval;


ALTER TABLE public.ec_retailer_location_sequence OWNER TO evex;

--
-- Name: ec_retailer_locations; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_retailer_locations (
    retailer_location_id integer NOT NULL,
    retailer_id integer NOT NULL,
    location_name character varying(300),
    primary_contact_name character varying(100),
    secondary_contact_name character varying(100),
    primary_contact_info character varying(4000),
    secondary_contact_info character varying(4000),
    line1 character varying(100),
    line2 character varying(100),
    city character varying(100),
    usps_abbrev character(2),
    zip_code character varying(10),
    phone character varying(30),
    fax character varying(30),
    country_code character(2),
    url character varying(200),
    financing_policy character varying(4000),
    return_policy character varying(4000),
    price_guarantee_policy character varying(4000),
    delivery_policy character varying(4000),
    installation_policy character varying(4000),
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_retailer_locations OWNER TO evex;

--
-- Name: ec_retailer_locations_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_retailer_locations_audit (
    retailer_location_id integer,
    retailer_id integer,
    location_name character varying(300),
    primary_contact_name character varying(100),
    secondary_contact_name character varying(100),
    primary_contact_info character varying(4000),
    secondary_contact_info character varying(4000),
    line1 character varying(100),
    line2 character varying(100),
    city character varying(100),
    usps_abbrev character(2),
    zip_code character varying(10),
    phone character varying(30),
    fax character varying(30),
    country_code character(2),
    url character varying(200),
    financing_policy character varying(4000),
    return_policy character varying(4000),
    price_guarantee_policy character varying(4000),
    delivery_policy character varying(4000),
    installation_policy character varying(4000),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_retailer_locations_audit OWNER TO evex;

--
-- Name: ec_retailer_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_retailer_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_retailer_seq OWNER TO evex;

--
-- Name: ec_retailer_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_retailer_sequence AS
 SELECT nextval('public.ec_retailer_seq'::regclass) AS nextval;


ALTER TABLE public.ec_retailer_sequence OWNER TO evex;

--
-- Name: ec_retailers; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_retailers (
    retailer_id integer NOT NULL,
    retailer_name character varying(300),
    primary_contact_name character varying(100),
    secondary_contact_name character varying(100),
    primary_contact_info character varying(4000),
    secondary_contact_info character varying(4000),
    line1 character varying(100),
    line2 character varying(100),
    city character varying(100),
    usps_abbrev character(2),
    zip_code character varying(10),
    phone character varying(30),
    fax character varying(30),
    country_code character(2),
    reach character varying(15),
    url character varying(200),
    nexus_states character varying(200),
    financing_policy character varying(4000),
    return_policy character varying(4000),
    price_guarantee_policy character varying(4000),
    delivery_policy character varying(4000),
    installation_policy character varying(4000),
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL,
    CONSTRAINT ec_retailers_reach_check CHECK (((reach)::text = ANY (ARRAY[('national'::character varying)::text, ('local'::character varying)::text, ('international'::character varying)::text, ('regional'::character varying)::text, ('web'::character varying)::text])))
);


ALTER TABLE public.ec_retailers OWNER TO evex;

--
-- Name: ec_retailers_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_retailers_audit (
    retailer_id integer,
    retailer_name character varying(300),
    primary_contact_name character varying(100),
    secondary_contact_name character varying(100),
    primary_contact_info character varying(4000),
    secondary_contact_info character varying(4000),
    line1 character varying(100),
    line2 character varying(100),
    city character varying(100),
    usps_abbrev character(2),
    zip_code character varying(10),
    phone character varying(30),
    fax character varying(30),
    country_code character(2),
    reach character varying(15),
    url character varying(200),
    nexus_states character varying(200),
    financing_policy character varying(4000),
    return_policy character varying(4000),
    price_guarantee_policy character varying(4000),
    delivery_policy character varying(4000),
    installation_policy character varying(4000),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false,
    CONSTRAINT ec_retailers_audit_reach_check CHECK (((reach)::text = ANY (ARRAY[('national'::character varying)::text, ('local'::character varying)::text, ('international'::character varying)::text, ('regional'::character varying)::text, ('web'::character varying)::text])))
);


ALTER TABLE public.ec_retailers_audit OWNER TO evex;

--
-- Name: ec_sale_price_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_sale_price_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_sale_price_id_seq OWNER TO evex;

--
-- Name: ec_sale_price_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_sale_price_id_sequence AS
 SELECT nextval('public.ec_sale_price_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_sale_price_id_sequence OWNER TO evex;

--
-- Name: ec_sale_prices; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_sale_prices (
    sale_price_id integer NOT NULL,
    product_id integer NOT NULL,
    sale_price numeric,
    sale_begins timestamp with time zone NOT NULL,
    sale_ends timestamp with time zone NOT NULL,
    sale_name character varying(30),
    offer_code character varying(20),
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_sale_prices OWNER TO evex;

--
-- Name: ec_sale_prices_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_sale_prices_audit (
    sale_price_id integer,
    product_id integer,
    sale_price numeric,
    sale_begins timestamp with time zone,
    sale_ends timestamp with time zone,
    sale_name character varying(30),
    offer_code character varying(20),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_sale_prices_audit OWNER TO evex;

--
-- Name: ec_sale_prices_current; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_sale_prices_current AS
 SELECT ec_sale_prices.sale_price_id,
    ec_sale_prices.product_id,
    ec_sale_prices.sale_price,
    ec_sale_prices.sale_begins,
    ec_sale_prices.sale_ends,
    ec_sale_prices.sale_name,
    ec_sale_prices.offer_code,
    ec_sale_prices.last_modified,
    ec_sale_prices.last_modifying_user,
    ec_sale_prices.modified_ip_address
   FROM public.ec_sale_prices
  WHERE ((now() >= ec_sale_prices.sale_begins) AND (now() <= ec_sale_prices.sale_ends));


ALTER TABLE public.ec_sale_prices_current OWNER TO evex;

--
-- Name: ec_sales_tax_by_state; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_sales_tax_by_state (
    usps_abbrev character(2) NOT NULL,
    tax_rate numeric NOT NULL,
    shipping_p boolean NOT NULL,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_sales_tax_by_state OWNER TO evex;

--
-- Name: ec_sales_tax_by_state_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_sales_tax_by_state_audit (
    usps_abbrev character(2),
    tax_rate numeric,
    shipping_p boolean,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_sales_tax_by_state_audit OWNER TO evex;

--
-- Name: ec_shipment_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_shipment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_shipment_id_seq OWNER TO evex;

--
-- Name: ec_shipment_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_shipment_id_sequence AS
 SELECT nextval('public.ec_shipment_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_shipment_id_sequence OWNER TO evex;

--
-- Name: ec_shipments_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_shipments_audit (
    shipment_id integer,
    order_id integer,
    address_id integer,
    shipment_date timestamp with time zone,
    expected_arrival_date timestamp with time zone,
    carrier character varying(50),
    tracking_number character varying(24),
    actual_arrival_date timestamp with time zone,
    actual_arrival_detail character varying(4000),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_shipments_audit OWNER TO evex;

--
-- Name: ec_spam_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_spam_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_spam_id_seq OWNER TO evex;

--
-- Name: ec_spam_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_spam_id_sequence AS
 SELECT nextval('public.ec_spam_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_spam_id_sequence OWNER TO evex;

--
-- Name: ec_spam_log; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_spam_log (
    spam_id integer NOT NULL,
    spam_date timestamp with time zone,
    spam_text character varying(4000),
    mailing_list_category_id integer,
    mailing_list_subcategory_id integer,
    mailing_list_subsubcategory_id integer,
    user_class_id integer,
    product_id integer,
    last_visit_start_date timestamp with time zone,
    last_visit_end_date timestamp without time zone
);


ALTER TABLE public.ec_spam_log OWNER TO evex;

--
-- Name: ec_subcat_prod_map_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_subcat_prod_map_audit (
    product_id integer,
    subcategory_id integer,
    publisher_favorite_p boolean,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_subcat_prod_map_audit OWNER TO evex;

--
-- Name: ec_subcategories_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_subcategories_audit (
    subcategory_id integer,
    category_id integer,
    subcategory_name character varying(100),
    sort_key numeric,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_subcategories_audit OWNER TO evex;

--
-- Name: ec_subcategory_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_subcategory_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_subcategory_id_seq OWNER TO evex;

--
-- Name: ec_subcategory_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_subcategory_id_sequence AS
 SELECT nextval('public.ec_subcategory_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_subcategory_id_sequence OWNER TO evex;

--
-- Name: ec_subcategory_product_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_subcategory_product_map (
    product_id integer NOT NULL,
    subcategory_id integer NOT NULL,
    publisher_favorite_p boolean,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_subcategory_product_map OWNER TO evex;

--
-- Name: ec_subsubcat_prod_map_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_subsubcat_prod_map_audit (
    product_id integer,
    subsubcategory_id integer,
    publisher_favorite_p boolean,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_subsubcat_prod_map_audit OWNER TO evex;

--
-- Name: ec_subsubcategories_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_subsubcategories_audit (
    subsubcategory_id integer,
    subcategory_id integer,
    subsubcategory_name character varying(100),
    sort_key numeric,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_subsubcategories_audit OWNER TO evex;

--
-- Name: ec_subsubcategory_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_subsubcategory_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_subsubcategory_id_seq OWNER TO evex;

--
-- Name: ec_subsubcategory_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_subsubcategory_id_sequence AS
 SELECT nextval('public.ec_subsubcategory_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_subsubcategory_id_sequence OWNER TO evex;

--
-- Name: ec_subsubcategory_product_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_subsubcategory_product_map (
    product_id integer NOT NULL,
    subsubcategory_id integer NOT NULL,
    publisher_favorite_p boolean,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_subsubcategory_product_map OWNER TO evex;

--
-- Name: ec_template_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_template_id_seq
    START WITH 2
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_template_id_seq OWNER TO evex;

--
-- Name: ec_template_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_template_id_sequence AS
 SELECT nextval('public.ec_template_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_template_id_sequence OWNER TO evex;

--
-- Name: ec_templates; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_templates (
    template_id integer NOT NULL,
    template_name character varying(200),
    template character varying(4000),
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_templates OWNER TO evex;

--
-- Name: ec_templates_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_templates_audit (
    template_id integer,
    template_name character varying(200),
    template character varying(4000),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_templates_audit OWNER TO evex;

--
-- Name: ec_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_transaction_id_seq
    START WITH 4000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_transaction_id_seq OWNER TO evex;

--
-- Name: ec_transaction_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_transaction_id_sequence AS
 SELECT nextval('public.ec_transaction_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_transaction_id_sequence OWNER TO evex;

--
-- Name: ec_user_class_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_user_class_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_user_class_id_seq OWNER TO evex;

--
-- Name: ec_user_class_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_user_class_id_sequence AS
 SELECT nextval('public.ec_user_class_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_user_class_id_sequence OWNER TO evex;

--
-- Name: ec_user_class_user_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_user_class_user_map (
    user_id integer NOT NULL,
    user_class_id integer NOT NULL,
    user_class_approved_p boolean,
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_user_class_user_map OWNER TO evex;

--
-- Name: ec_user_class_user_map_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_user_class_user_map_audit (
    user_id integer,
    user_class_id integer,
    user_class_approved_p boolean,
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_user_class_user_map_audit OWNER TO evex;

--
-- Name: ec_user_classes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_user_classes (
    user_class_id integer NOT NULL,
    user_class_name character varying(200),
    last_modified timestamp with time zone NOT NULL,
    last_modifying_user integer NOT NULL,
    modified_ip_address character varying(20) NOT NULL
);


ALTER TABLE public.ec_user_classes OWNER TO evex;

--
-- Name: ec_user_classes_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_user_classes_audit (
    user_class_id integer,
    user_class_name character varying(200),
    last_modified timestamp with time zone,
    last_modifying_user integer,
    modified_ip_address character varying(20),
    delete_p boolean DEFAULT false
);


ALTER TABLE public.ec_user_classes_audit OWNER TO evex;

--
-- Name: ec_user_ident_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_user_ident_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_user_ident_id_seq OWNER TO evex;

--
-- Name: ec_user_ident_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_user_ident_id_sequence AS
 SELECT nextval('public.ec_user_ident_id_seq'::regclass) AS nextval;


ALTER TABLE public.ec_user_ident_id_sequence OWNER TO evex;

--
-- Name: ec_user_identification; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_user_identification (
    user_identification_id integer NOT NULL,
    date_added timestamp with time zone,
    user_id integer,
    email character varying(100),
    first_names character varying(100),
    last_name character varying(100),
    postal_code character varying(80),
    other_id_info character varying(2000)
);


ALTER TABLE public.ec_user_identification OWNER TO evex;

--
-- Name: ec_user_session_info; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_user_session_info (
    user_session_id integer NOT NULL,
    product_id integer,
    category_id integer,
    search_text character varying(200)
);


ALTER TABLE public.ec_user_session_info OWNER TO evex;

--
-- Name: ec_user_session_offer_codes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_user_session_offer_codes (
    user_session_id integer NOT NULL,
    product_id integer NOT NULL,
    offer_code character varying(20) NOT NULL
);


ALTER TABLE public.ec_user_session_offer_codes OWNER TO evex;

--
-- Name: ec_user_session_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ec_user_session_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ec_user_session_seq OWNER TO evex;

--
-- Name: ec_user_session_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ec_user_session_sequence AS
 SELECT nextval('public.ec_user_session_seq'::regclass) AS nextval;


ALTER TABLE public.ec_user_session_sequence OWNER TO evex;

--
-- Name: ec_user_sessions; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ec_user_sessions (
    user_session_id integer NOT NULL,
    user_id integer,
    ip_address character varying(20) NOT NULL,
    start_time timestamp with time zone,
    http_user_agent character varying(4000)
);


ALTER TABLE public.ec_user_sessions OWNER TO evex;

--
-- Name: ecds_alt_spelling_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_alt_spelling_map (
    context character varying(30) NOT NULL,
    alt_spelling character varying(200) NOT NULL,
    normalized character varying(200) NOT NULL
);


ALTER TABLE public.ecds_alt_spelling_map OWNER TO evex;

--
-- Name: ecds_categories; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_categories (
    cat_key character varying(300) NOT NULL,
    type character varying(80),
    url character varying(300),
    icon_html character varying(300),
    keywords character varying(4000),
    title character varying(300),
    description character varying(4000),
    website_url character varying(300),
    notes text
);


ALTER TABLE public.ecds_categories OWNER TO evex;

--
-- Name: ecds_categories_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_categories_map (
    category_id integer,
    subcategory_id integer,
    subsubcategory_id integer,
    cat_key character varying(300) NOT NULL
);


ALTER TABLE public.ecds_categories_map OWNER TO evex;

--
-- Name: ecds_object_templates_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_object_templates_map (
    object_id integer NOT NULL,
    template_id integer NOT NULL,
    template_parameters character varying(4000)
);


ALTER TABLE public.ecds_object_templates_map OWNER TO evex;

--
-- Name: ecds_process_control; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_process_control (
    process_ref character varying(48),
    okay_to_start character varying(1) DEFAULT 'f'::character varying,
    status text
);


ALTER TABLE public.ecds_process_control OWNER TO evex;

--
-- Name: ecds_product_id_site_url_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_product_id_site_url_map (
    site_url character varying(300) NOT NULL,
    product_id integer NOT NULL
);


ALTER TABLE public.ecds_product_id_site_url_map OWNER TO evex;

--
-- Name: ecds_templates; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_templates (
    template_id integer NOT NULL,
    package_id integer,
    template_type_id integer,
    template_name character varying(200),
    template text
);


ALTER TABLE public.ecds_templates OWNER TO evex;

--
-- Name: ecds_url_cache_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_url_cache_map (
    url character varying(300) NOT NULL,
    cache_filepath character varying(200) NOT NULL,
    last_update timestamp with time zone NOT NULL,
    flags character varying(100)
);


ALTER TABLE public.ecds_url_cache_map OWNER TO evex;

--
-- Name: ecds_vendors; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ecds_vendors (
    abbrev character varying(16),
    title character varying(100),
    terms integer DEFAULT 0,
    taxincluded character varying(1) DEFAULT 'f'::character varying,
    vendornumber character varying(32),
    gifi_accno character varying(30),
    business_id integer,
    taxnumber character varying(32),
    sic_code character varying(15),
    discount numeric,
    creditlimit numeric DEFAULT 0,
    iban character varying(34),
    bic character varying(11),
    employee_id integer,
    language_code character varying(6),
    pricegroup_id integer,
    curr character(3),
    startdate date,
    enddate date
);


ALTER TABLE public.ecds_vendors OWNER TO evex;

--
-- Name: ee_bookingsx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_bookingsx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    ee_bookings.booking_id,
    ee_bookings.product_id
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.ee_bookings
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = ee_bookings.booking_id));


ALTER TABLE public.ee_bookingsx OWNER TO evex;

--
-- Name: ee_item_offer_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_item_offer_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_item_offer_seq OWNER TO evex;

--
-- Name: ee_item_offers; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_item_offers (
    offer_id integer NOT NULL,
    item_id integer,
    photo_id integer,
    unit character varying(50),
    discount integer,
    price numeric
);


ALTER TABLE public.ee_item_offers OWNER TO evex;

--
-- Name: ee_item_policies; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_item_policies (
    policy_id integer NOT NULL,
    category_id integer,
    item_id integer,
    description text
);


ALTER TABLE public.ee_item_policies OWNER TO evex;

--
-- Name: ee_item_policy_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_item_policy_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_item_policy_seq OWNER TO evex;

--
-- Name: ee_item_sale_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_item_sale_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_item_sale_seq OWNER TO evex;

--
-- Name: ee_item_sales; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_item_sales (
    sale_id integer NOT NULL,
    item_id integer,
    photo_id integer,
    price numeric,
    unit integer
);


ALTER TABLE public.ee_item_sales OWNER TO evex;

--
-- Name: ee_itemsx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_itemsx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    ee_items.ee_item_id,
    ee_items.cnpj,
    ee_items.category_id,
    ee_items.contract_p,
    ee_items.url,
    ee_items.approved_p,
    ee_items.contract_date,
    ee_items.contract_ip,
    ee_items.contract_cpf,
    ee_items.contract_user,
    ee_items.phonenumber,
    ee_items.purchase_plan,
    ee_items.contact_person,
    ee_items.contact_email,
    ee_items.promocode
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.ee_items
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = ee_items.ee_item_id));


ALTER TABLE public.ee_itemsx OWNER TO evex;

--
-- Name: ee_leads; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_leads (
    lead_id integer NOT NULL,
    object_id integer,
    creation_date timestamp with time zone,
    creation_ip character varying,
    creation_user integer,
    counter bigint
);


ALTER TABLE public.ee_leads OWNER TO evex;

--
-- Name: ee_leads_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_leads_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_leads_seq OWNER TO evex;

--
-- Name: ee_object_category_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_object_category_map (
    map_id integer NOT NULL,
    category_id integer,
    object_id integer,
    value character varying
);


ALTER TABLE public.ee_object_category_map OWNER TO evex;

--
-- Name: ee_object_category_map_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_object_category_map_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_object_category_map_seq OWNER TO evex;

--
-- Name: ee_proposals_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_proposals_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_proposals_seq OWNER TO evex;

--
-- Name: ee_proposalsx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_proposalsx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    ee_proposals.proposal_id,
    ee_proposals.event_id,
    ee_proposals.product_id,
    ee_proposals.status,
    ee_proposals.budget,
    ee_proposals.attachment
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.ee_proposals
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = ee_proposals.proposal_id));


ALTER TABLE public.ee_proposalsx OWNER TO evex;

--
-- Name: ee_qa_item_category_score; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_qa_item_category_score (
    item_id integer NOT NULL,
    category_id integer NOT NULL,
    score numeric
);


ALTER TABLE public.ee_qa_item_category_score OWNER TO evex;

--
-- Name: ee_qa_item_category_score_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_qa_item_category_score_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_qa_item_category_score_seq OWNER TO evex;

--
-- Name: ee_qa_item_info; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_qa_item_info (
    item_id integer NOT NULL,
    category_id integer,
    cost numeric,
    vas numeric,
    score numeric,
    price_p boolean,
    seg_ver numeric
);


ALTER TABLE public.ee_qa_item_info OWNER TO evex;

--
-- Name: ee_qa_item_info_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_qa_item_info_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_qa_item_info_seq OWNER TO evex;

--
-- Name: ee_rooms; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_rooms (
    room_id integer NOT NULL
);


ALTER TABLE public.ee_rooms OWNER TO evex;

--
-- Name: ee_servicesx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_servicesx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    ee_services.service_id,
    ee_services.cnpj,
    ee_services.category_id,
    ee_services.contract_p,
    ee_services.contract_date,
    ee_services.contract_ip,
    ee_services.contract_cpf,
    ee_services.contract_user,
    ee_services.url,
    ee_services.phonenumber,
    ee_services.contact_person,
    ee_services.contact_email,
    ee_services.purchase_plan
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.ee_services
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = ee_services.service_id));


ALTER TABLE public.ee_servicesx OWNER TO evex;

--
-- Name: ee_venuesx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.ee_venuesx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    ee_venues.venue_id,
    ee_venues.cnpj,
    ee_venues.category_id,
    ee_venues.contract_p,
    ee_venues.contract_date,
    ee_venues.contract_ip,
    ee_venues.contract_cpf,
    ee_venues.contract_user,
    ee_venues.url,
    ee_venues.phonenumber,
    ee_venues.contact_person,
    ee_venues.contact_email,
    ee_venues.purchase_plan
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.ee_venues
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = ee_venues.venue_id));


ALTER TABLE public.ee_venuesx OWNER TO evex;

--
-- Name: ee_wish_list_items; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ee_wish_list_items (
    wishlist_id integer NOT NULL,
    item_id integer,
    user_id integer
);


ALTER TABLE public.ee_wish_list_items OWNER TO evex;

--
-- Name: ee_wishlist_items_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.ee_wishlist_items_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ee_wishlist_items_seq OWNER TO evex;

--
-- Name: email_images; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.email_images (
    user_id integer NOT NULL
);


ALTER TABLE public.email_images OWNER TO evex;

--
-- Name: enabled_locales; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.enabled_locales AS
 SELECT ad_locales.locale,
    ad_locales.language,
    ad_locales.country,
    ad_locales.variant,
    ad_locales.label,
    ad_locales.nls_language,
    ad_locales.nls_territory,
    ad_locales.nls_charset,
    ad_locales.mime_charset,
    ad_locales.default_p,
    ad_locales.enabled_p
   FROM public.ad_locales
  WHERE (ad_locales.enabled_p = true);


ALTER TABLE public.enabled_locales OWNER TO evex;

--
-- Name: ezic_gateway_result_log; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.ezic_gateway_result_log (
    transaction_id character varying(20) NOT NULL,
    txn_attempted_type character varying(18),
    txn_attempted_time timestamp with time zone,
    response character varying(400),
    response_code character varying(2),
    response_reason_code character varying(2),
    response_reason_text character varying(100),
    auth_code character varying(8),
    avs_code character varying(12),
    cvv2_code character varying(2),
    ticket_code character varying(40),
    amount numeric NOT NULL
);


ALTER TABLE public.ezic_gateway_result_log OWNER TO evex;

--
-- Name: faq_q_and_as; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.faq_q_and_as (
    entry_id integer NOT NULL,
    faq_id integer NOT NULL,
    question character varying(4000) NOT NULL,
    answer character varying(4000) NOT NULL,
    sort_key integer NOT NULL
);


ALTER TABLE public.faq_q_and_as OWNER TO evex;

--
-- Name: faqs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.faqs (
    faq_id integer NOT NULL,
    faq_name character varying(250) NOT NULL,
    separate_p boolean,
    disabled_p character(1) DEFAULT 'f'::bpchar,
    CONSTRAINT faqs_disabled_p_check CHECK ((disabled_p = ANY (ARRAY['f'::bpchar, 't'::bpchar]))),
    CONSTRAINT faqs_separate_p_check CHECK ((separate_p = ANY (ARRAY[false, true])))
);


ALTER TABLE public.faqs OWNER TO evex;

--
-- Name: file_storage_object_tx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.file_storage_object_tx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    file_storage_object_t.file_storage_object_id
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.file_storage_object_t
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = file_storage_object_t.file_storage_object_id));


ALTER TABLE public.file_storage_object_tx OWNER TO evex;

--
-- Name: fs_files; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.fs_files AS
 SELECT cr_revisions.item_id AS file_id,
    cr_revisions.revision_id AS live_revision,
    cr_revisions.mime_type AS type,
    cr_revisions.title AS file_upload_name,
    cr_revisions.content_length AS content_size,
    cr_items.name,
    acs_objects.last_modified,
    cr_items.parent_id,
    cr_items.name AS key
   FROM public.cr_revisions,
    public.cr_items,
    public.acs_objects
  WHERE ((cr_revisions.revision_id = cr_items.live_revision) AND (cr_revisions.item_id = cr_items.item_id) AND ((cr_items.content_type)::text = 'file_storage_object'::text) AND (cr_revisions.revision_id = acs_objects.object_id));


ALTER TABLE public.fs_files OWNER TO evex;

--
-- Name: fs_folders; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.fs_folders AS
 SELECT cr_folders.folder_id,
    cr_folders.label AS name,
    acs_objects.last_modified,
    ( SELECT count(*) AS count
           FROM public.cr_items ci2
          WHERE (((ci2.content_type)::text <> 'content_folder'::text) AND ((ci2.tree_sortkey >= ci.tree_sortkey) AND (ci2.tree_sortkey <= public.tree_right(ci.tree_sortkey))))) AS content_size,
    ci.parent_id,
    ci.name AS key
   FROM public.cr_folders,
    public.cr_items ci,
    public.acs_objects
  WHERE ((cr_folders.folder_id = ci.item_id) AND (cr_folders.folder_id = acs_objects.object_id));


ALTER TABLE public.fs_folders OWNER TO evex;

--
-- Name: fs_objects; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.fs_objects AS
 SELECT cr_items.item_id AS object_id,
    cr_items.live_revision,
        CASE
            WHEN ((cr_items.content_type)::text = 'content_folder'::text) THEN 'folder'::character varying
            WHEN ((cr_items.content_type)::text = 'content_extlink'::text) THEN 'url'::character varying
            WHEN ((cr_items.content_type)::text = 'content_symlink'::text) THEN 'symlink'::character varying
            ELSE cr_revisions.mime_type
        END AS type,
        CASE
            WHEN ((cr_items.content_type)::text = 'content_folder'::text) THEN ( SELECT count(*) AS count
               FROM public.cr_items ci2
              WHERE (((ci2.content_type)::text <> 'content_folder'::text) AND ((ci2.tree_sortkey >= cr_items.tree_sortkey) AND (ci2.tree_sortkey <= public.tree_right(cr_items.tree_sortkey)))))
            ELSE (cr_revisions.content_length)::bigint
        END AS content_size,
        CASE
            WHEN ((cr_items.content_type)::text = 'content_folder'::text) THEN cr_folders.label
            WHEN ((cr_items.content_type)::text = 'content_extlink'::text) THEN cr_extlinks.label
            ELSE cr_items.name
        END AS name,
    cr_items.name AS file_upload_name,
    cr_revisions.title,
    cr_revisions.mime_type,
    acs_objects.last_modified,
    cr_extlinks.url,
    cr_items.parent_id,
    cr_items.name AS key,
        CASE
            WHEN ((cr_items.content_type)::text = 'content_folder'::text) THEN 0
            ELSE 1
        END AS sort_key,
    cr_mime_types.label AS pretty_type
   FROM (((((public.cr_items
     LEFT JOIN public.cr_extlinks ON ((cr_items.item_id = cr_extlinks.extlink_id)))
     LEFT JOIN public.cr_folders ON ((cr_items.item_id = cr_folders.folder_id)))
     LEFT JOIN public.cr_revisions ON ((cr_items.live_revision = cr_revisions.revision_id)))
     LEFT JOIN public.cr_mime_types ON (((cr_revisions.mime_type)::text = (cr_mime_types.mime_type)::text)))
     JOIN public.acs_objects ON ((cr_items.item_id = acs_objects.object_id)));


ALTER TABLE public.fs_objects OWNER TO evex;

--
-- Name: fs_root_folders; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.fs_root_folders (
    package_id integer NOT NULL,
    folder_id integer
);


ALTER TABLE public.fs_root_folders OWNER TO evex;

--
-- Name: fs_rss_subscrs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.fs_rss_subscrs (
    subscr_id integer NOT NULL,
    folder_id integer NOT NULL,
    short_name character varying(80) NOT NULL,
    feed_title character varying(200) NOT NULL,
    max_items integer DEFAULT 15 NOT NULL,
    descend_p boolean DEFAULT true NOT NULL,
    include_revisions_p boolean DEFAULT false NOT NULL,
    enclosure_match_patterns character varying(200)
);


ALTER TABLE public.fs_rss_subscrs OWNER TO evex;

--
-- Name: fs_urls_full; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.fs_urls_full AS
 SELECT cr_extlinks.extlink_id AS url_id,
    cr_extlinks.url,
    cr_items.parent_id AS folder_id,
    cr_extlinks.label AS name,
    cr_extlinks.description,
    acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title,
    acs_objects.package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip
   FROM public.cr_extlinks,
    public.cr_items,
    public.acs_objects
  WHERE ((cr_extlinks.extlink_id = cr_items.item_id) AND (cr_items.item_id = acs_objects.object_id));


ALTER TABLE public.fs_urls_full OWNER TO evex;

--
-- Name: general_comments; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.general_comments (
    comment_id integer NOT NULL,
    object_id integer,
    category character varying(1000)
);


ALTER TABLE public.general_comments OWNER TO evex;

--
-- Name: TABLE general_comments; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.general_comments IS '
    Extends the acs_messages table to hold item level data.
';


--
-- Name: COLUMN general_comments.object_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.general_comments.object_id IS '
    The id of the object to associate message with
';


--
-- Name: COLUMN general_comments.category; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.general_comments.category IS '
    This feature is not complete. The purpose is to allow separation of 
    comments into categories.  
';


--
-- Name: general_objects; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.general_objects (
    object_id integer NOT NULL,
    on_which_table character varying(30) NOT NULL,
    on_what_id integer NOT NULL
);


ALTER TABLE public.general_objects OWNER TO evex;

--
-- Name: TABLE general_objects; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.general_objects IS '
 This table can be used to treat non-acs_objects as acs_objects for
 purposes of access control, categorization, etc.
';


--
-- Name: group_approved_member_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.group_approved_member_map AS
 SELECT gm.group_id,
    gm.member_id,
    gm.rel_id,
    gm.container_id,
    gm.rel_type
   FROM public.group_member_map gm,
    public.membership_rels mr
  WHERE ((gm.rel_id = mr.rel_id) AND ((mr.member_state)::text = 'approved'::text));


ALTER TABLE public.group_approved_member_map OWNER TO evex;

--
-- Name: group_component_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.group_component_map AS
 SELECT group_element_map.group_id,
    group_element_map.element_id AS component_id,
    group_element_map.rel_id,
    group_element_map.container_id,
    group_element_map.rel_type
   FROM public.group_element_map
  WHERE ((group_element_map.ancestor_rel_type)::text = 'composition_rel'::text);


ALTER TABLE public.group_component_map OWNER TO evex;

--
-- Name: group_component_index; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.group_component_index AS
 SELECT group_component_map.group_id,
    group_component_map.component_id,
    group_component_map.rel_id,
    group_component_map.container_id,
    group_component_map.rel_type
   FROM public.group_component_map;


ALTER TABLE public.group_component_index OWNER TO evex;

--
-- Name: group_distinct_member_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.group_distinct_member_map AS
 SELECT DISTINCT group_approved_member_map.group_id,
    group_approved_member_map.member_id
   FROM public.group_approved_member_map;


ALTER TABLE public.group_distinct_member_map OWNER TO evex;

--
-- Name: group_member_index; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.group_member_index AS
 SELECT group_member_map.group_id,
    group_member_map.member_id,
    group_member_map.rel_id,
    group_member_map.container_id,
    group_member_map.rel_type
   FROM public.group_member_map;


ALTER TABLE public.group_member_index OWNER TO evex;

--
-- Name: groups; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.groups (
    group_id integer NOT NULL,
    group_name character varying(1000) NOT NULL,
    join_policy character varying(30) DEFAULT 'open'::character varying NOT NULL,
    description character varying(4000),
    CONSTRAINT groups_join_policy_ck CHECK (((join_policy)::text = ANY (ARRAY[('open'::character varying)::text, ('needs approval'::character varying)::text, ('closed'::character varying)::text])))
);


ALTER TABLE public.groups OWNER TO evex;

--
-- Name: group_rel_type_combos; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.group_rel_type_combos AS
 SELECT groups.group_id,
    comp_or_member_rel_types.rel_type
   FROM public.groups,
    public.comp_or_member_rel_types;


ALTER TABLE public.group_rel_type_combos OWNER TO evex;

--
-- Name: group_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.group_rels (
    group_rel_id integer NOT NULL,
    rel_type character varying(1000) NOT NULL,
    group_id integer NOT NULL
);


ALTER TABLE public.group_rels OWNER TO evex;

--
-- Name: TABLE group_rels; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.group_rels IS '
  Stores the relationship types available for use by each group. Only
  relationship types in this table are offered for adding
  relations. Note that there is no restriction that says groups can
  only have relationship types specified for their group type. The
  <code>group_type_rels</code> table just stores defaults for groups
  of a new type.
';


--
-- Name: group_type_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.group_type_rels (
    group_rel_type_id integer NOT NULL,
    rel_type character varying(1000) NOT NULL,
    group_type character varying(1000) NOT NULL
);


ALTER TABLE public.group_type_rels OWNER TO evex;

--
-- Name: TABLE group_type_rels; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.group_type_rels IS '
  Stores the default relationship types available for use by groups of
  a given type. We May want to generalize this table to object_types and
  put it in the relationships sql file, though there is no need to do so
  right now.
';


--
-- Name: group_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.group_types (
    group_type character varying(1000) NOT NULL,
    default_join_policy character varying(30) DEFAULT 'open'::character varying NOT NULL,
    CONSTRAINT group_types_join_dft_policy_ck CHECK (((default_join_policy)::text = ANY (ARRAY[('open'::character varying)::text, ('needs approval'::character varying)::text, ('closed'::character varying)::text])))
);


ALTER TABLE public.group_types OWNER TO evex;

--
-- Name: TABLE group_types; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.group_types IS '
 This table holds additional knowledge level attributes for the
 group type and its subtypes.
';


--
-- Name: host_node_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.host_node_map (
    host character varying(200) NOT NULL,
    node_id integer
);


ALTER TABLE public.host_node_map OWNER TO evex;

--
-- Name: im_categories; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_categories (
    category_id integer NOT NULL,
    category character varying(50) NOT NULL,
    category_description text,
    category_type character varying(50),
    category_gif character varying(100) DEFAULT 'category'::character varying,
    enabled_p character(1) DEFAULT 't'::bpchar,
    parent_only_p character(1) DEFAULT 'f'::bpchar,
    sort_order integer DEFAULT 0,
    aux_int1 integer,
    aux_int2 integer,
    aux_string1 text,
    aux_string2 text,
    visible_tcl text,
    CONSTRAINT im_enabled_p_ck CHECK ((enabled_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar]))),
    CONSTRAINT im_parent_only_p_ck CHECK ((parent_only_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_categories OWNER TO evex;

--
-- Name: im_annual_revenue; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_annual_revenue AS
 SELECT im_categories.category_id AS revenue_id,
    im_categories.category AS revenue
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Annual Revenue'::text);


ALTER TABLE public.im_annual_revenue OWNER TO evex;

--
-- Name: im_biz_object_groups; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_biz_object_groups (
    group_id integer NOT NULL,
    biz_object_id integer
);


ALTER TABLE public.im_biz_object_groups OWNER TO evex;

--
-- Name: im_biz_object_members; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_biz_object_members (
    rel_id integer NOT NULL,
    object_role_id integer NOT NULL,
    percentage numeric(8,2) DEFAULT 100,
    skill_profile_rel_id integer
);


ALTER TABLE public.im_biz_object_members OWNER TO evex;

--
-- Name: im_biz_object_role; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_biz_object_role AS
 SELECT im_categories.category_id AS role_id,
    im_categories.category AS role
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Biz Object Role'::text);


ALTER TABLE public.im_biz_object_role OWNER TO evex;

--
-- Name: im_biz_object_role_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_biz_object_role_map (
    acs_object_type character varying(1000),
    object_type_id integer,
    object_role_id integer
);


ALTER TABLE public.im_biz_object_role_map OWNER TO evex;

--
-- Name: im_biz_object_tree_status; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_biz_object_tree_status (
    object_id integer NOT NULL,
    user_id integer NOT NULL,
    page_url text NOT NULL,
    open_p character(1),
    last_modified timestamp with time zone,
    CONSTRAINT im_biz_object_tree_status_open_ck CHECK (((open_p = 'o'::bpchar) OR (open_p = 'c'::bpchar)))
);


ALTER TABLE public.im_biz_object_tree_status OWNER TO evex;

--
-- Name: im_biz_object_urls; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_biz_object_urls (
    object_type character varying(1000) NOT NULL,
    url_type character varying(1000) NOT NULL,
    url text,
    CONSTRAINT im_biz_obj_urls_url_type_ck CHECK (((url_type)::text = ANY (ARRAY[('view'::character varying)::text, ('edit'::character varying)::text])))
);


ALTER TABLE public.im_biz_object_urls OWNER TO evex;

--
-- Name: im_biz_objects; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_biz_objects (
    object_id integer NOT NULL,
    lock_user integer,
    lock_date timestamp with time zone,
    lock_ip text
);


ALTER TABLE public.im_biz_objects OWNER TO evex;

--
-- Name: im_categories_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.im_categories_seq
    START WITH 10000000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.im_categories_seq OWNER TO evex;

--
-- Name: im_category_hierarchy; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_category_hierarchy (
    parent_id integer,
    child_id integer
);


ALTER TABLE public.im_category_hierarchy OWNER TO evex;

--
-- Name: im_companies; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_companies (
    company_id integer NOT NULL,
    company_name character varying(1000) NOT NULL,
    company_path character varying(100) NOT NULL,
    main_office_id integer NOT NULL,
    deleted_p character(1) DEFAULT 'f'::bpchar,
    company_status_id integer NOT NULL,
    company_type_id integer NOT NULL,
    crm_status_id integer,
    primary_contact_id integer,
    accounting_contact_id integer,
    note text,
    referral_source text,
    annual_revenue_id integer,
    status_modification_date date,
    old_company_status_id integer,
    billable_p character(1) DEFAULT 'f'::bpchar,
    site_concept character varying(100),
    manager_id integer,
    contract_value integer,
    start_date date,
    vat_number character varying(100),
    default_vat numeric(12,1) DEFAULT 0,
    default_tax numeric(12,1) DEFAULT 0,
    default_payment_days integer,
    default_payment_method_id integer,
    default_invoice_template_id integer,
    default_quote_template_id integer,
    default_delnote_template_id integer,
    default_bill_template_id integer,
    default_po_template_id integer,
    CONSTRAINT im_companies_billable_p_ck CHECK ((billable_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar]))),
    CONSTRAINT im_companies_deleted_p CHECK ((deleted_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_companies OWNER TO evex;

--
-- Name: im_company_employee_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_company_employee_rels (
    employee_rel_id integer NOT NULL
);


ALTER TABLE public.im_company_employee_rels OWNER TO evex;

--
-- Name: im_company_status; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_company_status AS
 SELECT im_categories.category_id AS company_status_id,
    im_categories.category AS company_status
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Company Status'::text);


ALTER TABLE public.im_company_status OWNER TO evex;

--
-- Name: im_company_types; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_company_types AS
 SELECT im_categories.category_id AS company_type_id,
    im_categories.category AS company_type
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Company Type'::text);


ALTER TABLE public.im_company_types OWNER TO evex;

--
-- Name: im_component_plugin_user_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_component_plugin_user_map (
    plugin_id integer NOT NULL,
    user_id integer NOT NULL,
    sort_order integer NOT NULL,
    minimized_p character(1) DEFAULT 'f'::bpchar,
    location character varying(100) NOT NULL,
    CONSTRAINT im_comp_plugin_user_map_min_p_ck CHECK ((minimized_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_component_plugin_user_map OWNER TO evex;

--
-- Name: TABLE im_component_plugin_user_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.im_component_plugin_user_map IS '
 This table maps Component Plugins to particular users,
 effectively allowing users to customize their GUI
 layout.
';


--
-- Name: im_component_plugins; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_component_plugins (
    plugin_id integer NOT NULL,
    plugin_name character varying(200) NOT NULL,
    package_name character varying(200) NOT NULL,
    sort_order integer NOT NULL,
    view_name character varying(100) DEFAULT NULL::character varying,
    page_url character varying(200) NOT NULL,
    location character varying(100) NOT NULL,
    title_tcl text,
    menu_name character varying(50) DEFAULT NULL::character varying,
    menu_sort_order integer DEFAULT 0 NOT NULL,
    component_tcl text,
    enabled_p character(1) DEFAULT 't'::bpchar,
    CONSTRAINT im_comp_plugin_enabled_ck CHECK ((enabled_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_component_plugins OWNER TO evex;

--
-- Name: TABLE im_component_plugins; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.im_component_plugins IS '
 Components Plugins are handeled in the database in order to allow
 customizations to survive system updates.
';


--
-- Name: im_component_plugin_user_map_all; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_component_plugin_user_map_all AS
 SELECT c.plugin_id,
    c.sort_order,
    c.location,
    NULL::integer AS user_id
   FROM public.im_component_plugins c
UNION
 SELECT m.plugin_id,
    m.sort_order,
    m.location,
    m.user_id
   FROM public.im_component_plugin_user_map m;


ALTER TABLE public.im_component_plugin_user_map_all OWNER TO evex;

--
-- Name: im_dynfield_attr_multi_value; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_attr_multi_value (
    attribute_id integer NOT NULL,
    object_id integer NOT NULL,
    value text,
    sort_order integer
);


ALTER TABLE public.im_dynfield_attr_multi_value OWNER TO evex;

--
-- Name: im_dynfield_attributes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_attributes (
    attribute_id integer NOT NULL,
    acs_attribute_id integer NOT NULL,
    widget_name text NOT NULL,
    already_existed_p character(1) DEFAULT 't'::bpchar NOT NULL,
    deprecated_p character(1) DEFAULT 'f'::bpchar NOT NULL,
    include_in_search_p character(1) DEFAULT 'f'::bpchar,
    also_hard_coded_p character(1) DEFAULT 'f'::bpchar,
    CONSTRAINT im_dynfield_attributes_also_hard_coded_ch CHECK ((also_hard_coded_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar]))),
    CONSTRAINT im_dynfield_attributes_search_ch CHECK ((include_in_search_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_dynfield_attributes OWNER TO evex;

--
-- Name: TABLE im_dynfield_attributes; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.im_dynfield_attributes IS 'Contains additional information for an acs_attribute like the widget to be used. The other attributes are mainly for backwards compatibility. Note that dynfield_attributes are acs_objects in contrast to acs_attributes which are NOT acs_objects (see acs_attributes for this)';


--
-- Name: COLUMN im_dynfield_attributes.attribute_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_attributes.attribute_id IS 'This column should be called dynfield_id. It is the internal dynfield_id (an object_id) is referenced by the other tables in dynfields to provide the connection between the acs_attribute_id and the display logic of the dynfield';


--
-- Name: COLUMN im_dynfield_attributes.acs_attribute_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_attributes.acs_attribute_id IS 'This references the attribute_id from acs_attributes. It is used to connect an acs_attribute with the display_logic';


--
-- Name: im_dynfield_cat_multi_value; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_cat_multi_value (
    attribute_id integer NOT NULL,
    object_id integer NOT NULL,
    category_id integer NOT NULL
);


ALTER TABLE public.im_dynfield_cat_multi_value OWNER TO evex;

--
-- Name: im_dynfield_layout; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_layout (
    attribute_id integer NOT NULL,
    page_url text NOT NULL,
    pos_x integer,
    pos_y integer,
    size_x integer,
    size_y integer,
    label_style character varying(15) DEFAULT 'plain'::character varying NOT NULL,
    div_class text,
    sort_key integer,
    CONSTRAINT im_dynfield_label_style_ck CHECK (((label_style)::text = ANY (ARRAY[('plain'::character varying)::text, ('table'::character varying)::text, ('div_absolute'::character varying)::text, ('div_relative'::character varying)::text, ('div'::character varying)::text, ('adp'::character varying)::text])))
);


ALTER TABLE public.im_dynfield_layout OWNER TO evex;

--
-- Name: TABLE im_dynfield_layout; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.im_dynfield_layout IS 'This table is used for providing positioning (layout) information of an attribute when being displayed.';


--
-- Name: COLUMN im_dynfield_layout.attribute_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_layout.attribute_id IS 'This is the dynfield_id which references im_dynfield_attributes.';


--
-- Name: COLUMN im_dynfield_layout.page_url; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_layout.page_url IS 'The page_url is the identified which groups the attributes together on a single page. The idea is that you can have a different layout of the attributes depending e.g. if you display the form (which would be displayed like a normal ad_form, where you just need the pos_y to define the order of attributes) and a page to display the attribute values, which could be a table with two columns where you would define which attribute will be displayed on what column in the table (using pos_y). The ''default'' page_url is the standard being used when no other page_url is specified.';


--
-- Name: COLUMN im_dynfield_layout.pos_x; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_layout.pos_x IS 'pos_x defines in which column in a table layout you will find the attribute rendered.';


--
-- Name: COLUMN im_dynfield_layout.pos_y; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_layout.pos_y IS 'pos_y could also be labelled ''sort_order'', but defines the row coordinate in a table layout where the attribute is rendered. By default im_dynfields supports only one_column which is why the entry form at attribute-new.tcl provides a possibility to enter pos_y for sorting';


--
-- Name: COLUMN im_dynfield_layout.label_style; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_layout.label_style IS ' the style in which the label (attribute_name) is presented in conjunction with the attribute''s value / form_widget. Default is ''table'' which means the label is in column 1 and the value / form_widget is in column 2. Most pages in ]project-open[ don''t bother looking at im_dynfield_layout and just use a normal ''table'' layout. This is changing with the advent of ExtJS driven Forms.';


--
-- Name: COLUMN im_dynfield_layout.div_class; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_layout.div_class IS 'This is the class information which you can pass onto the renderer to override the the standard CSS for this widget. Not in use in any ]project-open[ application as of beginning of 2011';


--
-- Name: COLUMN im_dynfield_layout.sort_key; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_layout.sort_key IS 'This is the sorting key for attributes which have a multiple choice widget like combo_box (select) or radio/ checkboxes. This allows you to differentiate if you would like to sort by value or by name. Not in use, all applications default to sort by name as of 2011';


--
-- Name: im_dynfield_layout_pages; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_layout_pages (
    page_url text NOT NULL,
    object_type character varying(100) NOT NULL,
    layout_type character varying(15) NOT NULL,
    table_height integer,
    table_width integer,
    adp_file text,
    default_p character(1) DEFAULT 'f'::bpchar NOT NULL,
    CONSTRAINT im_dynfield_layout_default_ck CHECK ((default_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar]))),
    CONSTRAINT im_dynfield_layout_type_ck CHECK (((layout_type)::text = ANY (ARRAY[('absolute'::character varying)::text, ('relative'::character varying)::text, ('table'::character varying)::text, ('div_absolute'::character varying)::text, ('div_relative'::character varying)::text, ('adp'::character varying)::text])))
);


ALTER TABLE public.im_dynfield_layout_pages OWNER TO evex;

--
-- Name: im_dynfield_page_fields; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_page_fields (
    field_id integer NOT NULL,
    page_id integer NOT NULL,
    attribute_id integer NOT NULL,
    field_status_id integer,
    field_type_id integer,
    pos_x integer,
    pos_y integer,
    size_x integer,
    size_y integer,
    label_style character varying(15) DEFAULT 'table'::character varying NOT NULL,
    div_class character varying(400),
    sort_key integer,
    CONSTRAINT im_dynfield_label_style_ck CHECK (((label_style)::text = ANY (ARRAY[('table'::character varying)::text, ('div_absolute'::character varying)::text, ('div_relative'::character varying)::text, ('div'::character varying)::text, ('adp'::character varying)::text])))
);


ALTER TABLE public.im_dynfield_page_fields OWNER TO evex;

--
-- Name: im_dynfield_pages; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_pages (
    page_id integer NOT NULL,
    object_type character varying(100) NOT NULL,
    page_status_id integer,
    page_type_id integer,
    page_url character varying(1000) NOT NULL,
    workflow_key character varying(100),
    transition_key character varying(100),
    layout_type character varying(15) NOT NULL,
    table_height integer,
    table_width integer,
    adp_file character varying(400),
    default_p character(1) DEFAULT 'f'::bpchar NOT NULL,
    CONSTRAINT im_dynfield_layout_default_ck CHECK ((default_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar]))),
    CONSTRAINT im_dynfield_layout_type_ck CHECK (((layout_type)::text = ANY (ARRAY[('absolute'::character varying)::text, ('relative'::character varying)::text, ('table'::character varying)::text, ('div_absolute'::character varying)::text, ('div_relative'::character varying)::text, ('adp'::character varying)::text])))
);


ALTER TABLE public.im_dynfield_pages OWNER TO evex;

--
-- Name: im_dynfield_type_attribute_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_type_attribute_map (
    attribute_id integer,
    object_type_id integer NOT NULL,
    display_mode character varying(10) NOT NULL,
    help_text text,
    section_heading text,
    default_value text,
    required_p character(1),
    CONSTRAINT im_dynfield_type_attr_map_dmode_ck CHECK (((display_mode)::text = ANY (ARRAY[('edit'::character varying)::text, ('display'::character varying)::text, ('none'::character varying)::text])))
);


ALTER TABLE public.im_dynfield_type_attribute_map OWNER TO evex;

--
-- Name: TABLE im_dynfield_type_attribute_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.im_dynfield_type_attribute_map IS 'This table defines under which conditions an attribute is to be rendered. The condition is determined by the object_type_id, which is a category_id. This category_id is of the category_type which is defined as ''type_category_type'' for the object_type of the attribute. The object_type ''im_projects'' has a type_category_type in acs_object_types of ''Intranet Project Type'' which is the category_type (in im_categories) that contains all the category_ids which can be used to define conditions in the way of object_type_id.';


--
-- Name: COLUMN im_dynfield_type_attribute_map.attribute_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_type_attribute_map.attribute_id IS 'This is the dynfield_id from im_dynfield_attributes which identifies the attribute. It is NOT an attribute_id from acs_attributes.';


--
-- Name: COLUMN im_dynfield_type_attribute_map.object_type_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_type_attribute_map.object_type_id IS 'This is the conditions identifier. This identifier is object specific, so if we take Projects as an example again, the condition is defined by the object''s type_id. In the case of Projects, this is stored in im_projects.project_type_id (see acs_object_types.type_column for more). When an object (e.g. Project) is displayed, the system takes the project_type_id and looks up in type_attribute_map how the attributes for the object_type ''im_project'' are to be treated.';


--
-- Name: COLUMN im_dynfield_type_attribute_map.display_mode; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_type_attribute_map.display_mode IS 'The display mode defining the mode in which the attribute is to be displayed. ''edit'' means, it can be both displayed (attribute & value) and edited in a form. ''display'' means that it will displayed when showing the object, but it will not be included in a form. ''none'' means it will neither show up when displaying the object nor when editing a form for this object. This is in addition to the individual permissions you can give on the dynfield_id, so if Freelancers don''t have permission to view attribute, then it does not matter what the display_mode says, they won''t see it';


--
-- Name: COLUMN im_dynfield_type_attribute_map.help_text; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_type_attribute_map.help_text IS 'This is the help_text for this attribute. Though usually it is the same for all object_type_ids (and this is how it is saved with im_dynfield::attribute::add) it is possible to make it differ depending on the TYPE (category_id) of the object';


--
-- Name: COLUMN im_dynfield_type_attribute_map.section_heading; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_type_attribute_map.section_heading IS 'This allows the grouping of attributes under a common heading. See ad_form sections for more details.';


--
-- Name: COLUMN im_dynfield_type_attribute_map.default_value; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_type_attribute_map.default_value IS 'This is the default value for this attribute. Though usually it is the same for all object_type_ids (and this is how it is saved with im_dynfield::attribute::add) it is possible to make it differ depending on the TYPE (category_id) of the object';


--
-- Name: COLUMN im_dynfield_type_attribute_map.required_p; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.im_dynfield_type_attribute_map.required_p IS 'This marks, if the attribute is a required attribute in this condition. This is useful e.g. in Projects where depending on the project_type you want an attribute to be filled out, but for other project types it is not necessary.';


--
-- Name: im_dynfield_widgets; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_dynfield_widgets (
    widget_id integer NOT NULL,
    widget_name text NOT NULL,
    pretty_name text NOT NULL,
    pretty_plural text NOT NULL,
    storage_type_id integer NOT NULL,
    acs_datatype character varying(50) NOT NULL,
    widget character varying(20) NOT NULL,
    sql_datatype text NOT NULL,
    parameters text,
    deref_plpgsql_function text DEFAULT 'im_name_from_id'::text
);


ALTER TABLE public.im_dynfield_widgets OWNER TO evex;

--
-- Name: im_key_account_rels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_key_account_rels (
    key_account_rel_id integer NOT NULL
);


ALTER TABLE public.im_key_account_rels OWNER TO evex;

--
-- Name: im_menus; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_menus (
    menu_id integer NOT NULL,
    package_name character varying(200) NOT NULL,
    label character varying(200) NOT NULL,
    name character varying(200) NOT NULL,
    url character varying(200) NOT NULL,
    sort_order integer,
    parent_menu_id integer,
    tree_sortkey character varying(100),
    visible_tcl text,
    enabled_p character(1) DEFAULT 't'::bpchar,
    menu_gif_small text,
    menu_gif_medium text,
    menu_gif_large text,
    CONSTRAINT im_menus_enabled_ck CHECK ((enabled_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_menus OWNER TO evex;

--
-- Name: im_office_status; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_office_status AS
 SELECT im_categories.category_id AS office_status_id,
    im_categories.category AS office_status
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Office Status'::text);


ALTER TABLE public.im_office_status OWNER TO evex;

--
-- Name: im_office_types; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_office_types AS
 SELECT im_categories.category_id AS office_type_id,
    im_categories.category AS office_type
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Office Type'::text);


ALTER TABLE public.im_office_types OWNER TO evex;

--
-- Name: im_offices; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_offices (
    office_id integer NOT NULL,
    office_name character varying(1000) NOT NULL,
    office_path character varying(100) NOT NULL,
    office_status_id integer NOT NULL,
    office_type_id integer NOT NULL,
    company_id integer,
    public_p character(1) DEFAULT 'f'::bpchar,
    phone character varying(50),
    fax character varying(50),
    address_line1 character varying(80),
    address_line2 character varying(80),
    address_city character varying(80),
    address_state character varying(80),
    address_postal_code character varying(80),
    address_country_code character(2),
    contact_person_id integer,
    landlord text,
    security text,
    note text,
    CONSTRAINT im_offices_public_p_ck CHECK ((public_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_offices OWNER TO evex;

--
-- Name: im_partner_status; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_partner_status AS
 SELECT im_categories.category_id AS partner_status_id,
    im_categories.category AS partner_status
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Partner Status'::text);


ALTER TABLE public.im_partner_status OWNER TO evex;

--
-- Name: im_partner_types; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_partner_types AS
 SELECT im_categories.category_id AS partner_type_id,
    im_categories.category AS partner_type
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Partner Type'::text);


ALTER TABLE public.im_partner_types OWNER TO evex;

--
-- Name: im_profiles; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_profiles (
    profile_id integer NOT NULL,
    profile_gif character varying(100) DEFAULT 'profile'::character varying
);


ALTER TABLE public.im_profiles OWNER TO evex;

--
-- Name: im_project_status; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_project_status AS
 SELECT im_categories.category_id AS project_status_id,
    im_categories.category AS project_status
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Project Status'::text);


ALTER TABLE public.im_project_status OWNER TO evex;

--
-- Name: im_project_types; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_project_types AS
 SELECT im_categories.category_id AS project_type_id,
    im_categories.category AS project_type
   FROM public.im_categories
  WHERE ((im_categories.category_type)::text = 'Intranet Project Type'::text);


ALTER TABLE public.im_project_types OWNER TO evex;

--
-- Name: im_project_url_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_project_url_map (
    project_id integer NOT NULL,
    url_type_id integer NOT NULL,
    url text
);


ALTER TABLE public.im_project_url_map OWNER TO evex;

--
-- Name: im_projects; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_projects (
    project_id integer NOT NULL,
    project_name character varying(1000) NOT NULL,
    project_nr character varying(100) NOT NULL,
    project_path character varying(100) NOT NULL,
    parent_id integer,
    tree_sortkey bit varying,
    max_child_sortkey bit varying,
    company_id integer NOT NULL,
    company_project_nr character varying(200),
    project_type_id integer NOT NULL,
    project_status_id integer NOT NULL,
    description text,
    billing_type_id integer,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    project_cost_center_id integer,
    note text,
    project_lead_id integer,
    supervisor_id integer,
    corporate_sponsor_id integer,
    requires_report_p character(1) DEFAULT 't'::bpchar,
    project_budget double precision,
    project_budget_hours double precision,
    percent_completed double precision,
    on_track_status_id integer,
    template_p character(1) DEFAULT 'f'::bpchar,
    company_contact_id integer,
    sort_order integer,
    presales_probability numeric(5,2),
    presales_value numeric(12,2),
    program_id integer,
    CONSTRAINT im_project_percent_completed_ck CHECK (((percent_completed >= (0)::double precision) AND (percent_completed <= (100)::double precision))),
    CONSTRAINT im_project_requires_report_p CHECK ((requires_report_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar]))),
    CONSTRAINT im_project_template_p CHECK ((requires_report_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar]))),
    CONSTRAINT im_projects_date_const CHECK ((((end_date)::date - (start_date)::date) >= 0)),
    CONSTRAINT im_projects_parent_ck CHECK ((parent_id <> project_id)),
    CONSTRAINT im_projects_start_end_chk CHECK ((end_date >= start_date))
);


ALTER TABLE public.im_projects OWNER TO evex;

--
-- Name: im_start_months; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_start_months (
    start_block date NOT NULL,
    start_of_larger_unit_p character(1) DEFAULT 'f'::bpchar,
    note text,
    CONSTRAINT im_start_months_larger_ck CHECK ((start_of_larger_unit_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_start_months OWNER TO evex;

--
-- Name: im_start_weeks; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_start_weeks (
    start_block date NOT NULL,
    start_of_larger_unit_p character(1) DEFAULT 'f'::bpchar,
    note text,
    CONSTRAINT im_start_weeks_larger_ck CHECK ((start_of_larger_unit_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.im_start_weeks OWNER TO evex;

--
-- Name: im_url_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_url_types (
    url_type_id integer NOT NULL,
    url_type character varying(200) NOT NULL,
    to_ask text NOT NULL,
    to_display character varying(100) NOT NULL,
    display_order integer DEFAULT 1
);


ALTER TABLE public.im_url_types OWNER TO evex;

--
-- Name: im_url_types_type_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.im_url_types_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.im_url_types_type_id_seq OWNER TO evex;

--
-- Name: im_user_status; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_user_status AS
 SELECT im_categories.category_id AS user_status_id,
    im_categories.category AS user_status
   FROM public.im_categories
  WHERE (((im_categories.category_type)::text = 'Intranet User Status'::text) AND ((im_categories.enabled_p IS NULL) OR (im_categories.enabled_p = 't'::bpchar)));


ALTER TABLE public.im_user_status OWNER TO evex;

--
-- Name: im_user_type; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.im_user_type AS
 SELECT im_categories.category_id AS user_type_id,
    im_categories.category AS user_type
   FROM public.im_categories
  WHERE (((im_categories.category_type)::text = 'Intranet User Type'::text) AND ((im_categories.enabled_p IS NULL) OR (im_categories.enabled_p = 't'::bpchar)));


ALTER TABLE public.im_user_type OWNER TO evex;

--
-- Name: im_view_columns; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_view_columns (
    column_id integer NOT NULL,
    view_id integer NOT NULL,
    group_id integer,
    column_name character varying(100) NOT NULL,
    column_render_tcl text,
    extra_select text,
    extra_from text,
    extra_where text,
    sort_order integer NOT NULL,
    order_by_clause text,
    visible_for text,
    ajax_configuration text
);


ALTER TABLE public.im_view_columns OWNER TO evex;

--
-- Name: im_view_columns_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.im_view_columns_seq
    START WITH 1000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.im_view_columns_seq OWNER TO evex;

--
-- Name: im_views; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.im_views (
    view_id integer NOT NULL,
    view_name character varying(100) NOT NULL,
    view_type_id integer,
    view_status_id integer,
    visible_for text,
    view_sql text,
    sort_order integer
);


ALTER TABLE public.im_views OWNER TO evex;

--
-- Name: im_views_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.im_views_seq
    START WITH 1000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.im_views_seq OWNER TO evex;

--
-- Name: imagesx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.imagesx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    images.image_id,
    images.width,
    images.height
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.images
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = images.image_id));


ALTER TABLE public.imagesx OWNER TO evex;

--
-- Name: invalid_uninstalled_bindings; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.invalid_uninstalled_bindings AS
 SELECT c.contract_id,
    c.contract_name,
    i.impl_id,
    i.impl_name,
    i.impl_owner_name,
    i.impl_pretty_name
   FROM public.acs_sc_contracts c,
    public.acs_sc_impls i
  WHERE (((c.contract_name)::text = (i.impl_contract_name)::text) AND (NOT (EXISTS ( SELECT 1
           FROM public.acs_sc_bindings b
          WHERE ((b.contract_id = c.contract_id) AND (b.impl_id = i.impl_id))))) AND (EXISTS ( SELECT 1
           FROM public.acs_sc_operations o
          WHERE ((o.contract_id = c.contract_id) AND (NOT (EXISTS ( SELECT 1
                   FROM public.acs_sc_impl_aliases a
                  WHERE (((a.impl_contract_name)::text = (c.contract_name)::text) AND (a.impl_id = i.impl_id) AND ((a.impl_operation_name)::text = (o.operation_name)::text)))))))));


ALTER TABLE public.invalid_uninstalled_bindings OWNER TO evex;

--
-- Name: itu_codes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.itu_codes (
    itu_id integer NOT NULL,
    code character(6) NOT NULL,
    country character varying(100) NOT NULL,
    note_id character(3)
);


ALTER TABLE public.itu_codes OWNER TO evex;

--
-- Name: TABLE itu_codes; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.itu_codes IS '
    This is the ITU country dialing code list.
';


--
-- Name: itu_notes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.itu_notes (
    note_id character(3) NOT NULL,
    note text NOT NULL
);


ALTER TABLE public.itu_notes OWNER TO evex;

--
-- Name: iurix_mailsx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.iurix_mailsx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    iurix_mails.mail_id,
    iurix_mails.package_id,
    iurix_mails.user_id,
    iurix_mails.type,
    iurix_mails.subject,
    iurix_mails.bodies,
    iurix_mails.date,
    iurix_mails.to_address,
    iurix_mails.from_address,
    iurix_mails.delivered_to,
    iurix_mails.importance,
    iurix_mails.dkim_signature,
    iurix_mails.headers,
    iurix_mails.message_id,
    iurix_mails.received,
    iurix_mails.return_path,
    iurix_mails.x_arrival_time,
    iurix_mails.x_mailer,
    iurix_mails.x_original_to,
    iurix_mails.x_original_arrival_time,
    iurix_mails.x_originating_ip,
    iurix_mails.x_priority
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.iurix_mails
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = iurix_mails.mail_id));


ALTER TABLE public.iurix_mailsx OWNER TO evex;

--
-- Name: journal_entries; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.journal_entries (
    journal_id integer NOT NULL,
    object_id integer,
    action character varying(100),
    action_pretty text,
    msg text
);


ALTER TABLE public.journal_entries OWNER TO evex;

--
-- Name: TABLE journal_entries; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.journal_entries IS '
  Keeps track of actions performed on objects, e.g. banning a user,
  starting or finishing a workflow task, etc.
';


--
-- Name: lang_message_keys; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.lang_message_keys (
    message_key character varying(200) NOT NULL,
    package_key character varying(100) NOT NULL,
    description text
);


ALTER TABLE public.lang_message_keys OWNER TO evex;

--
-- Name: lang_messages; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.lang_messages (
    message_key character varying(200) NOT NULL,
    package_key character varying(100) NOT NULL,
    locale character varying(30) NOT NULL,
    message text,
    deleted_p boolean DEFAULT false,
    sync_time timestamp with time zone,
    conflict_p boolean DEFAULT false,
    upgrade_status character varying(30),
    creation_date timestamp with time zone DEFAULT now() NOT NULL,
    creation_user integer,
    CONSTRAINT lang_messages_us_ck CHECK (((upgrade_status)::text = ANY (ARRAY[('no_upgrade'::character varying)::text, ('added'::character varying)::text, ('deleted'::character varying)::text, ('updated'::character varying)::text])))
);


ALTER TABLE public.lang_messages OWNER TO evex;

--
-- Name: lang_messages_audit; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.lang_messages_audit (
    audit_id integer NOT NULL,
    message_key character varying(200) NOT NULL,
    package_key character varying(100) NOT NULL,
    locale character varying(30) NOT NULL,
    old_message text,
    deleted_p boolean DEFAULT false,
    sync_time timestamp with time zone,
    conflict_p boolean DEFAULT false,
    upgrade_status character varying(30),
    comment_text text,
    overwrite_date timestamp with time zone DEFAULT now() NOT NULL,
    overwrite_user integer,
    CONSTRAINT lang_messages_us_ck CHECK (((upgrade_status)::text = ANY (ARRAY[('no_upgrade'::character varying)::text, ('added'::character varying)::text, ('deleted'::character varying)::text, ('updated'::character varying)::text])))
);


ALTER TABLE public.lang_messages_audit OWNER TO evex;

--
-- Name: lang_messages_audit_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.lang_messages_audit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lang_messages_audit_id_seq OWNER TO evex;

--
-- Name: lang_translate_columns; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.lang_translate_columns (
    column_id integer NOT NULL,
    on_which_table character varying(50),
    on_what_column character varying(50),
    required_p boolean,
    short_p boolean
);


ALTER TABLE public.lang_translate_columns OWNER TO evex;

--
-- Name: lang_translation_registry; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.lang_translation_registry (
    on_which_table character varying(50) NOT NULL,
    on_what_id integer NOT NULL,
    locale character varying(30) NOT NULL
);


ALTER TABLE public.lang_translation_registry OWNER TO evex;

--
-- Name: lang_user_timezone; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.lang_user_timezone (
    user_id integer,
    timezone character varying(30)
);


ALTER TABLE public.lang_user_timezone OWNER TO evex;

--
-- Name: language_639_2_codes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.language_639_2_codes (
    iso_639_2 character(3) NOT NULL,
    iso_639_1 character(2),
    label character varying(200)
);


ALTER TABLE public.language_639_2_codes OWNER TO evex;

--
-- Name: TABLE language_639_2_codes; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.language_639_2_codes IS 'Contains ISO-639-2 language codes and their corresponding ISO-639-1 when it exists.';


--
-- Name: language_codes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.language_codes (
    language_id character(2) NOT NULL,
    name character varying(100) NOT NULL
);


ALTER TABLE public.language_codes OWNER TO evex;

--
-- Name: TABLE language_codes; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.language_codes IS '
    This is data from the ISO 639-1 standard on language codes.
';


--
-- Name: COLUMN language_codes.language_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.language_codes.language_id IS '
    This is the ISO standard language 2 chars code
';


--
-- Name: COLUMN language_codes.name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.language_codes.name IS '
    This is the English version of the language name. 
';


--
-- Name: lob_data; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.lob_data (
    lob_id integer NOT NULL,
    segment integer NOT NULL,
    byte_len integer NOT NULL,
    data bytea NOT NULL
);


ALTER TABLE public.lob_data OWNER TO evex;

--
-- Name: lob_sequence; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.lob_sequence
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lob_sequence OWNER TO evex;

--
-- Name: lobs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.lobs (
    lob_id integer NOT NULL,
    refcount integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.lobs OWNER TO evex;

--
-- Name: notification_delivery_methods; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_delivery_methods (
    delivery_method_id integer NOT NULL,
    sc_impl_id integer NOT NULL,
    short_name character varying(100) NOT NULL,
    pretty_name character varying(200) NOT NULL
);


ALTER TABLE public.notification_delivery_methods OWNER TO evex;

--
-- Name: notification_email_hold; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_email_hold (
    reply_id integer NOT NULL,
    to_addr text,
    headers text,
    body text
);


ALTER TABLE public.notification_email_hold OWNER TO evex;

--
-- Name: notification_intervals; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_intervals (
    interval_id integer NOT NULL,
    name character varying(200) NOT NULL,
    n_seconds integer NOT NULL
);


ALTER TABLE public.notification_intervals OWNER TO evex;

--
-- Name: notification_replies; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_replies (
    reply_id integer NOT NULL,
    object_id integer NOT NULL,
    type_id integer NOT NULL,
    from_user integer NOT NULL,
    subject character varying(100),
    content text,
    reply_date timestamp with time zone
);


ALTER TABLE public.notification_replies OWNER TO evex;

--
-- Name: notification_requests; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_requests (
    request_id integer NOT NULL,
    type_id integer,
    user_id integer,
    object_id integer,
    interval_id integer NOT NULL,
    delivery_method_id integer NOT NULL,
    format character varying(100) DEFAULT 'text'::character varying,
    dynamic_p boolean DEFAULT false,
    CONSTRAINT notifications_request_format_ck CHECK (((format)::text = ANY (ARRAY[('text'::character varying)::text, ('html'::character varying)::text])))
);


ALTER TABLE public.notification_requests OWNER TO evex;

--
-- Name: notification_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_types (
    type_id integer NOT NULL,
    sc_impl_id integer NOT NULL,
    short_name character varying(100) NOT NULL,
    pretty_name character varying(200) NOT NULL,
    description character varying(2000)
);


ALTER TABLE public.notification_types OWNER TO evex;

--
-- Name: notification_types_del_methods; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_types_del_methods (
    type_id integer NOT NULL,
    delivery_method_id integer NOT NULL
);


ALTER TABLE public.notification_types_del_methods OWNER TO evex;

--
-- Name: notification_types_intervals; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_types_intervals (
    type_id integer NOT NULL,
    interval_id integer NOT NULL
);


ALTER TABLE public.notification_types_intervals OWNER TO evex;

--
-- Name: notification_user_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notification_user_map (
    notification_id integer NOT NULL,
    user_id integer NOT NULL,
    sent_date timestamp with time zone
);


ALTER TABLE public.notification_user_map OWNER TO evex;

--
-- Name: notifications; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.notifications (
    notification_id integer NOT NULL,
    type_id integer,
    object_id integer,
    notif_date timestamp with time zone NOT NULL,
    response_id integer,
    notif_user integer,
    notif_subject character varying(1000),
    notif_text text,
    notif_html text,
    file_ids text
);


ALTER TABLE public.notifications OWNER TO evex;

--
-- Name: organization_type_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.organization_type_map (
    organization_id integer,
    organization_type_id integer
);


ALTER TABLE public.organization_type_map OWNER TO evex;

--
-- Name: organization_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.organization_types (
    organization_type_id integer NOT NULL,
    type character varying(40) NOT NULL
);


ALTER TABLE public.organization_types OWNER TO evex;

--
-- Name: TABLE organization_types; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.organization_types IS '
This is a lookup table displaying organization types.
';


--
-- Name: COLUMN organization_types.organization_type_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.organization_types.organization_type_id IS '
Primary key.
';


--
-- Name: COLUMN organization_types.type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.organization_types.type IS '
Pretty name.
';


--
-- Name: organization_types_organization_type_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.organization_types_organization_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.organization_types_organization_type_id_seq OWNER TO evex;

--
-- Name: organization_types_organization_type_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: evex
--

ALTER SEQUENCE public.organization_types_organization_type_id_seq OWNED BY public.organization_types.organization_type_id;


--
-- Name: organizations; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.organizations (
    organization_id integer NOT NULL,
    name character varying(200),
    legal_name character varying(200),
    reg_number character varying(100),
    client_id character varying(100),
    notes text
);


ALTER TABLE public.organizations OWNER TO evex;

--
-- Name: orphan_implementations; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.orphan_implementations AS
 SELECT i.impl_id,
    i.impl_name,
    i.impl_owner_name,
    i.impl_contract_name,
    i.impl_pretty_name
   FROM public.acs_sc_impls i
  WHERE ((NOT (EXISTS ( SELECT 1
           FROM public.acs_sc_bindings b
          WHERE (b.impl_id = i.impl_id)))) AND (NOT (EXISTS ( SELECT 1
           FROM public.acs_sc_contracts c
          WHERE ((c.contract_name)::text = (i.impl_contract_name)::text)))));


ALTER TABLE public.orphan_implementations OWNER TO evex;

--
-- Name: pa_albumsx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.pa_albumsx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    pa_albums.pa_album_id,
    pa_albums.story,
    pa_albums.photographer,
    pa_albums.taken_start,
    pa_albums.taken_end,
    pa_albums.iconic
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.pa_albums
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = pa_albums.pa_album_id));


ALTER TABLE public.pa_albumsx OWNER TO evex;

--
-- Name: pa_collection_photo_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pa_collection_photo_map (
    collection_id integer NOT NULL,
    photo_id integer NOT NULL
);


ALTER TABLE public.pa_collection_photo_map OWNER TO evex;

--
-- Name: pa_collections; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pa_collections (
    collection_id integer NOT NULL,
    owner_id integer NOT NULL,
    title character varying(255) NOT NULL
);


ALTER TABLE public.pa_collections OWNER TO evex;

--
-- Name: TABLE pa_collections; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.pa_collections IS '
   Map a photo into the collection.
';


--
-- Name: pa_package_root_folder_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pa_package_root_folder_map (
    package_id integer NOT NULL,
    folder_id integer
);


ALTER TABLE public.pa_package_root_folder_map OWNER TO evex;

--
-- Name: TABLE pa_package_root_folder_map; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.pa_package_root_folder_map IS '
  Table to keep track of root folder for each instance of the photo-album
  Used for sub-site support.  Each instance of the photo album has a unique 
  root folder.  All folders, pa_albums, pa_photos, and images within the 
  package instance are descendants of the root folder.
  The one-to-one mapping is done using this table to avoid adding a column to the apm_packages
  that pertains only to the photo-album.
';


--
-- Name: pa_photosx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.pa_photosx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    pa_photos.pa_photo_id,
    pa_photos.caption,
    pa_photos.story,
    pa_photos.user_filename,
    pa_photos.camera_model,
    pa_photos.date_taken,
    pa_photos.flash,
    pa_photos.focal_length,
    pa_photos.exposure_time,
    pa_photos.aperture,
    pa_photos.focus_distance,
    pa_photos.metering,
    pa_photos.sha256,
    pa_photos.photographer
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.pa_photos
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = pa_photos.pa_photo_id));


ALTER TABLE public.pa_photosx OWNER TO evex;

--
-- Name: recurrences; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.recurrences (
    recurrence_id integer NOT NULL,
    interval_type integer NOT NULL,
    every_nth_interval integer,
    days_of_week character varying(20),
    recur_until timestamp with time zone,
    db_populated_until timestamp with time zone,
    custom_func character varying(255),
    CONSTRAINT recurs_every_nth_interval_ck CHECK ((every_nth_interval > 0))
);


ALTER TABLE public.recurrences OWNER TO evex;

--
-- Name: TABLE recurrences; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.recurrences IS '
    Desribes how an event recurs.
';


--
-- Name: COLUMN recurrences.interval_type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.recurrences.interval_type IS '
    One of day, week, month_by_date, month_by_day, last_of_month, year, custom.
';


--
-- Name: COLUMN recurrences.every_nth_interval; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.recurrences.every_nth_interval IS '
    Indicates how many of the given intervals between recurrences.
';


--
-- Name: COLUMN recurrences.days_of_week; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.recurrences.days_of_week IS '
    For weekly recurrences, stores which days of the week the event recurs on.
';


--
-- Name: COLUMN recurrences.recur_until; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.recurrences.recur_until IS '
    Indicates when this event should stop recurring.  Null indicates
    recur indefinitely.
';


--
-- Name: COLUMN recurrences.db_populated_until; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.recurrences.db_populated_until IS '
    Indicates the date of the last recurrence added. Used to determine if more
    recurrences need to be added.
';


--
-- Name: COLUMN recurrences.custom_func; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.recurrences.custom_func IS '
    Stores the name of a PL/SQL function that can be called to generate dates
    for special recurrences.
';


--
-- Name: partially_populated_event_ids; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.partially_populated_event_ids AS
 SELECT min(e.event_id) AS event_id,
    r.db_populated_until
   FROM public.acs_events e,
    public.recurrences r
  WHERE ((e.recurrence_id = r.recurrence_id) AND ((r.recur_until > r.db_populated_until) OR (r.recur_until IS NULL)))
  GROUP BY r.recurrence_id, r.db_populated_until;


ALTER TABLE public.partially_populated_event_ids OWNER TO evex;

--
-- Name: VIEW partially_populated_event_ids; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON VIEW public.partially_populated_event_ids IS '
    This view returns the first event_id and db_populated_until column
    for any recurrences that have not been completely populated.
';


--
-- Name: partially_populated_events; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.partially_populated_events AS
 SELECT e.event_id,
    e.timespan_id,
    e.activity_id,
    e.recurrence_id,
    p.db_populated_until
   FROM public.acs_events e,
    public.partially_populated_event_ids p
  WHERE (e.event_id = p.event_id);


ALTER TABLE public.partially_populated_events OWNER TO evex;

--
-- Name: VIEW partially_populated_events; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON VIEW public.partially_populated_events IS '
    This view returns information about recurring events that have not been
    completely populated (such as indefinitely recurring events.)
';


--
-- Name: rel_segment_group_rel_type_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_segment_group_rel_type_map AS
 SELECT s.segment_id,
    gcm.component_id AS group_id,
    acs_rel_types.rel_type
   FROM public.rel_segments s,
    ( SELECT group_component_map.group_id,
            group_component_map.component_id
           FROM public.group_component_map
        UNION ALL
         SELECT groups.group_id,
            groups.group_id AS component_id
           FROM public.groups) gcm,
    public.acs_rel_types,
    public.acs_object_types ot1,
    public.acs_object_types ot2
  WHERE ((s.group_id = gcm.group_id) AND ((s.rel_type)::text = (ot2.object_type)::text) AND ((ot1.object_type)::text = (acs_rel_types.rel_type)::text) AND ((ot1.tree_sortkey >= ot2.tree_sortkey) AND (ot1.tree_sortkey <= public.tree_right(ot2.tree_sortkey))));


ALTER TABLE public.rel_segment_group_rel_type_map OWNER TO evex;

--
-- Name: rc_all_constraints; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rc_all_constraints AS
 SELECT group_rel_types.group_id,
    group_rel_types.rel_type,
    rel_constraints.rel_segment,
    rel_constraints.rel_side,
    rel_constraints.required_rel_segment
   FROM public.rel_constraints,
    public.rel_segment_group_rel_type_map group_rel_types,
    public.rel_segments req_seg
  WHERE ((rel_constraints.rel_segment = group_rel_types.segment_id) AND (rel_constraints.required_rel_segment = req_seg.segment_id) AND (NOT ((req_seg.group_id = group_rel_types.group_id) AND ((req_seg.rel_type)::text = (group_rel_types.rel_type)::text))));


ALTER TABLE public.rc_all_constraints OWNER TO evex;

--
-- Name: rc_required_rel_segments; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rc_required_rel_segments AS
 SELECT DISTINCT rc_all_constraints.group_id,
    rc_all_constraints.rel_type,
    rc_all_constraints.required_rel_segment
   FROM public.rc_all_constraints
  WHERE (rc_all_constraints.rel_side = 'two'::bpchar);


ALTER TABLE public.rc_required_rel_segments OWNER TO evex;

--
-- Name: parties_in_required_segs; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.parties_in_required_segs AS
 SELECT required_segs.group_id,
    required_segs.rel_type,
    seg_parties.party_id,
    seg_parties.segment_id,
    count(*) AS num_matching_segs
   FROM public.rc_required_rel_segments required_segs,
    public.rel_segment_party_map seg_parties
  WHERE (required_segs.required_rel_segment = seg_parties.segment_id)
  GROUP BY required_segs.group_id, required_segs.rel_type, seg_parties.party_id, seg_parties.segment_id;


ALTER TABLE public.parties_in_required_segs OWNER TO evex;

--
-- Name: party_names; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.party_names AS
 SELECT p.party_id,
        CASE
            WHEN (groups.group_id IS NULL) THEN (
            CASE
                WHEN (persons.person_id IS NULL) THEN (p.email)::text
                ELSE (((persons.first_names)::text || ' '::text) || (persons.last_name)::text)
            END)::character varying
            ELSE groups.group_name
        END AS party_name
   FROM ((public.parties p
     LEFT JOIN public.groups ON ((p.party_id = groups.group_id)))
     LEFT JOIN public.persons ON ((p.party_id = persons.person_id)));


ALTER TABLE public.party_names OWNER TO evex;

--
-- Name: phone_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.phone_types (
    phone_type_id integer NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.phone_types OWNER TO evex;

--
-- Name: pinds_blog_categories; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pinds_blog_categories (
    category_id integer NOT NULL,
    package_id integer,
    name character varying(4000) NOT NULL,
    short_name character varying(4000) NOT NULL
);


ALTER TABLE public.pinds_blog_categories OWNER TO evex;

--
-- Name: pinds_blog_entries; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pinds_blog_entries (
    entry_id integer NOT NULL,
    package_id integer,
    title character varying(500),
    title_url character varying(500),
    category_id integer,
    content character varying(32000),
    content_format character varying(50) DEFAULT 'text/html'::character varying NOT NULL,
    entry_date timestamp with time zone,
    draft_p character(1) DEFAULT 'f'::bpchar,
    deleted_p character(1) DEFAULT 'f'::bpchar,
    CONSTRAINT pinds_blog_entries_deleted_ck CHECK ((deleted_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar]))),
    CONSTRAINT pinds_blog_entries_draft_ck CHECK ((draft_p = ANY (ARRAY['t'::bpchar, 'f'::bpchar])))
);


ALTER TABLE public.pinds_blog_entries OWNER TO evex;

--
-- Name: pm; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pm (
    pm_id integer NOT NULL,
    replied_p boolean DEFAULT false,
    read_p boolean DEFAULT false,
    parent_id integer
);


ALTER TABLE public.pm OWNER TO evex;

--
-- Name: pm_aggregate; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pm_aggregate (
    user_id integer NOT NULL,
    total_sent bigint,
    total_recv bigint
);


ALTER TABLE public.pm_aggregate OWNER TO evex;

--
-- Name: pm_preference; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pm_preference (
    user_id integer NOT NULL,
    rcv_msg_p boolean DEFAULT true,
    email_p boolean DEFAULT false
);


ALTER TABLE public.pm_preference OWNER TO evex;

--
-- Name: pm_queue; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pm_queue (
    id integer NOT NULL,
    user_id integer NOT NULL,
    sender_user_id integer NOT NULL,
    title text,
    content text,
    ip character varying(50),
    parent_id integer
);


ALTER TABLE public.pm_queue OWNER TO evex;

--
-- Name: pm_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.pm_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.pm_queue_id_seq OWNER TO evex;

--
-- Name: pm_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: evex
--

ALTER SEQUENCE public.pm_queue_id_seq OWNED BY public.pm_queue.id;


--
-- Name: pm_sent; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.pm_sent (
    pm_id integer NOT NULL
);


ALTER TABLE public.pm_sent OWNER TO evex;

--
-- Name: postal_addresses; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.postal_addresses (
    address_id integer NOT NULL,
    party_id integer,
    delivery_address character varying(1000),
    postal_code character varying(30),
    municipality character varying(100),
    region character varying(100),
    country_code character(2),
    additional_text character varying(100),
    postal_type integer,
    latitude character varying(30),
    longitude character varying(30),
    google_url character varying(254),
    nearbies text
);


ALTER TABLE public.postal_addresses OWNER TO evex;

--
-- Name: TABLE postal_addresses; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.postal_addresses IS '
This is the master address table.
';


--
-- Name: COLUMN postal_addresses.delivery_address; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.postal_addresses.delivery_address IS '
This is the main delivery address. In the US of A it would be equivalent to line1, line2 and etc.
';


--
-- Name: COLUMN postal_addresses.postal_code; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.postal_addresses.postal_code IS '
This is equivalent to zip in the good ol'' US of A.
';


--
-- Name: COLUMN postal_addresses.municipality; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.postal_addresses.municipality IS '
This is equivalent to City in the good ol'' US of A.
';


--
-- Name: COLUMN postal_addresses.region; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.postal_addresses.region IS '
This is equivalent to state in the good ol'' US of A.
';


--
-- Name: COLUMN postal_addresses.country_code; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.postal_addresses.country_code IS '
Required. This is the country of reference for validations and etc.
';


--
-- Name: postal_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.postal_types (
    type_id integer NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.postal_types OWNER TO evex;

--
-- Name: rc_all_constraints_view; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rc_all_constraints_view AS
 SELECT rc_all_constraints.group_id,
    rc_all_constraints.rel_type,
    rc_all_constraints.rel_segment,
    rc_all_constraints.rel_side,
    rc_all_constraints.required_rel_segment
   FROM public.rc_all_constraints
  WHERE (rc_all_constraints.rel_side = 'one'::bpchar);


ALTER TABLE public.rc_all_constraints_view OWNER TO evex;

--
-- Name: rc_all_distinct_constraints; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rc_all_distinct_constraints AS
 SELECT DISTINCT rc_all_constraints.group_id,
    rc_all_constraints.rel_type,
    rc_all_constraints.rel_segment,
    rc_all_constraints.rel_side,
    rc_all_constraints.required_rel_segment
   FROM public.rc_all_constraints;


ALTER TABLE public.rc_all_distinct_constraints OWNER TO evex;

--
-- Name: total_num_required_segs; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.total_num_required_segs AS
 SELECT rc_required_rel_segments.group_id,
    rc_required_rel_segments.rel_type,
    count(*) AS total
   FROM public.rc_required_rel_segments
  GROUP BY rc_required_rel_segments.group_id, rc_required_rel_segments.rel_type;


ALTER TABLE public.total_num_required_segs OWNER TO evex;

--
-- Name: rc_parties_in_required_segs; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rc_parties_in_required_segs AS
 SELECT parties_in_required_segs.group_id,
    parties_in_required_segs.rel_type,
    parties_in_required_segs.party_id
   FROM public.parties_in_required_segs,
    public.total_num_required_segs
  WHERE ((parties_in_required_segs.group_id = total_num_required_segs.group_id) AND ((parties_in_required_segs.rel_type)::text = (total_num_required_segs.rel_type)::text) AND (parties_in_required_segs.num_matching_segs = total_num_required_segs.total))
UNION ALL
 SELECT group_rel_type_combos.group_id,
    group_rel_type_combos.rel_type,
    parties.party_id
   FROM (public.rc_required_rel_segments
     RIGHT JOIN public.group_rel_type_combos ON (((rc_required_rel_segments.group_id = group_rel_type_combos.group_id) AND ((rc_required_rel_segments.rel_type)::text = (group_rel_type_combos.rel_type)::text)))),
    public.parties
  WHERE (rc_required_rel_segments.group_id IS NULL);


ALTER TABLE public.rc_parties_in_required_segs OWNER TO evex;

--
-- Name: rc_segment_required_seg_map; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.rc_segment_required_seg_map (
    rel_segment integer NOT NULL,
    rel_side character(3) NOT NULL,
    required_rel_segment integer NOT NULL,
    CONSTRAINT rc_rel_side_ck CHECK ((rel_side = ANY (ARRAY['one'::bpchar, 'two'::bpchar])))
);


ALTER TABLE public.rc_segment_required_seg_map OWNER TO evex;

--
-- Name: rc_segment_dependency_levels; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rc_segment_dependency_levels AS
 SELECT rc_segment_required_seg_map.rel_segment AS segment_id,
    count(*) AS dependency_level
   FROM public.rc_segment_required_seg_map
  WHERE (rc_segment_required_seg_map.rel_side = 'two'::bpchar)
  GROUP BY rc_segment_required_seg_map.rel_segment;


ALTER TABLE public.rc_segment_dependency_levels OWNER TO evex;

--
-- Name: side_one_constraints; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.side_one_constraints AS
 SELECT required_segs.group_id,
    required_segs.rel_type,
    count(*) AS num_satisfied
   FROM public.rc_all_constraints required_segs,
    public.rel_segment_party_map map
  WHERE ((required_segs.rel_side = 'one'::bpchar) AND (required_segs.required_rel_segment = map.segment_id) AND (required_segs.group_id = map.party_id))
  GROUP BY required_segs.group_id, required_segs.rel_type;


ALTER TABLE public.side_one_constraints OWNER TO evex;

--
-- Name: total_side_one_constraints; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.total_side_one_constraints AS
 SELECT rc_all_constraints.group_id,
    rc_all_constraints.rel_type,
    count(*) AS total
   FROM public.rc_all_constraints
  WHERE (rc_all_constraints.rel_side = 'one'::bpchar)
  GROUP BY rc_all_constraints.group_id, rc_all_constraints.rel_type;


ALTER TABLE public.total_side_one_constraints OWNER TO evex;

--
-- Name: rc_valid_rel_types; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rc_valid_rel_types AS
 SELECT side_one_constraints.group_id,
    side_one_constraints.rel_type
   FROM public.side_one_constraints,
    public.total_side_one_constraints
  WHERE ((side_one_constraints.group_id = total_side_one_constraints.group_id) AND ((side_one_constraints.rel_type)::text = (total_side_one_constraints.rel_type)::text) AND (side_one_constraints.num_satisfied = total_side_one_constraints.total))
UNION ALL
 SELECT group_rel_type_combos.group_id,
    group_rel_type_combos.rel_type
   FROM (public.rc_all_constraints_view
     RIGHT JOIN public.group_rel_type_combos ON (((rc_all_constraints_view.group_id = group_rel_type_combos.group_id) AND ((rc_all_constraints_view.rel_type)::text = (group_rel_type_combos.rel_type)::text))))
  WHERE (rc_all_constraints_view.group_id IS NULL);


ALTER TABLE public.rc_valid_rel_types OWNER TO evex;

--
-- Name: rc_violations_by_removing_rel; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rc_violations_by_removing_rel AS
 SELECT r.rel_type AS viol_rel_type,
    r.rel_id AS viol_rel_id,
    r.object_id_one AS viol_object_id_one,
    r.object_id_two AS viol_object_id_two,
    s.rel_id,
    cons.constraint_id,
    cons.constraint_name,
    map.segment_id,
    map.party_id,
    map.group_id,
    map.container_id,
    map.ancestor_rel_type
   FROM public.acs_rels r,
    public.rel_segment_party_map map,
    public.rel_constraints cons,
    ( SELECT s_1.segment_id,
            r_1.rel_id,
            r_1.object_id_two
           FROM public.rel_segments s_1,
            public.acs_rels r_1
          WHERE ((r_1.object_id_one = s_1.group_id) AND ((r_1.rel_type)::text = (s_1.rel_type)::text))) s
  WHERE ((map.party_id = r.object_id_two) AND (map.rel_id = r.rel_id) AND (r.object_id_two = s.object_id_two) AND (cons.rel_segment = map.segment_id) AND (cons.required_rel_segment = s.segment_id));


ALTER TABLE public.rc_violations_by_removing_rel OWNER TO evex;

--
-- Name: recurrence_interval_types; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.recurrence_interval_types (
    interval_type integer NOT NULL,
    interval_name character varying(50) NOT NULL
);


ALTER TABLE public.recurrence_interval_types OWNER TO evex;

--
-- Name: recurrence_sequence; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.recurrence_sequence
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.recurrence_sequence OWNER TO evex;

--
-- Name: refund_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.refund_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.refund_id_seq OWNER TO evex;

--
-- Name: refund_id_sequence; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.refund_id_sequence AS
 SELECT nextval('public.refund_id_seq'::regclass) AS nextval;


ALTER TABLE public.refund_id_sequence OWNER TO evex;

--
-- Name: registered_users; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.registered_users AS
 SELECT p.email,
    p.url,
    pe.first_names,
    pe.last_name,
    u.user_id,
    u.authority_id,
    u.username,
    u.screen_name,
    u.priv_name,
    u.priv_email,
    u.email_verified_p,
    u.email_bouncing_p,
    u.no_alerts_until,
    u.last_visit,
    u.second_to_last_visit,
    u.n_sessions,
    u.password,
    u.salt,
    u.password_question,
    u.password_answer,
    u.password_changed_date,
    u.auth_token,
    mr.member_state
   FROM public.parties p,
    public.persons pe,
    public.users u,
    public.group_member_map m,
    public.membership_rels mr
  WHERE ((p.party_id = pe.person_id) AND (pe.person_id = u.user_id) AND (u.user_id = m.member_id) AND (m.rel_id = mr.rel_id) AND (m.group_id = public.acs__magic_object_id('registered_users'::character varying)) AND (m.container_id = m.group_id) AND ((m.rel_type)::text = 'membership_rel'::text) AND ((mr.member_state)::text = 'approved'::text) AND (u.email_verified_p = true));


ALTER TABLE public.registered_users OWNER TO evex;

--
-- Name: rel_constraints_violated_one; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_constraints_violated_one AS
 SELECT c.constraint_id,
    c.constraint_name,
    c.rel_id,
    c.container_id,
    c.party_id,
    c.rel_type,
    c.rel_segment,
    c.rel_side,
    c.required_rel_segment
   FROM (public.constrained_rels1 c
     LEFT JOIN public.rel_segment_party_map rspm ON (((rspm.segment_id = c.required_rel_segment) AND (rspm.party_id = c.container_id))))
  WHERE (rspm.party_id IS NULL);


ALTER TABLE public.rel_constraints_violated_one OWNER TO evex;

--
-- Name: rel_constraints_violated_two; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_constraints_violated_two AS
 SELECT c.constraint_id,
    c.constraint_name,
    c.rel_id,
    c.container_id,
    c.party_id,
    c.rel_type,
    c.rel_segment,
    c.rel_side,
    c.required_rel_segment
   FROM (public.constrained_rels2 c
     LEFT JOIN public.rel_segment_party_map rspm ON (((rspm.segment_id = c.required_rel_segment) AND (rspm.party_id = c.party_id))))
  WHERE (rspm.party_id IS NULL);


ALTER TABLE public.rel_constraints_violated_two OWNER TO evex;

--
-- Name: rel_seg_approved_member_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_seg_approved_member_map AS
 SELECT rs.segment_id,
    gem.element_id AS member_id,
    gem.rel_id,
    gem.rel_type,
    gem.group_id,
    gem.container_id
   FROM public.membership_rels mr,
    public.group_element_map gem,
    public.rel_segments rs,
    public.acs_object_types ot1,
    public.acs_object_types ot2
  WHERE ((rs.group_id = gem.group_id) AND ((rs.rel_type)::text = (ot2.object_type)::text) AND ((ot1.object_type)::text = (gem.rel_type)::text) AND ((ot1.tree_sortkey >= ot2.tree_sortkey) AND (ot1.tree_sortkey <= public.tree_right(ot2.tree_sortkey))) AND (mr.rel_id = gem.rel_id) AND ((mr.member_state)::text = 'approved'::text));


ALTER TABLE public.rel_seg_approved_member_map OWNER TO evex;

--
-- Name: rel_seg_distinct_member_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_seg_distinct_member_map AS
 SELECT DISTINCT rel_seg_approved_member_map.segment_id,
    rel_seg_approved_member_map.member_id
   FROM public.rel_seg_approved_member_map;


ALTER TABLE public.rel_seg_distinct_member_map OWNER TO evex;

--
-- Name: rel_segment_distinct_party_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_segment_distinct_party_map AS
 SELECT DISTINCT rel_segment_party_map.segment_id,
    rel_segment_party_map.party_id,
    rel_segment_party_map.ancestor_rel_type
   FROM public.rel_segment_party_map;


ALTER TABLE public.rel_segment_distinct_party_map OWNER TO evex;

--
-- Name: rel_segment_member_map; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_segment_member_map AS
 SELECT rel_segment_party_map.segment_id,
    rel_segment_party_map.party_id AS member_id,
    rel_segment_party_map.rel_id,
    rel_segment_party_map.rel_type,
    rel_segment_party_map.group_id,
    rel_segment_party_map.container_id
   FROM public.rel_segment_party_map
  WHERE ((rel_segment_party_map.ancestor_rel_type)::text = 'membership_rel'::text);


ALTER TABLE public.rel_segment_member_map OWNER TO evex;

--
-- Name: rel_types_valid_obj_one_types; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_types_valid_obj_one_types AS
 SELECT rt.rel_type,
    th.object_type
   FROM public.acs_rel_types rt,
    ( SELECT acs_object_type_supertype_map.object_type,
            acs_object_type_supertype_map.ancestor_type
           FROM public.acs_object_type_supertype_map
        UNION ALL
         SELECT acs_object_types.object_type,
            acs_object_types.object_type AS ancestor_type
           FROM public.acs_object_types) th
  WHERE ((rt.object_type_one)::text = (th.ancestor_type)::text);


ALTER TABLE public.rel_types_valid_obj_one_types OWNER TO evex;

--
-- Name: rel_types_valid_obj_two_types; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.rel_types_valid_obj_two_types AS
 SELECT rt.rel_type,
    th.object_type
   FROM public.acs_rel_types rt,
    ( SELECT acs_object_type_supertype_map.object_type,
            acs_object_type_supertype_map.ancestor_type
           FROM public.acs_object_type_supertype_map
        UNION ALL
         SELECT acs_object_types.object_type,
            acs_object_types.object_type AS ancestor_type
           FROM public.acs_object_types) th
  WHERE ((rt.object_type_two)::text = (th.ancestor_type)::text);


ALTER TABLE public.rel_types_valid_obj_two_types OWNER TO evex;

--
-- Name: rss_gen_subscrs; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.rss_gen_subscrs (
    subscr_id integer NOT NULL,
    impl_id integer NOT NULL,
    summary_context_id integer NOT NULL,
    timeout integer NOT NULL,
    lastbuild timestamp with time zone,
    last_ttb integer,
    channel_title character varying(200),
    channel_link character varying(1000)
);


ALTER TABLE public.rss_gen_subscrs OWNER TO evex;

--
-- Name: TABLE rss_gen_subscrs; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.rss_gen_subscrs IS '
   Table for storing the different parts of the site we will generate
   summaries for.
';


--
-- Name: COLUMN rss_gen_subscrs.subscr_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rss_gen_subscrs.subscr_id IS '
   Subscriptions are ACS objects.  They will typically inherit
   permission from a package instance.
';


--
-- Name: COLUMN rss_gen_subscrs.impl_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rss_gen_subscrs.impl_id IS '
   The implementation which will provide summary information and
   update status.
';


--
-- Name: COLUMN rss_gen_subscrs.summary_context_id; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rss_gen_subscrs.summary_context_id IS '
   An identifier unique to the site section whose content is to be
   summarized.  A context identifier need not be a package instance
   id.  We will suggest a convention but the format is entirely up to
   the implementors.
';


--
-- Name: COLUMN rss_gen_subscrs.timeout; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rss_gen_subscrs.timeout IS '
   The minimum number of seconds between summary builds. 
';


--
-- Name: COLUMN rss_gen_subscrs.lastbuild; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rss_gen_subscrs.lastbuild IS '
   Accounting column for use by rss generation service.
';


--
-- Name: COLUMN rss_gen_subscrs.last_ttb; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rss_gen_subscrs.last_ttb IS '
   Another accounting column.  The last time to build (in seconds).
';


--
-- Name: COLUMN rss_gen_subscrs.channel_title; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rss_gen_subscrs.channel_title IS '
   Used for display purposes.
';


--
-- Name: COLUMN rss_gen_subscrs.channel_link; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.rss_gen_subscrs.channel_link IS '
   Used for display purposes.
';


--
-- Name: search_observer_queue; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.search_observer_queue (
    object_id integer NOT NULL,
    event_date timestamp with time zone DEFAULT now(),
    event character varying(6),
    CONSTRAINT search_observer_queue_event_ck CHECK (((event)::text = ANY (ARRAY[('INSERT'::character varying)::text, ('DELETE'::character varying)::text, ('UPDATE'::character varying)::text])))
);


ALTER TABLE public.search_observer_queue OWNER TO evex;

--
-- Name: t_sec_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.t_sec_id_seq
    START WITH 1
    INCREMENT BY 100
    NO MINVALUE
    NO MAXVALUE
    CACHE 100;


ALTER TABLE public.t_sec_id_seq OWNER TO evex;

--
-- Name: sec_id_seq; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.sec_id_seq AS
 SELECT nextval('public.t_sec_id_seq'::regclass) AS nextval;


ALTER TABLE public.sec_id_seq OWNER TO evex;

--
-- Name: t_sec_security_token_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.t_sec_security_token_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 100;


ALTER TABLE public.t_sec_security_token_id_seq OWNER TO evex;

--
-- Name: sec_security_token_id_seq; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.sec_security_token_id_seq AS
 SELECT nextval('public.t_sec_security_token_id_seq'::regclass) AS nextval;


ALTER TABLE public.sec_security_token_id_seq OWNER TO evex;

--
-- Name: sec_session_properties; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.sec_session_properties (
    session_id bigint NOT NULL,
    module character varying(50) NOT NULL,
    property_name character varying(50) NOT NULL,
    property_value text,
    secure_p boolean,
    last_hit integer NOT NULL
);


ALTER TABLE public.sec_session_properties OWNER TO evex;

--
-- Name: secret_tokens; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.secret_tokens (
    token_id integer NOT NULL,
    token character(40),
    token_timestamp timestamp with time zone
);


ALTER TABLE public.secret_tokens OWNER TO evex;

--
-- Name: site_node_object_mappings; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.site_node_object_mappings (
    object_id integer NOT NULL,
    node_id integer NOT NULL
);


ALTER TABLE public.site_node_object_mappings OWNER TO evex;

--
-- Name: site_nodes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.site_nodes (
    node_id integer NOT NULL,
    parent_id integer,
    name text,
    directory_p boolean NOT NULL,
    pattern_p boolean DEFAULT false NOT NULL,
    object_id integer,
    tree_sortkey bit varying,
    CONSTRAINT site_nodes_name_ck CHECK ((name !~~ '%/%'::text))
);


ALTER TABLE public.site_nodes OWNER TO evex;

--
-- Name: site_nodes_selection; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.site_nodes_selection (
    node_id integer NOT NULL,
    view_p boolean
);


ALTER TABLE public.site_nodes_selection OWNER TO evex;

--
-- Name: subsite_callbacks; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.subsite_callbacks (
    callback_id integer NOT NULL,
    event_type character varying(100) NOT NULL,
    object_type character varying(1000) NOT NULL,
    callback character varying(300) NOT NULL,
    callback_type character varying(100) NOT NULL,
    sort_order integer DEFAULT 1 NOT NULL,
    CONSTRAINT sgc_callback_type_ck CHECK (((callback_type)::text = 'tcl'::text)),
    CONSTRAINT sgc_event_type_ck CHECK (((event_type)::text = ANY (ARRAY[('insert'::character varying)::text, ('update'::character varying)::text, ('delete'::character varying)::text]))),
    CONSTRAINT sgc_sort_order_ck CHECK ((sort_order >= 1))
);


ALTER TABLE public.subsite_callbacks OWNER TO evex;

--
-- Name: TABLE subsite_callbacks; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.subsite_callbacks IS '
	Applications can register callbacks that are triggered
	whenever a group of a specified type is created. The callback
	must expect the following arguments: 
	  * object_id: The object that just got created
	  * node_id: The node_id where the object got created
	  * package_id: The package_id from where the object got created
	These are passed in the following way:
	  * tcl procedure: Using named parameters (e.g. -object_id $object_id)
	All callbacks must accept all of these parameters.
';


--
-- Name: COLUMN subsite_callbacks.event_type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.subsite_callbacks.event_type IS '
	The type of event we are monitoring. The keywords here are used
	by the applications to determine which callbacks to trigger.
';


--
-- Name: COLUMN subsite_callbacks.object_type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.subsite_callbacks.object_type IS '
	The object type to monitor. Whenever an object of this type is
	created, the subsite package will check for a registered
	callbacks.
';


--
-- Name: COLUMN subsite_callbacks.callback; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.subsite_callbacks.callback IS '
	The actual callback. This can be the name of a plsql function
	or procedure, a url stub relative to the node at which package
	id is mounted, or the name of a tcl function.
';


--
-- Name: COLUMN subsite_callbacks.callback_type; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.subsite_callbacks.callback_type IS ' 
	The type of the callback. This determines how the callback is
	executed. Currenlty only a tcl type is supported but other
	types may be added in the future. 
';


--
-- Name: COLUMN subsite_callbacks.sort_order; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.subsite_callbacks.sort_order IS '
	The order in which the callbacks should fire. This is
	important when you need to ensure that one event fires before
	another (e.g. you must mount a portals application before the
	bboard application)
';


--
-- Name: subsite_themes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.subsite_themes (
    key text NOT NULL,
    name text NOT NULL,
    template text NOT NULL,
    css text,
    js text,
    form_template text,
    list_template text,
    list_filter_template text,
    dimensional_template text,
    resource_dir text,
    streaming_head text
);


ALTER TABLE public.subsite_themes OWNER TO evex;

--
-- Name: syndication; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.syndication (
    object_id integer NOT NULL,
    last_updated timestamp with time zone DEFAULT now() NOT NULL,
    rss_xml_frag text,
    body text,
    url text
);


ALTER TABLE public.syndication OWNER TO evex;

--
-- Name: TABLE syndication; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.syndication IS 'stores xml fragments for consolidating into rss feeds. Also stores an html version of the content item
         and it''s url from the link field of the rss';


--
-- Name: tags_tags; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.tags_tags (
    item_id integer,
    package_id integer,
    user_id integer,
    tag character varying(3000),
    "time" timestamp without time zone,
    context_id integer
);


ALTER TABLE public.tags_tags OWNER TO evex;

--
-- Name: telecom_numbers; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.telecom_numbers (
    number_id integer NOT NULL,
    party_id integer,
    itu_id integer,
    national_number character varying(20),
    area_city_code character varying(30),
    subscriber_number character varying(100) NOT NULL,
    extension character varying(100),
    sms_enabled_p boolean,
    best_contact_time character varying(200),
    location character varying(200),
    phone_type_id integer
);


ALTER TABLE public.telecom_numbers OWNER TO evex;

--
-- Name: telecom_number_vw; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.telecom_number_vw AS
 SELECT n.number_id,
    n.party_id,
    n.itu_id,
    n.national_number,
    n.area_city_code,
    n.subscriber_number,
    n.extension,
    n.sms_enabled_p,
    n.best_contact_time,
    n.location,
    n.phone_type_id,
    (((n.area_city_code)::text || ' '::text) || (n.subscriber_number)::text) AS pretty_number,
    t.description AS phone_type
   FROM public.phone_types t,
    public.telecom_numbers n
  WHERE (t.phone_type_id = n.phone_type_id);


ALTER TABLE public.telecom_number_vw OWNER TO evex;

--
-- Name: template_demo_notes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.template_demo_notes (
    template_demo_note_id integer NOT NULL,
    title character varying(255) NOT NULL,
    body text,
    color text
);


ALTER TABLE public.template_demo_notes OWNER TO evex;

--
-- Name: timespan_sequence; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.timespan_sequence
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.timespan_sequence OWNER TO evex;

--
-- Name: timezone_rules; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.timezone_rules (
    tz_id integer,
    abbrev character varying(10) NOT NULL,
    utc_start timestamp with time zone NOT NULL,
    utc_end timestamp with time zone NOT NULL,
    local_start timestamp with time zone NOT NULL,
    local_end timestamp with time zone NOT NULL,
    gmt_offset text NOT NULL,
    isdst_p boolean
);


ALTER TABLE public.timezone_rules OWNER TO evex;

--
-- Name: timezone_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.timezone_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.timezone_seq OWNER TO evex;

--
-- Name: timezones; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.timezones (
    tz_id integer NOT NULL,
    tz character varying(100) NOT NULL,
    gmt_offset text NOT NULL
);


ALTER TABLE public.timezones OWNER TO evex;

--
-- Name: trackback_pings; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.trackback_pings (
    tb_url character varying(1000),
    name character varying(1000),
    comment_id integer
);


ALTER TABLE public.trackback_pings OWNER TO evex;

--
-- Name: txt; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.txt (
    object_id integer,
    fti tsvector
);


ALTER TABLE public.txt OWNER TO evex;

--
-- Name: us_counties; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.us_counties (
    fips_state_code character(2) NOT NULL,
    fips_county_code character(6) NOT NULL,
    name character varying(100) NOT NULL,
    state_abbrev character(2),
    population numeric,
    housing_units numeric,
    land_area numeric,
    water_area numeric,
    latitude numeric,
    longitude numeric
);


ALTER TABLE public.us_counties OWNER TO evex;

--
-- Name: TABLE us_counties; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.us_counties IS '
    This is the United States county code table from the US Census Bureau
';


--
-- Name: COLUMN us_counties.fips_state_code; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.fips_state_code IS '
State FIPS code.
';


--
-- Name: COLUMN us_counties.fips_county_code; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.fips_county_code IS '
County FIPS code.
';


--
-- Name: COLUMN us_counties.name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.name IS '
Name. Includes name of county. Counties don''t nave a type, but do have
the word "County" as part of the name.
';


--
-- Name: COLUMN us_counties.state_abbrev; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.state_abbrev IS '
State abbreviations.
';


--
-- Name: COLUMN us_counties.population; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.population IS '
Total population (1990).
';


--
-- Name: COLUMN us_counties.housing_units; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.housing_units IS '
Housing units (1990).
';


--
-- Name: COLUMN us_counties.land_area; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.land_area IS '
Land are included (in thousandths of a square kilometer).
';


--
-- Name: COLUMN us_counties.water_area; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.water_area IS '
Water area included (in thousandths of a square kilometer).
';


--
-- Name: COLUMN us_counties.latitude; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.latitude IS '
Longitude (millionths of a degree, + or - denoting N or S,
respectively.
';


--
-- Name: COLUMN us_counties.longitude; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_counties.longitude IS '
Latitude (millionths of a degree, + or - denoting N or S,
respectively.
';


--
-- Name: us_states; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.us_states (
    abbrev character(2) NOT NULL,
    state_name character varying(100) NOT NULL,
    fips_state_code character(2)
);


ALTER TABLE public.us_states OWNER TO evex;

--
-- Name: TABLE us_states; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.us_states IS '
This is the US states table.
';


--
-- Name: COLUMN us_states.abbrev; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_states.abbrev IS '
This is the 2 letter abbreviation for states.
';


--
-- Name: COLUMN us_states.fips_state_code; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_states.fips_state_code IS '
The FIPS code used by the USPS for certain delivery types.
';


--
-- Name: us_zipcodes; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.us_zipcodes (
    zipcode character(5) NOT NULL,
    name character varying(100) NOT NULL,
    fips_state_code character(2) NOT NULL,
    fips_county_code character(6) NOT NULL,
    latitude numeric,
    longitude numeric
);


ALTER TABLE public.us_zipcodes OWNER TO evex;

--
-- Name: TABLE us_zipcodes; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON TABLE public.us_zipcodes IS '
This is the table of US zipcodes. It does not include zip+4.
';


--
-- Name: COLUMN us_zipcodes.zipcode; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_zipcodes.zipcode IS '
5-digit Zipcode.
';


--
-- Name: COLUMN us_zipcodes.name; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_zipcodes.name IS '
Zipcode name.
';


--
-- Name: COLUMN us_zipcodes.fips_state_code; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_zipcodes.fips_state_code IS '
State FIPS code.
';


--
-- Name: COLUMN us_zipcodes.fips_county_code; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_zipcodes.fips_county_code IS '
County FIPS code.
';


--
-- Name: COLUMN us_zipcodes.latitude; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_zipcodes.latitude IS '
Latitude in decimal degrees.
';


--
-- Name: COLUMN us_zipcodes.longitude; Type: COMMENT; Schema: public; Owner: evex
--

COMMENT ON COLUMN public.us_zipcodes.longitude IS '
Longitude in decimal degrees.
';


--
-- Name: user_col_comments; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.user_col_comments AS
 SELECT upper((c.relname)::text) AS table_name,
    upper((a.attname)::text) AS column_name,
    col_description(a.attrelid, (a.attnum)::integer) AS comments
   FROM (pg_class c
     LEFT JOIN pg_attribute a ON ((a.attrelid = c.oid)))
  WHERE (a.attnum > 0);


ALTER TABLE public.user_col_comments OWNER TO evex;

--
-- Name: user_ext_info; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.user_ext_info (
    userinfo_id integer NOT NULL,
    fbid character varying(255),
    phonenumber character varying(255),
    user_id integer,
    purchased_plan character varying(255),
    purchased_quota integer,
    purchased_date timestamp with time zone,
    product_id integer
);


ALTER TABLE public.user_ext_info OWNER TO evex;

--
-- Name: user_info_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.user_info_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1000;


ALTER TABLE public.user_info_id_seq OWNER TO evex;

--
-- Name: user_payment_id_seq; Type: SEQUENCE; Schema: public; Owner: evex
--

CREATE SEQUENCE public.user_payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1000;


ALTER TABLE public.user_payment_id_seq OWNER TO evex;

--
-- Name: user_payments; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.user_payments (
    payment_id integer NOT NULL,
    collection_id character varying(255),
    collection_status character varying(255),
    external_reference character varying(255),
    payment_type character varying(255),
    merchant_order_id character varying(255),
    preference_id character varying(255),
    site_id character varying(255),
    processing_mode character varying(255),
    merchant_account_id character varying(255),
    user_id integer,
    product_id integer
);


ALTER TABLE public.user_payments OWNER TO evex;

--
-- Name: user_portraits; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.user_portraits (
    user_id integer NOT NULL
);


ALTER TABLE public.user_portraits OWNER TO evex;

--
-- Name: user_preferences; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.user_preferences (
    user_id integer NOT NULL,
    prefer_text_only_p boolean DEFAULT false,
    language_preference character(2) DEFAULT 'en'::bpchar,
    dont_spam_me_p boolean DEFAULT false,
    email_type character varying(64),
    timezone character varying(100),
    locale character varying(30)
);


ALTER TABLE public.user_preferences OWNER TO evex;

--
-- Name: user_tab_columns; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.user_tab_columns AS
 SELECT upper((c.relname)::text) AS table_name,
    upper((a.attname)::text) AS column_name,
    upper((t.typname)::text) AS data_type
   FROM pg_class c,
    pg_attribute a,
    pg_type t
  WHERE ((c.oid = a.attrelid) AND (a.atttypid = t.oid) AND (a.attnum > 0));


ALTER TABLE public.user_tab_columns OWNER TO evex;

--
-- Name: user_tab_comments; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.user_tab_comments AS
 SELECT upper((c.relname)::text) AS table_name,
        CASE
            WHEN (c.relkind = 'r'::"char") THEN 'TABLE'::text
            WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text
            ELSE (c.relkind)::text
        END AS table_type,
    d.description AS comments
   FROM (pg_class c
     LEFT JOIN pg_description d ON ((c.oid = d.objoid)))
  WHERE (d.objsubid = 0);


ALTER TABLE public.user_tab_comments OWNER TO evex;

--
-- Name: users_contact; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.users_contact (
    user_id integer NOT NULL,
    home_phone text,
    priv_home_phone integer,
    work_phone text,
    priv_work_phone integer,
    cell_phone text,
    priv_cell_phone integer,
    pager text,
    priv_pager integer,
    fax text,
    priv_fax integer,
    aim_screen_name text,
    priv_aim_screen_name integer,
    msn_screen_name text,
    priv_msn_screen_name integer,
    icq_number text,
    priv_icq_number integer,
    m_address character(1),
    ha_line1 text,
    ha_line2 text,
    ha_city text,
    ha_state text,
    ha_postal_code text,
    ha_country_code character(2),
    priv_ha integer,
    wa_line1 text,
    wa_line2 text,
    wa_city text,
    wa_state text,
    wa_postal_code text,
    wa_country_code character(2),
    priv_wa integer,
    note text,
    current_information text,
    CONSTRAINT users_contact_m_address_check CHECK ((m_address = ANY (ARRAY['w'::bpchar, 'h'::bpchar])))
);


ALTER TABLE public.users_contact OWNER TO evex;

--
-- Name: users_active; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.users_active AS
 SELECT u.user_id,
    u.username,
    u.screen_name,
    u.last_visit,
    u.second_to_last_visit,
    u.n_sessions,
    u.first_names,
    u.last_name,
    c.home_phone,
    c.priv_home_phone,
    c.work_phone,
    c.priv_work_phone,
    c.cell_phone,
    c.priv_cell_phone,
    c.pager,
    c.priv_pager,
    c.fax,
    c.priv_fax,
    c.aim_screen_name,
    c.priv_aim_screen_name,
    c.msn_screen_name,
    c.priv_msn_screen_name,
    c.icq_number,
    c.priv_icq_number,
    c.m_address,
    c.ha_line1,
    c.ha_line2,
    c.ha_city,
    c.ha_state,
    c.ha_postal_code,
    c.ha_country_code,
    c.priv_ha,
    c.wa_line1,
    c.wa_line2,
    c.wa_city,
    c.wa_state,
    c.wa_postal_code,
    c.wa_country_code,
    c.priv_wa,
    c.note,
    c.current_information
   FROM (public.registered_users u
     LEFT JOIN public.users_contact c ON ((u.user_id = c.user_id)));


ALTER TABLE public.users_active OWNER TO evex;

--
-- Name: users_email_imagex; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.users_email_imagex AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    users_email_image.email_image_id
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.users_email_image
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = users_email_image.email_image_id));


ALTER TABLE public.users_email_imagex OWNER TO evex;

--
-- Name: valid_uninstalled_bindings; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.valid_uninstalled_bindings AS
 SELECT c.contract_id,
    c.contract_name,
    i.impl_id,
    i.impl_name,
    i.impl_owner_name,
    i.impl_pretty_name
   FROM public.acs_sc_contracts c,
    public.acs_sc_impls i
  WHERE (((c.contract_name)::text = (i.impl_contract_name)::text) AND (NOT (EXISTS ( SELECT 1
           FROM public.acs_sc_bindings b
          WHERE ((b.contract_id = c.contract_id) AND (b.impl_id = i.impl_id))))) AND (NOT (EXISTS ( SELECT 1
           FROM public.acs_sc_operations o
          WHERE ((o.contract_id = c.contract_id) AND (NOT (EXISTS ( SELECT 1
                   FROM public.acs_sc_impl_aliases a
                  WHERE (((a.impl_contract_name)::text = (c.contract_name)::text) AND (a.impl_id = i.impl_id) AND ((a.impl_operation_name)::text = (o.operation_name)::text))))))))));


ALTER TABLE public.valid_uninstalled_bindings OWNER TO evex;

--
-- Name: weblogger_blogroll_entries; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.weblogger_blogroll_entries (
    link_id integer NOT NULL,
    package_id integer,
    name character varying(500) NOT NULL,
    url character varying(1000) NOT NULL,
    sort_order integer DEFAULT 0
);


ALTER TABLE public.weblogger_blogroll_entries OWNER TO evex;

--
-- Name: weblogger_channels; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.weblogger_channels (
    channel_id integer NOT NULL,
    package_id integer,
    user_id integer
);


ALTER TABLE public.weblogger_channels OWNER TO evex;

--
-- Name: weblogger_ping_urls; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.weblogger_ping_urls (
    package_id integer NOT NULL,
    ping_url character varying(500) NOT NULL,
    creation_date timestamp with time zone DEFAULT now()
);


ALTER TABLE public.weblogger_ping_urls OWNER TO evex;

--
-- Name: weblogger_technorati_cache; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.weblogger_technorati_cache (
    package_id integer,
    name character varying(500),
    url character varying(500),
    creation_date timestamp with time zone DEFAULT now()
);


ALTER TABLE public.weblogger_technorati_cache OWNER TO evex;

--
-- Name: xowf_package; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowf_package (
    package_id integer NOT NULL
);


ALTER TABLE public.xowf_package OWNER TO evex;

--
-- Name: xowiki_autonames; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_autonames (
    parent_id integer,
    name character varying(3000),
    count integer
);


ALTER TABLE public.xowiki_autonames OWNER TO evex;

--
-- Name: xowiki_filex; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_filex AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_file.file_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_file,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_file.file_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_filex OWNER TO evex;

--
-- Name: xowiki_form_instance_attributes; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_form_instance_attributes AS
 SELECT ci.item_id,
    o.package_id,
    o.object_id,
    o.object_type,
    o.title AS object_title,
    o.context_id,
    o.security_inherit_p,
    o.creation_user,
    o.creation_date,
    o.creation_ip,
    o.last_modified,
    o.modifying_user,
    o.modifying_ip,
    cr.revision_id,
    cr.title,
    public.content_revision__get_content(cr.revision_id) AS data,
    cr_text.text_data AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_form_page.xowiki_form_page_id,
    xowiki_page_instance.page_instance_id,
    xowiki_page_instance.instance_attributes,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.cr_text,
    (((((public.cr_items ci
     LEFT JOIN public.cr_revisions cr ON ((cr.revision_id = ci.live_revision)))
     LEFT JOIN public.acs_objects o ON ((o.object_id = ci.live_revision)))
     LEFT JOIN public.xowiki_page ON ((o.object_id = xowiki_page.page_id)))
     LEFT JOIN public.xowiki_page_instance ON ((o.object_id = xowiki_page_instance.page_instance_id)))
     LEFT JOIN public.xowiki_form_page ON ((o.object_id = xowiki_form_page.xowiki_form_page_id)));


ALTER TABLE public.xowiki_form_instance_attributes OWNER TO evex;

--
-- Name: xowiki_form_instance_item_index; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_form_instance_item_index (
    item_id integer,
    name character varying(400),
    package_id integer,
    parent_id integer,
    publish_status text,
    page_template integer,
    assignee integer,
    state text
);


ALTER TABLE public.xowiki_form_instance_item_index OWNER TO evex;

--
-- Name: xowiki_form_instance_children; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_form_instance_children AS
 WITH RECURSIVE child_items AS (
         SELECT xowiki_form_instance_item_index.item_id AS root_item_id,
            xowiki_form_instance_item_index.item_id,
            xowiki_form_instance_item_index.name,
            xowiki_form_instance_item_index.package_id,
            xowiki_form_instance_item_index.parent_id,
            xowiki_form_instance_item_index.publish_status,
            xowiki_form_instance_item_index.page_template,
            xowiki_form_instance_item_index.assignee,
            xowiki_form_instance_item_index.state
           FROM public.xowiki_form_instance_item_index
        UNION ALL
         SELECT child_items_1.root_item_id,
            xi.item_id,
            xi.name,
            xi.package_id,
            xi.parent_id,
            xi.publish_status,
            xi.page_template,
            xi.assignee,
            xi.state
           FROM public.xowiki_form_instance_item_index xi,
            child_items child_items_1
          WHERE (xi.parent_id = child_items_1.item_id)
        )
 SELECT child_items.root_item_id,
    child_items.item_id,
    child_items.name,
    child_items.package_id,
    child_items.parent_id,
    child_items.publish_status,
    child_items.page_template,
    child_items.assignee,
    child_items.state
   FROM child_items;


ALTER TABLE public.xowiki_form_instance_children OWNER TO evex;

--
-- Name: xowiki_form_instance_item_view; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_form_instance_item_view AS
 SELECT xi.package_id,
    xi.parent_id,
    xi.name,
    xi.publish_status,
    xi.assignee,
    xi.state,
    xi.page_template,
    xi.item_id,
    o.object_id,
    o.object_type,
    o.title AS object_title,
    o.context_id,
    o.security_inherit_p,
    o.creation_user,
    o.creation_date,
    o.creation_ip,
    o.last_modified,
    o.modifying_user,
    o.modifying_ip,
    cr.revision_id,
    cr.title,
    public.content_revision__get_content(cr.revision_id) AS text,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    xowiki_form_page.xowiki_form_page_id,
    xowiki_page_instance.page_instance_id,
    xowiki_page_instance.instance_attributes,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.cr_text,
    ((((((public.xowiki_form_instance_item_index xi
     LEFT JOIN public.cr_items ci ON ((ci.item_id = xi.item_id)))
     LEFT JOIN public.cr_revisions cr ON ((cr.revision_id = ci.live_revision)))
     LEFT JOIN public.acs_objects o ON ((o.object_id = ci.live_revision)))
     LEFT JOIN public.xowiki_page ON ((o.object_id = xowiki_page.page_id)))
     LEFT JOIN public.xowiki_page_instance ON ((o.object_id = xowiki_page_instance.page_instance_id)))
     LEFT JOIN public.xowiki_form_page ON ((o.object_id = xowiki_form_page.xowiki_form_page_id)));


ALTER TABLE public.xowiki_form_instance_item_view OWNER TO evex;

--
-- Name: xowiki_form_pagex; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_form_pagex AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_form_page.xowiki_form_page_id,
    xowiki_form_page.assignee,
    xowiki_form_page.state,
    xowiki_page_instance.page_instance_id,
    xowiki_page_instance.page_template,
    xowiki_page_instance.instance_attributes,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_form_page,
    public.xowiki_page_instance,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_form_page.xowiki_form_page_id) AND (acs_objects.object_id = xowiki_page_instance.page_instance_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_form_pagex OWNER TO evex;

--
-- Name: xowiki_formx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_formx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_form.xowiki_form_id,
    xowiki_form.form,
    xowiki_form.form_constraints,
    xowiki_page_template.page_template_id,
    xowiki_page_template.anon_instances,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_form,
    public.xowiki_page_template,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_form.xowiki_form_id) AND (acs_objects.object_id = xowiki_page_template.page_template_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_formx OWNER TO evex;

--
-- Name: xowiki_last_visited; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_last_visited (
    page_id integer,
    package_id integer,
    user_id integer,
    count integer,
    "time" timestamp without time zone
);


ALTER TABLE public.xowiki_last_visited OWNER TO evex;

--
-- Name: xowiki_objectx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_objectx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_object.xowiki_object_id,
    xowiki_plain_page.ppage_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_object,
    public.xowiki_plain_page,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_object.xowiki_object_id) AND (acs_objects.object_id = xowiki_plain_page.ppage_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_objectx OWNER TO evex;

--
-- Name: xowiki_package; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_package (
    package_id integer NOT NULL
);


ALTER TABLE public.xowiki_package OWNER TO evex;

--
-- Name: xowiki_page_instancex; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_page_instancex AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_page_instance.page_instance_id,
    xowiki_page_instance.page_template,
    xowiki_page_instance.instance_attributes,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_page_instance,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_page_instance.page_instance_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_page_instancex OWNER TO evex;

--
-- Name: xowiki_page_live_revision; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_page_live_revision AS
 SELECT p.page_id,
    p.page_order,
    p.creator,
    cr.revision_id,
    cr.item_id,
    cr.title,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    cr.lob,
    cr.content,
    cr.content_length,
    ci.parent_id,
    ci.name,
    ci.locale,
    ci.live_revision,
    ci.latest_revision,
    ci.publish_status,
    ci.content_type,
    ci.storage_type,
    ci.storage_area_key,
    ci.tree_sortkey,
    ci.max_child_sortkey
   FROM public.xowiki_page p,
    public.cr_items ci,
    public.cr_revisions cr
  WHERE ((p.page_id = ci.live_revision) AND (p.page_id = cr.revision_id) AND ((ci.publish_status)::text <> 'production'::text));


ALTER TABLE public.xowiki_page_live_revision OWNER TO evex;

--
-- Name: xowiki_page_templatex; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_page_templatex AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_page_template.page_template_id,
    xowiki_page_template.anon_instances,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_page_template,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_page_template.page_template_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_page_templatex OWNER TO evex;

--
-- Name: xowiki_pagex; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_pagex AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_pagex OWNER TO evex;

--
-- Name: xowiki_plain_pagex; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_plain_pagex AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_plain_page.ppage_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_plain_page,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_plain_page.ppage_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_plain_pagex OWNER TO evex;

--
-- Name: xowiki_podcast_itemx; Type: VIEW; Schema: public; Owner: evex
--

CREATE VIEW public.xowiki_podcast_itemx AS
 SELECT acs_objects.object_id,
    acs_objects.object_type,
    acs_objects.title AS object_title,
    acs_objects.package_id AS object_package_id,
    acs_objects.context_id,
    acs_objects.security_inherit_p,
    acs_objects.creation_user,
    acs_objects.creation_date,
    acs_objects.creation_ip,
    acs_objects.last_modified,
    acs_objects.modifying_user,
    acs_objects.modifying_ip,
    cr.revision_id,
    cr.title,
    cr.item_id,
    cr.description,
    cr.publish_date,
    cr.mime_type,
    cr.nls_language,
    i.name,
    i.parent_id,
    xowiki_podcast_item.podcast_item_id,
    xowiki_podcast_item.pub_date,
    xowiki_podcast_item.duration,
    xowiki_podcast_item.subtitle,
    xowiki_podcast_item.keywords,
    xowiki_file.file_id,
    xowiki_page.page_id,
    xowiki_page.page_order,
    xowiki_page.creator
   FROM public.acs_objects,
    public.cr_revisions cr,
    public.cr_items i,
    public.cr_text,
    public.xowiki_podcast_item,
    public.xowiki_file,
    public.xowiki_page
  WHERE ((acs_objects.object_id = cr.revision_id) AND (cr.item_id = i.item_id) AND (acs_objects.object_id = xowiki_podcast_item.podcast_item_id) AND (acs_objects.object_id = xowiki_file.file_id) AND (acs_objects.object_id = xowiki_page.page_id));


ALTER TABLE public.xowiki_podcast_itemx OWNER TO evex;

--
-- Name: xowiki_references; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_references (
    reference integer,
    link_type text,
    page integer
);


ALTER TABLE public.xowiki_references OWNER TO evex;

--
-- Name: xowiki_tags; Type: TABLE; Schema: public; Owner: evex
--

CREATE TABLE public.xowiki_tags (
    item_id integer,
    package_id integer,
    user_id integer,
    tag character varying(3000),
    "time" timestamp without time zone
);


ALTER TABLE public.xowiki_tags OWNER TO evex;

--
-- Name: organization_types organization_type_id; Type: DEFAULT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.organization_types ALTER COLUMN organization_type_id SET DEFAULT nextval('public.organization_types_organization_type_id_seq'::regclass);


--
-- Name: pm_queue id; Type: DEFAULT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_queue ALTER COLUMN id SET DEFAULT nextval('public.pm_queue_id_seq'::regclass);


--
-- Name: acs_activity_object_map acs_act_obj_mp_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_activity_object_map
    ADD CONSTRAINT acs_act_obj_mp_pk PRIMARY KEY (activity_id, object_id);


--
-- Name: acs_activities acs_activities_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_activities
    ADD CONSTRAINT acs_activities_pk PRIMARY KEY (activity_id);


--
-- Name: acs_attribute_descriptions acs_attribute_descriptions_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attribute_descriptions
    ADD CONSTRAINT acs_attribute_descriptions_pk PRIMARY KEY (object_type, attribute_name, description_key);


--
-- Name: acs_attribute_values acs_attribute_values_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attribute_values
    ADD CONSTRAINT acs_attribute_values_pk PRIMARY KEY (object_id, attribute_id);


--
-- Name: acs_attributes acs_attributes_attr_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attributes
    ADD CONSTRAINT acs_attributes_attr_name_un UNIQUE (attribute_name, object_type);


--
-- Name: acs_attributes acs_attributes_attribute_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attributes
    ADD CONSTRAINT acs_attributes_attribute_id_pk PRIMARY KEY (attribute_id);


--
-- Name: acs_attributes acs_attributes_pretty_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attributes
    ADD CONSTRAINT acs_attributes_pretty_name_un UNIQUE (pretty_name, object_type);


--
-- Name: acs_attributes acs_attributes_sort_order_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attributes
    ADD CONSTRAINT acs_attributes_sort_order_un UNIQUE (attribute_id, sort_order);


--
-- Name: acs_data_links acs_data_links_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_data_links
    ADD CONSTRAINT acs_data_links_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: acs_data_links acs_data_links_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_data_links
    ADD CONSTRAINT acs_data_links_un UNIQUE (object_id_one, object_id_two, relation_tag);


--
-- Name: acs_datatypes acs_datatypes_datatype_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_datatypes
    ADD CONSTRAINT acs_datatypes_datatype_pk PRIMARY KEY (datatype);


--
-- Name: acs_enum_values acs_enum_values_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_enum_values
    ADD CONSTRAINT acs_enum_values_pk PRIMARY KEY (attribute_id, enum_value);


--
-- Name: acs_enum_values acs_enum_values_pretty_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_enum_values
    ADD CONSTRAINT acs_enum_values_pretty_name_un UNIQUE (attribute_id, pretty_name);


--
-- Name: acs_enum_values acs_enum_values_sort_order_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_enum_values
    ADD CONSTRAINT acs_enum_values_sort_order_un UNIQUE (attribute_id, sort_order);


--
-- Name: acs_events acs_events_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_events
    ADD CONSTRAINT acs_events_pk PRIMARY KEY (event_id);


--
-- Name: acs_event_party_map acs_evnt_party_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_event_party_map
    ADD CONSTRAINT acs_evnt_party_map_pk PRIMARY KEY (event_id, party_id);


--
-- Name: acs_function_args acs_function_args_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_function_args
    ADD CONSTRAINT acs_function_args_pk PRIMARY KEY (function, arg_seq);


--
-- Name: acs_function_args acs_function_args_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_function_args
    ADD CONSTRAINT acs_function_args_un UNIQUE (function, arg_name);


--
-- Name: acs_logs acs_logs_log_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_logs
    ADD CONSTRAINT acs_logs_log_id_pk PRIMARY KEY (log_id);


--
-- Name: acs_magic_objects acs_magic_objects_name_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_magic_objects
    ADD CONSTRAINT acs_magic_objects_name_pk PRIMARY KEY (name);


--
-- Name: acs_mail_lite_bounce acs_mail_lite_bou_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_mail_lite_bounce
    ADD CONSTRAINT acs_mail_lite_bou_pk PRIMARY KEY (party_id);


--
-- Name: acs_mail_lite_bounce_notif acs_mail_lite_bounce_notif_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_mail_lite_bounce_notif
    ADD CONSTRAINT acs_mail_lite_bounce_notif_pk PRIMARY KEY (party_id);


--
-- Name: acs_mail_lite_mail_log acs_mail_lite_log_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_mail_lite_mail_log
    ADD CONSTRAINT acs_mail_lite_log_pk PRIMARY KEY (party_id);


--
-- Name: acs_mail_lite_queue acs_mail_lite_queue_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_mail_lite_queue
    ADD CONSTRAINT acs_mail_lite_queue_pk PRIMARY KEY (message_id);


--
-- Name: acs_messages acs_messages_message_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_messages
    ADD CONSTRAINT acs_messages_message_id_pk PRIMARY KEY (message_id);


--
-- Name: acs_messages_outgoing acs_messages_outgoing_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_messages_outgoing
    ADD CONSTRAINT acs_messages_outgoing_pk PRIMARY KEY (message_id, to_address);


--
-- Name: acs_messages acs_messages_rfc822_id_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_messages
    ADD CONSTRAINT acs_messages_rfc822_id_un UNIQUE (rfc822_id);


--
-- Name: acs_named_objects acs_named_objs_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_named_objects
    ADD CONSTRAINT acs_named_objs_pk PRIMARY KEY (object_id);


--
-- Name: acs_object_types acs_obj_types_pretty_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_types
    ADD CONSTRAINT acs_obj_types_pretty_name_un UNIQUE (pretty_name);


--
-- Name: acs_object_types acs_obj_types_pretty_plural_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_types
    ADD CONSTRAINT acs_obj_types_pretty_plural_un UNIQUE (pretty_plural);


--
-- Name: acs_object_context_index acs_object_context_index_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_context_index
    ADD CONSTRAINT acs_object_context_index_pk PRIMARY KEY (object_id, ancestor_id);


--
-- Name: acs_rels acs_object_rels_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rels
    ADD CONSTRAINT acs_object_rels_un UNIQUE (rel_type, object_id_one, object_id_two);


--
-- Name: acs_object_type_tables acs_object_type_tables_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_type_tables
    ADD CONSTRAINT acs_object_type_tables_pk PRIMARY KEY (object_type, table_name);


--
-- Name: acs_object_types acs_object_types_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_types
    ADD CONSTRAINT acs_object_types_pk PRIMARY KEY (object_type);


--
-- Name: acs_object_types acs_object_types_pkg_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_types
    ADD CONSTRAINT acs_object_types_pkg_name_un UNIQUE (package_name);


--
-- Name: acs_object_types acs_object_types_table_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_types
    ADD CONSTRAINT acs_object_types_table_name_un UNIQUE (table_name);


--
-- Name: acs_objects acs_objects_context_object_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_objects
    ADD CONSTRAINT acs_objects_context_object_un UNIQUE (context_id, object_id);


--
-- Name: acs_objects acs_objects_object_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_objects
    ADD CONSTRAINT acs_objects_object_id_pk PRIMARY KEY (object_id);


--
-- Name: acs_permissions acs_permissions_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_permissions
    ADD CONSTRAINT acs_permissions_pk PRIMARY KEY (object_id, grantee_id, privilege);


--
-- Name: acs_privilege_hierarchy acs_privilege_hierarchy_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_privilege_hierarchy
    ADD CONSTRAINT acs_privilege_hierarchy_pk PRIMARY KEY (privilege, child_privilege);


--
-- Name: acs_privileges acs_privileges_privilege_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_privileges
    ADD CONSTRAINT acs_privileges_privilege_pk PRIMARY KEY (privilege);


--
-- Name: acs_rel_roles acs_rel_roles_role_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rel_roles
    ADD CONSTRAINT acs_rel_roles_role_pk PRIMARY KEY (role);


--
-- Name: acs_rel_types acs_rel_types_rel_type_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rel_types
    ADD CONSTRAINT acs_rel_types_rel_type_pk PRIMARY KEY (rel_type);


--
-- Name: acs_rels acs_rels_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rels
    ADD CONSTRAINT acs_rels_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: acs_sc_contracts acs_sc_contracts_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_contracts
    ADD CONSTRAINT acs_sc_contracts_name_un UNIQUE (contract_name);


--
-- Name: acs_sc_contracts acs_sc_contracts_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_contracts
    ADD CONSTRAINT acs_sc_contracts_pk PRIMARY KEY (contract_id);


--
-- Name: acs_sc_impl_aliases acs_sc_impl_alias_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_impl_aliases
    ADD CONSTRAINT acs_sc_impl_alias_un UNIQUE (impl_name, impl_contract_name, impl_operation_name);


--
-- Name: acs_sc_impls acs_sc_impls_impl_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_impls
    ADD CONSTRAINT acs_sc_impls_impl_id_pk PRIMARY KEY (impl_id);


--
-- Name: acs_sc_msg_types acs_sc_msg_types_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_msg_types
    ADD CONSTRAINT acs_sc_msg_types_name_un UNIQUE (msg_type_name);


--
-- Name: acs_sc_msg_types acs_sc_msg_types_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_msg_types
    ADD CONSTRAINT acs_sc_msg_types_pk PRIMARY KEY (msg_type_id);


--
-- Name: acs_sc_operations acs_sc_operations_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_pk PRIMARY KEY (operation_id);


--
-- Name: acs_static_attr_values acs_static_a_v_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_static_attr_values
    ADD CONSTRAINT acs_static_a_v_pk PRIMARY KEY (object_type, attribute_id);


--
-- Name: ad_locales ad_locales_label_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ad_locales
    ADD CONSTRAINT ad_locales_label_un UNIQUE (label);


--
-- Name: ad_locales ad_locales_locale_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ad_locales
    ADD CONSTRAINT ad_locales_locale_pk PRIMARY KEY (locale);


--
-- Name: ad_template_sample_users ad_template_sample_users_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ad_template_sample_users
    ADD CONSTRAINT ad_template_sample_users_pk PRIMARY KEY (user_id);


--
-- Name: admin_rels admin_rels_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.admin_rels
    ADD CONSTRAINT admin_rels_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: ams_attribute_items ams_attribute_items_ams_attribute_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_attribute_items
    ADD CONSTRAINT ams_attribute_items_ams_attribute_id_pk PRIMARY KEY (ams_attribute_id);


--
-- Name: ams_attribute_items ams_attribute_items_attribute_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_attribute_items
    ADD CONSTRAINT ams_attribute_items_attribute_id_key UNIQUE (attribute_id);


--
-- Name: ams_list_attribute_map ams_list_attribute_map_list_id_attribute_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_list_attribute_map
    ADD CONSTRAINT ams_list_attribute_map_list_id_attribute_id_key UNIQUE (list_id, attribute_id);


--
-- Name: ams_list_attribute_map ams_list_attribute_map_list_id_sort_order_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_list_attribute_map
    ADD CONSTRAINT ams_list_attribute_map_list_id_sort_order_key UNIQUE (list_id, sort_order);


--
-- Name: ams_lists ams_lists_list_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_lists
    ADD CONSTRAINT ams_lists_list_id_pk PRIMARY KEY (list_id);


--
-- Name: ams_lists ams_lists_package_key_object_type_list_name_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_lists
    ADD CONSTRAINT ams_lists_package_key_object_type_list_name_key UNIQUE (package_key, object_type, list_name);


--
-- Name: ams_numbers ams_numbers_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_numbers
    ADD CONSTRAINT ams_numbers_id_pk PRIMARY KEY (value_id);


--
-- Name: ams_option_types ams_option_types_attribute_id_sort_order_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_option_types
    ADD CONSTRAINT ams_option_types_attribute_id_sort_order_key UNIQUE (attribute_id, sort_order);


--
-- Name: ams_option_ids ams_options_map_ids_value_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_option_ids
    ADD CONSTRAINT ams_options_map_ids_value_id_pk PRIMARY KEY (value_id);


--
-- Name: ams_option_types ams_options_option_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_option_types
    ADD CONSTRAINT ams_options_option_id_pk PRIMARY KEY (option_id);


--
-- Name: ams_options ams_options_value_id_option_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_options
    ADD CONSTRAINT ams_options_value_id_option_id_key UNIQUE (value_id, option_id);


--
-- Name: ams_texts ams_texts_text_format_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_texts
    ADD CONSTRAINT ams_texts_text_format_pk PRIMARY KEY (value_id);


--
-- Name: ams_times ams_times_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_times
    ADD CONSTRAINT ams_times_id_pk PRIMARY KEY (value_id);


--
-- Name: ams_widgets ams_widgets_name_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_widgets
    ADD CONSTRAINT ams_widgets_name_pk PRIMARY KEY (widget);


--
-- Name: apm_applications apm_applications_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_applications
    ADD CONSTRAINT apm_applications_pk PRIMARY KEY (application_id);


--
-- Name: apm_package_callbacks apm_package_callbacks_vt_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_callbacks
    ADD CONSTRAINT apm_package_callbacks_vt_un UNIQUE (version_id, type);


--
-- Name: apm_package_db_types apm_package_db_types_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_db_types
    ADD CONSTRAINT apm_package_db_types_pk PRIMARY KEY (db_type_key);


--
-- Name: apm_package_dependencies apm_package_deps_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_dependencies
    ADD CONSTRAINT apm_package_deps_id_pk PRIMARY KEY (dependency_id);


--
-- Name: apm_package_dependencies apm_package_deps_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_dependencies
    ADD CONSTRAINT apm_package_deps_un UNIQUE (version_id, service_uri);


--
-- Name: apm_package_types apm_package_types_p_key_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_types
    ADD CONSTRAINT apm_package_types_p_key_pk PRIMARY KEY (package_key);


--
-- Name: apm_package_types apm_package_types_pretty_n_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_types
    ADD CONSTRAINT apm_package_types_pretty_n_un UNIQUE (pretty_name);


--
-- Name: apm_package_types apm_package_types_pretty_pl_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_types
    ADD CONSTRAINT apm_package_types_pretty_pl_un UNIQUE (pretty_plural);


--
-- Name: apm_package_version_attr apm_package_vers_attr_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_version_attr
    ADD CONSTRAINT apm_package_vers_attr_pk PRIMARY KEY (version_id, attribute_name);


--
-- Name: apm_package_versions apm_package_vers_id_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_versions
    ADD CONSTRAINT apm_package_vers_id_name_un UNIQUE (package_key, version_name);


--
-- Name: apm_package_versions apm_package_vers_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_versions
    ADD CONSTRAINT apm_package_vers_id_pk PRIMARY KEY (version_id);


--
-- Name: apm_package_versions apm_package_vers_ver_uri_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_versions
    ADD CONSTRAINT apm_package_vers_ver_uri_un UNIQUE (version_uri);


--
-- Name: apm_packages apm_packages_package_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_packages
    ADD CONSTRAINT apm_packages_package_id_pk PRIMARY KEY (package_id);


--
-- Name: apm_package_types apm_packages_types_p_uri_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_types
    ADD CONSTRAINT apm_packages_types_p_uri_un UNIQUE (package_uri);


--
-- Name: apm_parameter_values apm_parameter_values_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameter_values
    ADD CONSTRAINT apm_parameter_values_pk PRIMARY KEY (value_id);


--
-- Name: apm_parameter_values apm_parameter_values_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameter_values
    ADD CONSTRAINT apm_parameter_values_un UNIQUE (package_id, parameter_id);


--
-- Name: apm_parameters apm_parameters_parameter_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameters
    ADD CONSTRAINT apm_parameters_parameter_id_pk PRIMARY KEY (parameter_id);


--
-- Name: apm_parameters apm_paramters_attr_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameters
    ADD CONSTRAINT apm_paramters_attr_name_un UNIQUE (parameter_name, package_key);


--
-- Name: apm_services apm_services_service_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_services
    ADD CONSTRAINT apm_services_service_id_pk PRIMARY KEY (service_id);


--
-- Name: application_groups application_groups_group_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.application_groups
    ADD CONSTRAINT application_groups_group_id_pk PRIMARY KEY (group_id);


--
-- Name: application_groups application_groups_package_id_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.application_groups
    ADD CONSTRAINT application_groups_package_id_un UNIQUE (package_id);


--
-- Name: acs_reference_repositories arr_package_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_reference_repositories
    ADD CONSTRAINT arr_package_name_un UNIQUE (package_name);


--
-- Name: acs_reference_repositories arr_repository_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_reference_repositories
    ADD CONSTRAINT arr_repository_id_pk PRIMARY KEY (repository_id);


--
-- Name: acs_reference_repositories arr_table_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_reference_repositories
    ADD CONSTRAINT arr_table_name_un UNIQUE (table_name);


--
-- Name: attachments_fs_root_folder_map attach_fldr_map_package_id_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.attachments_fs_root_folder_map
    ADD CONSTRAINT attach_fldr_map_package_id_un UNIQUE (package_id);


--
-- Name: attachments_fs_root_folder_map attach_fldr_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.attachments_fs_root_folder_map
    ADD CONSTRAINT attach_fldr_map_pk PRIMARY KEY (package_id, folder_id);


--
-- Name: attachments attachments_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.attachments
    ADD CONSTRAINT attachments_pk PRIMARY KEY (object_id, item_id);


--
-- Name: auth_authorities auth_authorities_auth_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_auth_id_pk PRIMARY KEY (authority_id);


--
-- Name: auth_authorities auth_authorities_short_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_short_name_un UNIQUE (short_name);


--
-- Name: auth_batch_job_entries auth_batch_job_entries_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_batch_job_entries
    ADD CONSTRAINT auth_batch_job_entries_pk PRIMARY KEY (entry_id);


--
-- Name: auth_batch_jobs auth_batch_jobs_job_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_batch_jobs
    ADD CONSTRAINT auth_batch_jobs_job_id_pk PRIMARY KEY (job_id);


--
-- Name: auth_driver_params auth_driver_params_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_driver_params
    ADD CONSTRAINT auth_driver_params_pk PRIMARY KEY (authority_id, impl_id, key);


--
-- Name: banners banners_banner_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.banners
    ADD CONSTRAINT banners_banner_id_pk PRIMARY KEY (banner_id);


--
-- Name: cal_items cal_item_cal_item_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_items
    ADD CONSTRAINT cal_item_cal_item_id_pk PRIMARY KEY (cal_item_id);


--
-- Name: cal_item_types cal_item_type_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_item_types
    ADD CONSTRAINT cal_item_type_id_pk PRIMARY KEY (item_type_id);


--
-- Name: cal_item_types cal_item_types_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_item_types
    ADD CONSTRAINT cal_item_types_un UNIQUE (calendar_id, item_type_id);


--
-- Name: cal_party_prefs cal_party_prefs_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_party_prefs
    ADD CONSTRAINT cal_party_prefs_un UNIQUE (calendar_id, party_id);


--
-- Name: calendars calendars_calendar_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.calendars
    ADD CONSTRAINT calendars_calendar_id_pk PRIMARY KEY (calendar_id);


--
-- Name: categories categories_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT categories_pkey PRIMARY KEY (category_id);


--
-- Name: im_category_hierarchy category_hierarchy_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_category_hierarchy
    ADD CONSTRAINT category_hierarchy_un UNIQUE (parent_id, child_id);


--
-- Name: category_links category_links_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_links
    ADD CONSTRAINT category_links_pk PRIMARY KEY (link_id);


--
-- Name: category_links category_links_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_links
    ADD CONSTRAINT category_links_un UNIQUE (from_category_id, to_category_id);


--
-- Name: category_object_map category_object_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_object_map
    ADD CONSTRAINT category_object_map_pkey PRIMARY KEY (category_id, object_id);


--
-- Name: category_search category_search_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_search
    ADD CONSTRAINT category_search_id_pk PRIMARY KEY (query_id);


--
-- Name: category_search category_search_query_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_search
    ADD CONSTRAINT category_search_query_un UNIQUE (search_text, locale);


--
-- Name: category_search_results category_search_results_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_search_results
    ADD CONSTRAINT category_search_results_pk PRIMARY KEY (query_id, synonym_id);


--
-- Name: category_synonyms category_synonyms_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_synonyms
    ADD CONSTRAINT category_synonyms_pk PRIMARY KEY (synonym_id);


--
-- Name: category_translations category_translations_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_translations
    ADD CONSTRAINT category_translations_pkey PRIMARY KEY (category_id, locale);


--
-- Name: category_tree_map category_tree_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_tree_map
    ADD CONSTRAINT category_tree_map_pkey PRIMARY KEY (object_id, tree_id);


--
-- Name: category_tree_translations category_tree_translations_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_tree_translations
    ADD CONSTRAINT category_tree_translations_pkey PRIMARY KEY (tree_id, locale);


--
-- Name: category_trees category_trees_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_trees
    ADD CONSTRAINT category_trees_pkey PRIMARY KEY (tree_id);


--
-- Name: organization_types company_type_name_uq; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.organization_types
    ADD CONSTRAINT company_type_name_uq UNIQUE (type);


--
-- Name: organization_types company_types_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.organization_types
    ADD CONSTRAINT company_types_pk PRIMARY KEY (organization_type_id);


--
-- Name: composition_rels composition_rels_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.composition_rels
    ADD CONSTRAINT composition_rels_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: countries countries_default_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.countries
    ADD CONSTRAINT countries_default_name_un UNIQUE (default_name);


--
-- Name: countries countries_iso_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.countries
    ADD CONSTRAINT countries_iso_pk PRIMARY KEY (iso);


--
-- Name: country_codes country_codes_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.country_codes
    ADD CONSTRAINT country_codes_pk PRIMARY KEY (iso);


--
-- Name: cr_child_rels cr_child_rels_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_child_rels
    ADD CONSTRAINT cr_child_rels_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: cr_content_mime_type_map cr_content_mime_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_content_mime_type_map
    ADD CONSTRAINT cr_content_mime_map_pk PRIMARY KEY (content_type, mime_type);


--
-- Name: cr_content_text cr_content_text_revision_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_content_text
    ADD CONSTRAINT cr_content_text_revision_id_pk PRIMARY KEY (revision_id);


--
-- Name: cr_doc_filter cr_doc_filter_revision_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_doc_filter
    ADD CONSTRAINT cr_doc_filter_revision_id_pk PRIMARY KEY (revision_id);


--
-- Name: cr_extension_mime_type_map cr_extension_mime_type_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_extension_mime_type_map
    ADD CONSTRAINT cr_extension_mime_type_map_pk PRIMARY KEY (extension);


--
-- Name: cr_extlinks cr_extlinks_extlink_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_extlinks
    ADD CONSTRAINT cr_extlinks_extlink_id_pk PRIMARY KEY (extlink_id);


--
-- Name: cr_folder_type_map cr_folder_type_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_folder_type_map
    ADD CONSTRAINT cr_folder_type_map_pk PRIMARY KEY (folder_id, content_type);


--
-- Name: cr_folders cr_folders_folder_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_folders
    ADD CONSTRAINT cr_folders_folder_id_pk PRIMARY KEY (folder_id);


--
-- Name: cr_item_keyword_map cr_item_keyword_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_keyword_map
    ADD CONSTRAINT cr_item_keyword_map_pk PRIMARY KEY (item_id, keyword_id);


--
-- Name: cr_item_rels cr_item_rels_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_rels
    ADD CONSTRAINT cr_item_rels_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: cr_item_template_map cr_item_template_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_template_map
    ADD CONSTRAINT cr_item_template_map_pk PRIMARY KEY (item_id, template_id, use_context);


--
-- Name: cr_items cr_items_item_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_items
    ADD CONSTRAINT cr_items_item_id_pk PRIMARY KEY (item_id);


--
-- Name: cr_keywords cr_keywords_keyword_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_keywords
    ADD CONSTRAINT cr_keywords_keyword_id_pk PRIMARY KEY (keyword_id);


--
-- Name: cr_locales cr_locales_label_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_locales
    ADD CONSTRAINT cr_locales_label_un UNIQUE (label);


--
-- Name: cr_locales cr_locales_locale_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_locales
    ADD CONSTRAINT cr_locales_locale_pk PRIMARY KEY (locale);


--
-- Name: cr_mime_types cr_mime_types_mime_type_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_mime_types
    ADD CONSTRAINT cr_mime_types_mime_type_pk PRIMARY KEY (mime_type);


--
-- Name: cr_release_periods cr_release_periods_item_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_release_periods
    ADD CONSTRAINT cr_release_periods_item_id_pk PRIMARY KEY (item_id);


--
-- Name: cr_revision_attributes cr_revision_attributes_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_revision_attributes
    ADD CONSTRAINT cr_revision_attributes_pk PRIMARY KEY (revision_id);


--
-- Name: cr_revisions cr_revisions_revision_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_revisions
    ADD CONSTRAINT cr_revisions_revision_id_pk PRIMARY KEY (revision_id);


--
-- Name: cr_symlinks cr_symlinks_symlink_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_symlinks
    ADD CONSTRAINT cr_symlinks_symlink_id_pk PRIMARY KEY (symlink_id);


--
-- Name: cr_template_use_contexts cr_template_use_contexts_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_template_use_contexts
    ADD CONSTRAINT cr_template_use_contexts_pk PRIMARY KEY (use_context);


--
-- Name: cr_templates cr_templates_template_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_templates
    ADD CONSTRAINT cr_templates_template_id_pk PRIMARY KEY (template_id);


--
-- Name: cr_type_children cr_type_children_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_children
    ADD CONSTRAINT cr_type_children_pk PRIMARY KEY (parent_type, child_type, relation_tag);


--
-- Name: cr_type_relations cr_type_relations_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_relations
    ADD CONSTRAINT cr_type_relations_pk PRIMARY KEY (content_type, target_type, relation_tag);


--
-- Name: cr_type_template_map cr_type_template_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_template_map
    ADD CONSTRAINT cr_type_template_map_pk PRIMARY KEY (content_type, template_id, use_context);


--
-- Name: cr_xml_docs cr_xml_docs_doc_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_xml_docs
    ADD CONSTRAINT cr_xml_docs_doc_id_pk PRIMARY KEY (doc_id);


--
-- Name: currency_codes currency_codes_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.currency_codes
    ADD CONSTRAINT currency_codes_pk PRIMARY KEY (iso);


--
-- Name: dav_site_node_folder_map dav_site_node_folder_map_node_id_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.dav_site_node_folder_map
    ADD CONSTRAINT dav_site_node_folder_map_node_id_un UNIQUE (node_id);


--
-- Name: ec_addresses ec_addresses_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_addresses
    ADD CONSTRAINT ec_addresses_pkey PRIMARY KEY (address_id);


--
-- Name: ec_admin_settings ec_admin_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_admin_settings
    ADD CONSTRAINT ec_admin_settings_pkey PRIMARY KEY (admin_setting_id);


--
-- Name: ec_canned_responses ec_canned_responses_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_canned_responses
    ADD CONSTRAINT ec_canned_responses_pkey PRIMARY KEY (response_id);


--
-- Name: ec_categories ec_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_categories
    ADD CONSTRAINT ec_categories_pkey PRIMARY KEY (category_id);


--
-- Name: ec_category_product_map ec_category_product_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_category_product_map
    ADD CONSTRAINT ec_category_product_map_pkey PRIMARY KEY (product_id, category_id);


--
-- Name: ec_category_template_map ec_category_template_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_category_template_map
    ADD CONSTRAINT ec_category_template_map_pkey PRIMARY KEY (category_id);


--
-- Name: ec_creditcards ec_creditcards_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_creditcards
    ADD CONSTRAINT ec_creditcards_pkey PRIMARY KEY (creditcard_id);


--
-- Name: ec_custom_product_field_values ec_custom_product_field_values_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_custom_product_field_values
    ADD CONSTRAINT ec_custom_product_field_values_pkey PRIMARY KEY (product_id);


--
-- Name: ec_custom_product_fields ec_custom_product_fields_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_custom_product_fields
    ADD CONSTRAINT ec_custom_product_fields_pkey PRIMARY KEY (field_identifier);


--
-- Name: ec_customer_serv_interactions ec_customer_serv_interactions_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_serv_interactions
    ADD CONSTRAINT ec_customer_serv_interactions_pkey PRIMARY KEY (interaction_id);


--
-- Name: ec_customer_service_actions ec_customer_service_actions_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_service_actions
    ADD CONSTRAINT ec_customer_service_actions_pkey PRIMARY KEY (action_id);


--
-- Name: ec_customer_service_issues ec_customer_service_issues_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_service_issues
    ADD CONSTRAINT ec_customer_service_issues_pkey PRIMARY KEY (issue_id);


--
-- Name: ec_email_templates ec_email_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_email_templates
    ADD CONSTRAINT ec_email_templates_pkey PRIMARY KEY (email_template_id);


--
-- Name: ec_financial_transactions ec_financial_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_financial_transactions
    ADD CONSTRAINT ec_financial_transactions_pkey PRIMARY KEY (transaction_id);


--
-- Name: ec_gift_certificates ec_gift_certificates_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_gift_certificates
    ADD CONSTRAINT ec_gift_certificates_pkey PRIMARY KEY (gift_certificate_id);


--
-- Name: ec_items ec_items_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_items
    ADD CONSTRAINT ec_items_pkey PRIMARY KEY (item_id);


--
-- Name: ec_offers ec_offers_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_offers
    ADD CONSTRAINT ec_offers_pkey PRIMARY KEY (offer_id);


--
-- Name: ec_orders ec_orders_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_orders
    ADD CONSTRAINT ec_orders_pkey PRIMARY KEY (order_id);


--
-- Name: ec_picklist_items ec_picklist_items_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_picklist_items
    ADD CONSTRAINT ec_picklist_items_pkey PRIMARY KEY (picklist_item_id);


--
-- Name: ec_problems_log ec_problems_log_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_problems_log
    ADD CONSTRAINT ec_problems_log_pkey PRIMARY KEY (problem_id);


--
-- Name: ec_product_comments ec_product_comments_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_comments
    ADD CONSTRAINT ec_product_comments_pkey PRIMARY KEY (comment_id);


--
-- Name: ec_product_links ec_product_links_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_links
    ADD CONSTRAINT ec_product_links_pkey PRIMARY KEY (product_a, product_b);


--
-- Name: ec_product_purchase_comb ec_product_purchase_comb_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_purchase_comb
    ADD CONSTRAINT ec_product_purchase_comb_pkey PRIMARY KEY (product_id);


--
-- Name: ec_product_recommendations ec_product_recommendations_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_recommendations
    ADD CONSTRAINT ec_product_recommendations_pkey PRIMARY KEY (recommendation_id);


--
-- Name: ec_product_reviews ec_product_reviews_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_reviews
    ADD CONSTRAINT ec_product_reviews_pkey PRIMARY KEY (review_id);


--
-- Name: ec_product_series_map ec_product_series_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_series_map
    ADD CONSTRAINT ec_product_series_map_pkey PRIMARY KEY (series_id, component_id);


--
-- Name: ec_product_user_class_prices ec_product_user_class_prices_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_user_class_prices
    ADD CONSTRAINT ec_product_user_class_prices_pkey PRIMARY KEY (product_id, user_class_id);


--
-- Name: ec_products ec_products_product_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_products
    ADD CONSTRAINT ec_products_product_id_pk PRIMARY KEY (product_id);


--
-- Name: ec_refunds ec_refunds_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_refunds
    ADD CONSTRAINT ec_refunds_pkey PRIMARY KEY (refund_id);


--
-- Name: ec_retailer_locations ec_retailer_locations_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailer_locations
    ADD CONSTRAINT ec_retailer_locations_pkey PRIMARY KEY (retailer_location_id);


--
-- Name: ec_retailers ec_retailers_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailers
    ADD CONSTRAINT ec_retailers_pkey PRIMARY KEY (retailer_id);


--
-- Name: ec_sale_prices ec_sale_prices_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_sale_prices
    ADD CONSTRAINT ec_sale_prices_pkey PRIMARY KEY (sale_price_id);


--
-- Name: ec_sales_tax_by_state ec_sales_tax_by_state_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_sales_tax_by_state
    ADD CONSTRAINT ec_sales_tax_by_state_pkey PRIMARY KEY (usps_abbrev);


--
-- Name: ec_user_sessions ec_session_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_sessions
    ADD CONSTRAINT ec_session_id_pk PRIMARY KEY (user_session_id);


--
-- Name: ec_shipments ec_shipments_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_shipments
    ADD CONSTRAINT ec_shipments_pkey PRIMARY KEY (shipment_id);


--
-- Name: ec_spam_log ec_spam_log_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_spam_log
    ADD CONSTRAINT ec_spam_log_pkey PRIMARY KEY (spam_id);


--
-- Name: ec_subcategories ec_subcategories_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subcategories
    ADD CONSTRAINT ec_subcategories_pkey PRIMARY KEY (subcategory_id);


--
-- Name: ec_subcategory_product_map ec_subcategory_product_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subcategory_product_map
    ADD CONSTRAINT ec_subcategory_product_map_pkey PRIMARY KEY (product_id, subcategory_id);


--
-- Name: ec_subsubcategories ec_subsubcategories_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subsubcategories
    ADD CONSTRAINT ec_subsubcategories_pkey PRIMARY KEY (subsubcategory_id);


--
-- Name: ec_subsubcategory_product_map ec_subsubcategory_product_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subsubcategory_product_map
    ADD CONSTRAINT ec_subsubcategory_product_map_pkey PRIMARY KEY (product_id, subsubcategory_id);


--
-- Name: ec_templates ec_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_templates
    ADD CONSTRAINT ec_templates_pkey PRIMARY KEY (template_id);


--
-- Name: ec_user_class_user_map ec_user_class_user_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_class_user_map
    ADD CONSTRAINT ec_user_class_user_map_pkey PRIMARY KEY (user_id, user_class_id);


--
-- Name: ec_user_classes ec_user_classes_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_classes
    ADD CONSTRAINT ec_user_classes_pkey PRIMARY KEY (user_class_id);


--
-- Name: ec_user_identification ec_user_identification_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_identification
    ADD CONSTRAINT ec_user_identification_pkey PRIMARY KEY (user_identification_id);


--
-- Name: ec_user_session_offer_codes ec_user_session_offer_codes_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_session_offer_codes
    ADD CONSTRAINT ec_user_session_offer_codes_pkey PRIMARY KEY (user_session_id, product_id);


--
-- Name: ecds_categories_map ecds_categories_map_cat_key_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_categories_map
    ADD CONSTRAINT ecds_categories_map_cat_key_key UNIQUE (cat_key);


--
-- Name: ecds_categories_map ecds_categories_map_category_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_categories_map
    ADD CONSTRAINT ecds_categories_map_category_id_key UNIQUE (category_id);


--
-- Name: ecds_categories_map ecds_categories_map_subcategory_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_categories_map
    ADD CONSTRAINT ecds_categories_map_subcategory_id_key UNIQUE (subcategory_id);


--
-- Name: ecds_categories_map ecds_categories_map_subsubcategory_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_categories_map
    ADD CONSTRAINT ecds_categories_map_subsubcategory_id_key UNIQUE (subsubcategory_id);


--
-- Name: ecds_categories ecds_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_categories
    ADD CONSTRAINT ecds_categories_pkey PRIMARY KEY (cat_key);


--
-- Name: ecds_object_templates_map ecds_object_templates_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_object_templates_map
    ADD CONSTRAINT ecds_object_templates_map_pkey PRIMARY KEY (object_id);


--
-- Name: ecds_process_control ecds_process_control_process_ref_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_process_control
    ADD CONSTRAINT ecds_process_control_process_ref_key UNIQUE (process_ref);


--
-- Name: ecds_product_id_site_url_map ecds_product_id_site_url_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_product_id_site_url_map
    ADD CONSTRAINT ecds_product_id_site_url_map_pkey PRIMARY KEY (site_url);


--
-- Name: ecds_product_id_site_url_map ecds_product_id_site_url_map_product_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_product_id_site_url_map
    ADD CONSTRAINT ecds_product_id_site_url_map_product_id_key UNIQUE (product_id);


--
-- Name: ecds_templates ecds_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_templates
    ADD CONSTRAINT ecds_templates_pkey PRIMARY KEY (template_id);


--
-- Name: ecds_vendors ecds_vendors_abbrev_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ecds_vendors
    ADD CONSTRAINT ecds_vendors_abbrev_key UNIQUE (abbrev);


--
-- Name: ee_bookings ee_bookings_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_bookings
    ADD CONSTRAINT ee_bookings_id_pk PRIMARY KEY (booking_id);


--
-- Name: ee_item_offers ee_i_o_offer_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_offers
    ADD CONSTRAINT ee_i_o_offer_id_pk PRIMARY KEY (offer_id);


--
-- Name: ee_item_policies ee_i_p_policy_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_policies
    ADD CONSTRAINT ee_i_p_policy_id_pk PRIMARY KEY (policy_id);


--
-- Name: ee_item_sales ee_i_s_sale_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_sales
    ADD CONSTRAINT ee_i_s_sale_id_pk PRIMARY KEY (sale_id);


--
-- Name: ee_items ee_items_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_items
    ADD CONSTRAINT ee_items_pk PRIMARY KEY (ee_item_id);


--
-- Name: ee_leads ee_leads_lead_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_leads
    ADD CONSTRAINT ee_leads_lead_id_pk PRIMARY KEY (lead_id);


--
-- Name: ee_object_category_map ee_map_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_object_category_map
    ADD CONSTRAINT ee_map_id_pk PRIMARY KEY (map_id);


--
-- Name: ee_proposals ee_proposals_proposal_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_proposals
    ADD CONSTRAINT ee_proposals_proposal_id_pk PRIMARY KEY (proposal_id);


--
-- Name: ee_qa_item_category_score ee_qa_ics_item_category_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_qa_item_category_score
    ADD CONSTRAINT ee_qa_ics_item_category_id_pk PRIMARY KEY (item_id, category_id);


--
-- Name: ee_qa_item_info ee_qa_ii_item_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_qa_item_info
    ADD CONSTRAINT ee_qa_ii_item_id_pk PRIMARY KEY (item_id);


--
-- Name: ee_rooms ee_room_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_rooms
    ADD CONSTRAINT ee_room_id_pk PRIMARY KEY (room_id);


--
-- Name: ee_services ee_services_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_services
    ADD CONSTRAINT ee_services_id_pk PRIMARY KEY (service_id);


--
-- Name: ee_venues ee_venues_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_venues
    ADD CONSTRAINT ee_venues_id_pk PRIMARY KEY (venue_id);


--
-- Name: ee_wish_list_items ee_wli_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_wish_list_items
    ADD CONSTRAINT ee_wli_id_pk PRIMARY KEY (wishlist_id);


--
-- Name: email_images email_images_user_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.email_images
    ADD CONSTRAINT email_images_user_id_pk PRIMARY KEY (user_id);


--
-- Name: faq_q_and_as faq_q_sand_a_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.faq_q_and_as
    ADD CONSTRAINT faq_q_sand_a_pk PRIMARY KEY (entry_id);


--
-- Name: faqs faqs_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.faqs
    ADD CONSTRAINT faqs_pk PRIMARY KEY (faq_id);


--
-- Name: file_storage_object_t file_storage_object_t_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.file_storage_object_t
    ADD CONSTRAINT file_storage_object_t_pk PRIMARY KEY (file_storage_object_id);


--
-- Name: fs_root_folders fs_root_folder_folder_id_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.fs_root_folders
    ADD CONSTRAINT fs_root_folder_folder_id_un UNIQUE (folder_id);


--
-- Name: fs_root_folders fs_root_folder_package_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.fs_root_folders
    ADD CONSTRAINT fs_root_folder_package_id_pk PRIMARY KEY (package_id);


--
-- Name: fs_rss_subscrs fs_rss_subscrs_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.fs_rss_subscrs
    ADD CONSTRAINT fs_rss_subscrs_pk PRIMARY KEY (subscr_id);


--
-- Name: general_comments general_comments_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.general_comments
    ADD CONSTRAINT general_comments_pk PRIMARY KEY (comment_id);


--
-- Name: general_objects general_objects_object_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.general_objects
    ADD CONSTRAINT general_objects_object_id_pk PRIMARY KEY (object_id);


--
-- Name: general_objects general_objects_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.general_objects
    ADD CONSTRAINT general_objects_un UNIQUE (on_which_table, on_what_id);


--
-- Name: group_element_index group_element_index_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_element_index
    ADD CONSTRAINT group_element_index_pk PRIMARY KEY (element_id, group_id, rel_id);


--
-- Name: group_rels group_rels_group_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_rels
    ADD CONSTRAINT group_rels_group_rel_id_pk PRIMARY KEY (group_rel_id);


--
-- Name: group_rels group_rels_group_rel_type_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_rels
    ADD CONSTRAINT group_rels_group_rel_type_un UNIQUE (group_id, rel_type);


--
-- Name: group_types group_types_group_type_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_types
    ADD CONSTRAINT group_types_group_type_pk PRIMARY KEY (group_type);


--
-- Name: groups groups_group_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.groups
    ADD CONSTRAINT groups_group_id_pk PRIMARY KEY (group_id);


--
-- Name: group_type_rels gtr_group_rel_type_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_type_rels
    ADD CONSTRAINT gtr_group_rel_type_id_pk PRIMARY KEY (group_rel_type_id);


--
-- Name: group_type_rels gtr_group_rel_types_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_type_rels
    ADD CONSTRAINT gtr_group_rel_types_un UNIQUE (group_type, rel_type);


--
-- Name: host_node_map host_node_map_host_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.host_node_map
    ADD CONSTRAINT host_node_map_host_pk PRIMARY KEY (host);


--
-- Name: im_biz_object_urls im_biz_obj_urls_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_urls
    ADD CONSTRAINT im_biz_obj_urls_pk PRIMARY KEY (object_type, url_type);


--
-- Name: im_biz_object_groups im_biz_object_groups_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_groups
    ADD CONSTRAINT im_biz_object_groups_id_pk PRIMARY KEY (group_id);


--
-- Name: im_biz_objects im_biz_object_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_objects
    ADD CONSTRAINT im_biz_object_id_pk PRIMARY KEY (object_id);


--
-- Name: im_biz_object_members im_biz_object_members_rel_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_members
    ADD CONSTRAINT im_biz_object_members_rel_pk PRIMARY KEY (rel_id);


--
-- Name: im_biz_object_tree_status im_biz_object_tree_status_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_tree_status
    ADD CONSTRAINT im_biz_object_tree_status_pkey PRIMARY KEY (object_id, user_id, page_url);


--
-- Name: im_categories im_categories_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_categories
    ADD CONSTRAINT im_categories_pk PRIMARY KEY (category_id);


--
-- Name: im_component_plugin_user_map im_comp_plugin_user_map_plugin_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_component_plugin_user_map
    ADD CONSTRAINT im_comp_plugin_user_map_plugin_pk PRIMARY KEY (plugin_id, user_id);


--
-- Name: im_companies im_companies_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_name_un UNIQUE (company_name);


--
-- Name: im_companies im_companies_path_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_path_un UNIQUE (company_path);


--
-- Name: im_companies im_companies_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_pk PRIMARY KEY (company_id);


--
-- Name: im_company_employee_rels im_company_employee_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_company_employee_rels
    ADD CONSTRAINT im_company_employee_rel_id_pk PRIMARY KEY (employee_rel_id);


--
-- Name: im_component_plugins im_component_plugin_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_component_plugins
    ADD CONSTRAINT im_component_plugin_id_pk PRIMARY KEY (plugin_id);


--
-- Name: im_component_plugins im_component_plugins_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_component_plugins
    ADD CONSTRAINT im_component_plugins_un UNIQUE (plugin_name, package_name);


--
-- Name: im_dynfield_attributes im_dynfield_attr_attr_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_attributes
    ADD CONSTRAINT im_dynfield_attr_attr_id_pk PRIMARY KEY (attribute_id);


--
-- Name: im_dynfield_attributes im_dynfield_attributes_acs_attribute_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_attributes
    ADD CONSTRAINT im_dynfield_attributes_acs_attribute_un UNIQUE (acs_attribute_id);


--
-- Name: im_dynfield_layout_pages im_dynfield_layout_pages_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_layout_pages
    ADD CONSTRAINT im_dynfield_layout_pages_pk PRIMARY KEY (page_url, object_type);


--
-- Name: im_dynfield_layout im_dynfield_layout_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_layout
    ADD CONSTRAINT im_dynfield_layout_pk PRIMARY KEY (attribute_id, page_url);


--
-- Name: im_dynfield_page_fields im_dynfield_page_fields_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_page_fields
    ADD CONSTRAINT im_dynfield_page_fields_pk PRIMARY KEY (field_id);


--
-- Name: im_dynfield_pages im_dynfield_pages_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_pages
    ADD CONSTRAINT im_dynfield_pages_pk PRIMARY KEY (page_id);


--
-- Name: im_dynfield_type_attribute_map im_dynfield_type_attribute_map_attribute_id_object_type_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_type_attribute_map
    ADD CONSTRAINT im_dynfield_type_attribute_map_attribute_id_object_type_id_key UNIQUE (attribute_id, object_type_id);


--
-- Name: im_dynfield_widgets im_dynfield_widgets_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_widgets
    ADD CONSTRAINT im_dynfield_widgets_name_un UNIQUE (widget_name);


--
-- Name: im_dynfield_widgets im_dynfield_widgets_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_widgets
    ADD CONSTRAINT im_dynfield_widgets_pk PRIMARY KEY (widget_id);


--
-- Name: im_key_account_rels im_key_account_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_key_account_rels
    ADD CONSTRAINT im_key_account_rel_id_pk PRIMARY KEY (key_account_rel_id);


--
-- Name: im_menus im_menu_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_menus
    ADD CONSTRAINT im_menu_id_pk PRIMARY KEY (menu_id);


--
-- Name: im_menus im_menus_label_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_menus
    ADD CONSTRAINT im_menus_label_un UNIQUE (label);


--
-- Name: im_offices im_offices_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_offices
    ADD CONSTRAINT im_offices_name_un UNIQUE (office_name);


--
-- Name: im_offices im_offices_office_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_offices
    ADD CONSTRAINT im_offices_office_id_pk PRIMARY KEY (office_id);


--
-- Name: im_offices im_offices_path_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_offices
    ADD CONSTRAINT im_offices_path_un UNIQUE (office_path);


--
-- Name: im_profiles im_profiles_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_profiles
    ADD CONSTRAINT im_profiles_pk PRIMARY KEY (profile_id);


--
-- Name: im_project_url_map im_project_url_map_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_project_url_map
    ADD CONSTRAINT im_project_url_map_pkey PRIMARY KEY (project_id, url_type_id);


--
-- Name: im_projects im_projects_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_pk PRIMARY KEY (project_id);


--
-- Name: im_start_months im_start_months_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_start_months
    ADD CONSTRAINT im_start_months_pk PRIMARY KEY (start_block);


--
-- Name: im_start_weeks im_start_weeks_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_start_weeks
    ADD CONSTRAINT im_start_weeks_pk PRIMARY KEY (start_block);


--
-- Name: im_url_types im_url_types_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_url_types
    ADD CONSTRAINT im_url_types_pkey PRIMARY KEY (url_type_id);


--
-- Name: im_url_types im_url_types_type_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_url_types
    ADD CONSTRAINT im_url_types_type_un UNIQUE (url_type);


--
-- Name: im_view_columns im_view_columns_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_view_columns
    ADD CONSTRAINT im_view_columns_pk PRIMARY KEY (column_id);


--
-- Name: im_views im_views_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_views
    ADD CONSTRAINT im_views_pk PRIMARY KEY (view_id);


--
-- Name: im_views im_views_view_name_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_views
    ADD CONSTRAINT im_views_view_name_key UNIQUE (view_name);


--
-- Name: images images_image_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.images
    ADD CONSTRAINT images_image_id_pk PRIMARY KEY (image_id);


--
-- Name: itu_codes itu_code_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.itu_codes
    ADD CONSTRAINT itu_code_pk PRIMARY KEY (itu_id);


--
-- Name: itu_notes itu_notes_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.itu_notes
    ADD CONSTRAINT itu_notes_id_pk PRIMARY KEY (note_id);


--
-- Name: itu_notes itu_notes_note_uq; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.itu_notes
    ADD CONSTRAINT itu_notes_note_uq UNIQUE (note);


--
-- Name: iurix_mails iurix_mails_mail_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.iurix_mails
    ADD CONSTRAINT iurix_mails_mail_id_pk PRIMARY KEY (mail_id);


--
-- Name: journal_entries journal_entries_journal_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.journal_entries
    ADD CONSTRAINT journal_entries_journal_id_pk PRIMARY KEY (journal_id);


--
-- Name: lang_message_keys lang_message_keys_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_message_keys
    ADD CONSTRAINT lang_message_keys_pk PRIMARY KEY (message_key, package_key);


--
-- Name: lang_messages_audit lang_messages_audit_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_messages_audit
    ADD CONSTRAINT lang_messages_audit_pk PRIMARY KEY (audit_id);


--
-- Name: lang_messages lang_messages_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_messages
    ADD CONSTRAINT lang_messages_pk PRIMARY KEY (message_key, package_key, locale);


--
-- Name: lang_translation_registry lang_translation_registry_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_translation_registry
    ADD CONSTRAINT lang_translation_registry_pk PRIMARY KEY (on_what_id, on_which_table, locale);


--
-- Name: language_639_2_codes language_codes_iso_639_2_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.language_639_2_codes
    ADD CONSTRAINT language_codes_iso_639_2_pk PRIMARY KEY (iso_639_2);


--
-- Name: language_codes language_codes_language_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.language_codes
    ADD CONSTRAINT language_codes_language_id_pk PRIMARY KEY (language_id);


--
-- Name: lob_data lob_data_lob_id_segment_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lob_data
    ADD CONSTRAINT lob_data_lob_id_segment_pk PRIMARY KEY (lob_id, segment);


--
-- Name: lobs lobs_lob_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lobs
    ADD CONSTRAINT lobs_lob_id_pk PRIMARY KEY (lob_id);


--
-- Name: lang_translate_columns ltc_column_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_translate_columns
    ADD CONSTRAINT ltc_column_id_pk PRIMARY KEY (column_id);


--
-- Name: lang_translate_columns ltc_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_translate_columns
    ADD CONSTRAINT ltc_un UNIQUE (on_which_table, on_what_column);


--
-- Name: membership_rels membership_rels_rel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.membership_rels
    ADD CONSTRAINT membership_rels_rel_id_pk PRIMARY KEY (rel_id);


--
-- Name: notification_replies notif_repl_repl_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_replies
    ADD CONSTRAINT notif_repl_repl_id_pk PRIMARY KEY (reply_id);


--
-- Name: notification_user_map notif_user_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_user_map
    ADD CONSTRAINT notif_user_map_pk PRIMARY KEY (notification_id, user_id);


--
-- Name: notification_delivery_methods notification_delivery_methods_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_delivery_methods
    ADD CONSTRAINT notification_delivery_methods_pk PRIMARY KEY (delivery_method_id);


--
-- Name: notification_email_hold notification_email_hold_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_email_hold
    ADD CONSTRAINT notification_email_hold_pk PRIMARY KEY (reply_id);


--
-- Name: notification_intervals notification_intervals_interval_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_intervals
    ADD CONSTRAINT notification_intervals_interval_id_pk PRIMARY KEY (interval_id);


--
-- Name: notification_intervals notification_intervals_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_intervals
    ADD CONSTRAINT notification_intervals_name_un UNIQUE (name);


--
-- Name: notification_types notification_type_short_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types
    ADD CONSTRAINT notification_type_short_name_un UNIQUE (short_name);


--
-- Name: notification_types notification_types_type_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types
    ADD CONSTRAINT notification_types_type_id_pk PRIMARY KEY (type_id);


--
-- Name: notification_delivery_methods notifications_delivery_methods_short_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_delivery_methods
    ADD CONSTRAINT notifications_delivery_methods_short_name_un UNIQUE (short_name);


--
-- Name: notifications notifications_notification_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_notification_id_pk PRIMARY KEY (notification_id);


--
-- Name: notification_requests notifications_request_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_requests
    ADD CONSTRAINT notifications_request_id_pk PRIMARY KEY (request_id);


--
-- Name: notification_types_del_methods notifications_type_deliv_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types_del_methods
    ADD CONSTRAINT notifications_type_deliv_pk PRIMARY KEY (type_id, delivery_method_id);


--
-- Name: notification_types_intervals notifications_type_int_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types_intervals
    ADD CONSTRAINT notifications_type_int_pk PRIMARY KEY (type_id, interval_id);


--
-- Name: organizations orga_client_id_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT orga_client_id_un UNIQUE (client_id);


--
-- Name: organizations organization_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT organization_id_pk PRIMARY KEY (organization_id);


--
-- Name: pa_albums pa_albums_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_albums
    ADD CONSTRAINT pa_albums_id_pk PRIMARY KEY (pa_album_id);


--
-- Name: pa_collection_photo_map pa_collection_photo_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_collection_photo_map
    ADD CONSTRAINT pa_collection_photo_map_pk PRIMARY KEY (collection_id, photo_id);


--
-- Name: pa_collections pa_collections_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_collections
    ADD CONSTRAINT pa_collections_pk PRIMARY KEY (collection_id);


--
-- Name: pa_package_root_folder_map pa_pack_fldr_map_fldr_id_unq; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_package_root_folder_map
    ADD CONSTRAINT pa_pack_fldr_map_fldr_id_unq UNIQUE (folder_id);


--
-- Name: pa_package_root_folder_map pa_pack_fldr_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_package_root_folder_map
    ADD CONSTRAINT pa_pack_fldr_map_pk PRIMARY KEY (package_id);


--
-- Name: pa_photos pa_photo_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_photos
    ADD CONSTRAINT pa_photo_pk PRIMARY KEY (pa_photo_id);


--
-- Name: parties parties_email_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.parties
    ADD CONSTRAINT parties_email_un UNIQUE (email);


--
-- Name: parties parties_party_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.parties
    ADD CONSTRAINT parties_party_id_pk PRIMARY KEY (party_id);


--
-- Name: party_approved_member_map party_approved_member_map_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.party_approved_member_map
    ADD CONSTRAINT party_approved_member_map_pk PRIMARY KEY (party_id, member_id, originating_rel_id);


--
-- Name: persons persons_person_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.persons
    ADD CONSTRAINT persons_person_id_pk PRIMARY KEY (person_id);


--
-- Name: phone_types phone_types_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.phone_types
    ADD CONSTRAINT phone_types_id_pk PRIMARY KEY (phone_type_id);


--
-- Name: pinds_blog_categories pinds_blog_categories_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pinds_blog_categories
    ADD CONSTRAINT pinds_blog_categories_pk PRIMARY KEY (category_id);


--
-- Name: pinds_blog_entries pinds_blog_entries_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pinds_blog_entries
    ADD CONSTRAINT pinds_blog_entries_pk PRIMARY KEY (entry_id);


--
-- Name: pm_aggregate pm_aggregate_user_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_aggregate
    ADD CONSTRAINT pm_aggregate_user_id_key UNIQUE (user_id);


--
-- Name: pm_preference pm_preference_user_id_key; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_preference
    ADD CONSTRAINT pm_preference_user_id_key UNIQUE (user_id);


--
-- Name: pm_queue pm_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_queue
    ADD CONSTRAINT pm_queue_pkey PRIMARY KEY (id);


--
-- Name: postal_addresses postal__address_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.postal_addresses
    ADD CONSTRAINT postal__address_id_pk PRIMARY KEY (address_id);


--
-- Name: postal_types postal_types_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.postal_types
    ADD CONSTRAINT postal_types_id_pk PRIMARY KEY (type_id);


--
-- Name: rc_segment_required_seg_map rc_segment_required_seg_map_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rc_segment_required_seg_map
    ADD CONSTRAINT rc_segment_required_seg_map_un UNIQUE (rel_segment, rel_side, required_rel_segment);


--
-- Name: recurrence_interval_types recurrence_interval_type_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.recurrence_interval_types
    ADD CONSTRAINT recurrence_interval_type_pk PRIMARY KEY (interval_type);


--
-- Name: recurrences recurrences_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.recurrences
    ADD CONSTRAINT recurrences_pk PRIMARY KEY (recurrence_id);


--
-- Name: rel_constraints rel_constraints_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_constraints
    ADD CONSTRAINT rel_constraints_pk PRIMARY KEY (constraint_id);


--
-- Name: rel_constraints rel_constraints_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_constraints
    ADD CONSTRAINT rel_constraints_un UNIQUE (rel_segment, rel_side, required_rel_segment);


--
-- Name: rel_segments rel_segments_grp_rel_type_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_segments
    ADD CONSTRAINT rel_segments_grp_rel_type_un UNIQUE (group_id, rel_type);


--
-- Name: rel_segments rel_segments_segment_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_segments
    ADD CONSTRAINT rel_segments_segment_id_pk PRIMARY KEY (segment_id);


--
-- Name: recurrence_interval_types rit_interval_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.recurrence_interval_types
    ADD CONSTRAINT rit_interval_name_un UNIQUE (interval_name);


--
-- Name: rss_gen_subscrs rss_gen_subscrs_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_id_pk PRIMARY KEY (subscr_id);


--
-- Name: rss_gen_subscrs rss_gen_subscrs_impl_con_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_impl_con_un UNIQUE (impl_id, summary_context_id);


--
-- Name: sec_session_properties sec_session_prop_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.sec_session_properties
    ADD CONSTRAINT sec_session_prop_pk PRIMARY KEY (session_id, module, property_name);


--
-- Name: secret_tokens secret_tokens_token_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.secret_tokens
    ADD CONSTRAINT secret_tokens_token_id_pk PRIMARY KEY (token_id);


--
-- Name: subsite_callbacks sgc_callback_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.subsite_callbacks
    ADD CONSTRAINT sgc_callback_id_pk PRIMARY KEY (callback_id);


--
-- Name: site_node_object_mappings site_node_object_mappings_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_node_object_mappings
    ADD CONSTRAINT site_node_object_mappings_pk PRIMARY KEY (object_id);


--
-- Name: site_nodes_selection site_node_sel_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_nodes_selection
    ADD CONSTRAINT site_node_sel_id_pk PRIMARY KEY (node_id);


--
-- Name: site_nodes site_nodes_node_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_nodes
    ADD CONSTRAINT site_nodes_node_id_pk PRIMARY KEY (node_id);


--
-- Name: site_nodes site_nodes_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_nodes
    ADD CONSTRAINT site_nodes_un UNIQUE (parent_id, name);


--
-- Name: subsite_callbacks subsite_callbacks_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.subsite_callbacks
    ADD CONSTRAINT subsite_callbacks_un UNIQUE (object_type, event_type, callback_type, callback);


--
-- Name: subsite_themes subsite_themes_key_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.subsite_themes
    ADD CONSTRAINT subsite_themes_key_pk PRIMARY KEY (key);


--
-- Name: syndication syndication_object_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.syndication
    ADD CONSTRAINT syndication_object_id_pk PRIMARY KEY (object_id);


--
-- Name: telecom_numbers telecom_number_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.telecom_numbers
    ADD CONSTRAINT telecom_number_id_pk PRIMARY KEY (number_id);


--
-- Name: template_demo_notes template_demo_notes_note_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.template_demo_notes
    ADD CONSTRAINT template_demo_notes_note_id_pk PRIMARY KEY (template_demo_note_id);


--
-- Name: time_intervals time_intervals_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.time_intervals
    ADD CONSTRAINT time_intervals_pk PRIMARY KEY (interval_id);


--
-- Name: timezones timezones_tz_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.timezones
    ADD CONSTRAINT timezones_tz_id_pk PRIMARY KEY (tz_id);


--
-- Name: user_ext_info uei_user_id_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_ext_info
    ADD CONSTRAINT uei_user_id_un UNIQUE (user_id);


--
-- Name: user_ext_info uei_userinfo_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_ext_info
    ADD CONSTRAINT uei_userinfo_id_pk PRIMARY KEY (userinfo_id);


--
-- Name: user_payments up_payment_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_payments
    ADD CONSTRAINT up_payment_id_pk PRIMARY KEY (payment_id);


--
-- Name: user_payments up_user_id_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_payments
    ADD CONSTRAINT up_user_id_un UNIQUE (user_id);


--
-- Name: us_counties us_counties_unique_fips_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.us_counties
    ADD CONSTRAINT us_counties_unique_fips_pk PRIMARY KEY (fips_county_code, fips_state_code);


--
-- Name: us_states us_states_abbrev_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.us_states
    ADD CONSTRAINT us_states_abbrev_pk PRIMARY KEY (abbrev);


--
-- Name: us_states us_states_fips_state_code_uq; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.us_states
    ADD CONSTRAINT us_states_fips_state_code_uq UNIQUE (fips_state_code);


--
-- Name: us_states us_states_state_name_uq; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.us_states
    ADD CONSTRAINT us_states_state_name_uq UNIQUE (state_name);


--
-- Name: us_zipcodes us_zipcodes_unique_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.us_zipcodes
    ADD CONSTRAINT us_zipcodes_unique_pk PRIMARY KEY (zipcode, fips_state_code);


--
-- Name: user_portraits user_portraits_user_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_portraits
    ADD CONSTRAINT user_portraits_user_id_pk PRIMARY KEY (user_id);


--
-- Name: user_preferences user_preferences_user_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT user_preferences_user_id_pk PRIMARY KEY (user_id);


--
-- Name: users users_authority_username_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_authority_username_un UNIQUE (authority_id, username);


--
-- Name: users_contact users_contact_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users_contact
    ADD CONSTRAINT users_contact_pk PRIMARY KEY (user_id);


--
-- Name: users_email_image users_email_image_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users_email_image
    ADD CONSTRAINT users_email_image_pk PRIMARY KEY (email_image_id);


--
-- Name: users users_screen_name_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_screen_name_un UNIQUE (screen_name);


--
-- Name: users users_user_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_user_id_pk PRIMARY KEY (user_id);


--
-- Name: weblogger_blogroll_entries weblogger_blogroll_entries_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_blogroll_entries
    ADD CONSTRAINT weblogger_blogroll_entries_id_pk PRIMARY KEY (link_id);


--
-- Name: weblogger_channels weblogger_channels_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_channels
    ADD CONSTRAINT weblogger_channels_pk PRIMARY KEY (channel_id);


--
-- Name: weblogger_channels weblogger_chnls_package_user_un; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_channels
    ADD CONSTRAINT weblogger_chnls_package_user_un UNIQUE (package_id, user_id);


--
-- Name: weblogger_ping_urls weblogger_ping_urls_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_ping_urls
    ADD CONSTRAINT weblogger_ping_urls_pk PRIMARY KEY (package_id, ping_url);


--
-- Name: xowf_package xowf_package_package_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowf_package
    ADD CONSTRAINT xowf_package_package_id_pk PRIMARY KEY (package_id);


--
-- Name: xowiki_file xowiki_file_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_file
    ADD CONSTRAINT xowiki_file_pk PRIMARY KEY (file_id);


--
-- Name: xowiki_form_page xowiki_form_page_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form_page
    ADD CONSTRAINT xowiki_form_page_pk PRIMARY KEY (xowiki_form_page_id);


--
-- Name: xowiki_form xowiki_form_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form
    ADD CONSTRAINT xowiki_form_pk PRIMARY KEY (xowiki_form_id);


--
-- Name: xowiki_object xowiki_object_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_object
    ADD CONSTRAINT xowiki_object_pk PRIMARY KEY (xowiki_object_id);


--
-- Name: xowiki_package xowiki_package_package_id_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_package
    ADD CONSTRAINT xowiki_package_package_id_pk PRIMARY KEY (package_id);


--
-- Name: xowiki_page_instance xowiki_page_instance_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_page_instance
    ADD CONSTRAINT xowiki_page_instance_pk PRIMARY KEY (page_instance_id);


--
-- Name: xowiki_page xowiki_page_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_page
    ADD CONSTRAINT xowiki_page_pk PRIMARY KEY (page_id);


--
-- Name: xowiki_page_template xowiki_page_template_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_page_template
    ADD CONSTRAINT xowiki_page_template_pk PRIMARY KEY (page_template_id);


--
-- Name: xowiki_plain_page xowiki_plain_page_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_plain_page
    ADD CONSTRAINT xowiki_plain_page_pk PRIMARY KEY (ppage_id);


--
-- Name: xowiki_podcast_item xowiki_podcast_item_pk; Type: CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_podcast_item
    ADD CONSTRAINT xowiki_podcast_item_pk PRIMARY KEY (podcast_item_id);


--
-- Name: acs_attr_desc_attr_name_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_attr_desc_attr_name_idx ON public.acs_attribute_descriptions USING btree (attribute_name);


--
-- Name: acs_attr_desc_obj_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_attr_desc_obj_type_idx ON public.acs_attribute_descriptions USING btree (object_type);


--
-- Name: acs_attr_values_attr_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_attr_values_attr_id_idx ON public.acs_attribute_values USING btree (attribute_id);


--
-- Name: acs_attrs_datatype_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_attrs_datatype_idx ON public.acs_attributes USING btree (datatype);


--
-- Name: acs_attrs_obj_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_attrs_obj_type_idx ON public.acs_attributes USING btree (object_type);


--
-- Name: acs_attrs_tbl_name_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_attrs_tbl_name_idx ON public.acs_attributes USING btree (table_name);


--
-- Name: acs_data_links_id_one_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_data_links_id_one_idx ON public.acs_data_links USING btree (object_id_one);


--
-- Name: acs_data_links_id_two_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_data_links_id_two_idx ON public.acs_data_links USING btree (object_id_two);


--
-- Name: acs_data_links_rel_tag_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_data_links_rel_tag_idx ON public.acs_data_links USING btree (relation_tag);


--
-- Name: acs_enum_values_attr_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_enum_values_attr_id_idx ON public.acs_enum_values USING btree (attribute_id);


--
-- Name: acs_events_activity_id_ids; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_events_activity_id_ids ON public.acs_events USING btree (activity_id);


--
-- Name: acs_events_recurrence_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_events_recurrence_id_idx ON public.acs_events USING btree (recurrence_id);


--
-- Name: acs_messages_reply_to_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_messages_reply_to_idx ON public.acs_messages USING btree (reply_to);


--
-- Name: acs_messages_sender_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_messages_sender_idx ON public.acs_messages USING btree (sender);


--
-- Name: acs_messages_sent_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_messages_sent_idx ON public.acs_messages USING btree (sent_date);


--
-- Name: acs_messages_tree_skey_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_messages_tree_skey_idx ON public.acs_messages USING btree (tree_sortkey);


--
-- Name: acs_named_objs_name_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_named_objs_name_ix ON public.acs_named_objects USING btree (object_name);


--
-- Name: acs_named_objs_package_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_named_objs_package_ix ON public.acs_named_objects USING btree (package_id);


--
-- Name: acs_obj_ctx_idx_ancestor_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_obj_ctx_idx_ancestor_idx ON public.acs_object_context_index USING btree (ancestor_id);


--
-- Name: acs_obj_ctx_idx_object_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_obj_ctx_idx_object_id_idx ON public.acs_object_context_index USING btree (object_id);


--
-- Name: acs_obj_types_supertype_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_obj_types_supertype_idx ON public.acs_object_types USING btree (supertype);


--
-- Name: acs_obj_types_tree_skey_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_obj_types_tree_skey_idx ON public.acs_object_types USING btree (tree_sortkey);


--
-- Name: acs_objects_creation_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_objects_creation_user_idx ON public.acs_objects USING btree (creation_user);


--
-- Name: acs_objects_modify_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_objects_modify_user_idx ON public.acs_objects USING btree (modifying_user);


--
-- Name: acs_objects_object_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_objects_object_type_idx ON public.acs_objects USING btree (object_type);


--
-- Name: acs_objects_package_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_objects_package_idx ON public.acs_objects USING btree (package_id);


--
-- Name: acs_objects_title_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_objects_title_idx ON public.acs_objects USING btree (title);


--
-- Name: acs_objtype_tbls_objtype_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_objtype_tbls_objtype_idx ON public.acs_object_type_tables USING btree (object_type);


--
-- Name: acs_permissions_grantee_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_permissions_grantee_idx ON public.acs_permissions USING btree (grantee_id);


--
-- Name: acs_permissions_object_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_permissions_object_id_idx ON public.acs_permissions USING btree (object_id);


--
-- Name: acs_permissions_privilege_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_permissions_privilege_idx ON public.acs_permissions USING btree (privilege);


--
-- Name: acs_priv_desc_map_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_priv_desc_map_idx ON public.acs_privilege_descendant_map USING btree (descendant);


--
-- Name: acs_priv_desc_map_privilege_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_priv_desc_map_privilege_idx ON public.acs_privilege_descendant_map USING btree (privilege);


--
-- Name: acs_priv_hier_child_priv_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_priv_hier_child_priv_idx ON public.acs_privilege_hierarchy USING btree (child_privilege);


--
-- Name: acs_rel_types_objtypeone_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_rel_types_objtypeone_idx ON public.acs_rel_types USING btree (object_type_one);


--
-- Name: acs_rel_types_objtypetwo_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_rel_types_objtypetwo_idx ON public.acs_rel_types USING btree (object_type_two);


--
-- Name: acs_rel_types_role_one_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_rel_types_role_one_idx ON public.acs_rel_types USING btree (role_one);


--
-- Name: acs_rel_types_role_two_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_rel_types_role_two_idx ON public.acs_rel_types USING btree (role_two);


--
-- Name: acs_rels_object_id_one_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_rels_object_id_one_idx ON public.acs_rels USING btree (object_id_one);


--
-- Name: acs_rels_object_id_two_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_rels_object_id_two_idx ON public.acs_rels USING btree (object_id_two);


--
-- Name: acs_stat_attrs_attr_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX acs_stat_attrs_attr_id_idx ON public.acs_static_attr_values USING btree (attribute_id);


--
-- Name: ams_attribute_values_attribute_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ams_attribute_values_attribute_idx ON public.ams_attribute_values USING btree (attribute_id);


--
-- Name: ams_attribute_values_attribute_object_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ams_attribute_values_attribute_object_idx ON public.ams_attribute_values USING btree (object_id, attribute_id);


--
-- Name: apm_packages_package_key_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX apm_packages_package_key_idx ON public.apm_packages USING btree (package_key);


--
-- Name: apm_par_vals_parameter_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX apm_par_vals_parameter_idx ON public.apm_parameter_values USING btree (parameter_id);


--
-- Name: apm_parameters_package_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX apm_parameters_package_idx ON public.apm_parameters USING btree (package_key);


--
-- Name: apm_pkg_owners_version_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX apm_pkg_owners_version_idx ON public.apm_package_owners USING btree (version_id);


--
-- Name: attachments_fsr_fm_folder_id_i; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX attachments_fsr_fm_folder_id_i ON public.attachments_fs_root_folder_map USING btree (folder_id);


--
-- Name: attachments_item_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX attachments_item_id_idx ON public.attachments USING btree (item_id);


--
-- Name: auth_batch_job_ent_job_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX auth_batch_job_ent_job_idx ON public.auth_batch_job_entries USING btree (job_id);


--
-- Name: auth_batch_job_ent_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX auth_batch_job_ent_user_idx ON public.auth_batch_job_entries USING btree (user_id);


--
-- Name: auth_batch_jobs_auth_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX auth_batch_jobs_auth_idx ON public.auth_batch_jobs USING btree (authority_id);


--
-- Name: auth_batch_jobs_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX auth_batch_jobs_user_idx ON public.auth_batch_jobs USING btree (creation_user);


--
-- Name: cal_items_on_which_calendar_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cal_items_on_which_calendar_idx ON public.cal_items USING btree (on_which_calendar);


--
-- Name: cat_object_map_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cat_object_map_ix ON public.category_object_map USING btree (object_id, category_id);


--
-- Name: cat_tree_map_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cat_tree_map_ix ON public.category_tree_map USING btree (tree_id, object_id);


--
-- Name: categories_left_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX categories_left_ix ON public.categories USING btree (tree_id, left_ind);


--
-- Name: categories_parent_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX categories_parent_ix ON public.categories USING btree (parent_id, category_id);


--
-- Name: category_links_rev_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX category_links_rev_ix ON public.category_links USING btree (to_category_id, from_category_id);


--
-- Name: category_results_similarity_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX category_results_similarity_ix ON public.category_search_results USING btree (query_id, similarity);


--
-- Name: category_search_date_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX category_search_date_ix ON public.category_search USING btree (last_queried);


--
-- Name: category_search_ind_query_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX category_search_ind_query_ix ON public.category_search_index USING btree (query_id);


--
-- Name: category_search_ind_trigram_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX category_search_ind_trigram_ix ON public.category_search_index USING btree (trigram);


--
-- Name: category_syn_index_synonym_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX category_syn_index_synonym_ix ON public.category_synonym_index USING btree (synonym_id);


--
-- Name: category_syn_index_trigram_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX category_syn_index_trigram_ix ON public.category_synonym_index USING btree (trigram);


--
-- Name: category_synonyms_locale_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX category_synonyms_locale_ix ON public.category_synonyms USING btree (category_id, locale);


--
-- Name: category_synonyms_name_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX category_synonyms_name_ix ON public.category_synonyms USING btree (category_id, name);


--
-- Name: cr_child_rels_by_parent; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_child_rels_by_parent ON public.cr_child_rels USING btree (parent_id);


--
-- Name: cr_child_rels_child_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cr_child_rels_child_id_idx ON public.cr_child_rels USING btree (child_id);


--
-- Name: cr_child_rels_unq_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cr_child_rels_unq_id ON public.cr_child_rels USING btree (parent_id, child_id);


--
-- Name: cr_cont_mimetypmap_mimetyp_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_cont_mimetypmap_mimetyp_idx ON public.cr_content_mime_type_map USING btree (mime_type);


--
-- Name: cr_extension_mime_type_map_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_extension_mime_type_map_idx ON public.cr_extension_mime_type_map USING btree (mime_type);


--
-- Name: cr_folder_typ_map_cont_typ_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_folder_typ_map_cont_typ_idx ON public.cr_folder_type_map USING btree (content_type);


--
-- Name: cr_folders_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_folders_package_id_idx ON public.cr_folders USING btree (package_id);


--
-- Name: cr_item_keyword_map_kw_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_item_keyword_map_kw_id_idx ON public.cr_item_keyword_map USING btree (keyword_id);


--
-- Name: cr_item_publish_audit_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_item_publish_audit_idx ON public.cr_item_publish_audit USING btree (item_id);


--
-- Name: cr_item_publish_audit_nrev_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_item_publish_audit_nrev_idx ON public.cr_item_publish_audit USING btree (new_revision);


--
-- Name: cr_item_publish_audit_orev_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_item_publish_audit_orev_idx ON public.cr_item_publish_audit USING btree (old_revision);


--
-- Name: cr_item_rel_unq; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cr_item_rel_unq ON public.cr_item_rels USING btree (item_id, related_object_id, relation_tag);


--
-- Name: cr_item_rels_rel_obj_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_item_rels_rel_obj_id_idx ON public.cr_item_rels USING btree (related_object_id);


--
-- Name: cr_items_by_content_type; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_items_by_content_type ON public.cr_items USING btree (content_type);


--
-- Name: cr_items_by_latest_revision; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cr_items_by_latest_revision ON public.cr_items USING btree (latest_revision);


--
-- Name: cr_items_by_live_revision; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cr_items_by_live_revision ON public.cr_items USING btree (live_revision);


--
-- Name: cr_items_by_locale; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_items_by_locale ON public.cr_items USING btree (locale);


--
-- Name: cr_items_by_parent_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_items_by_parent_id ON public.cr_items USING btree (parent_id);


--
-- Name: cr_items_name; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_items_name ON public.cr_items USING btree (name);


--
-- Name: cr_items_tree_sortkey_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cr_items_tree_sortkey_un ON public.cr_items USING btree (tree_sortkey);


--
-- Name: cr_items_unique_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cr_items_unique_id ON public.cr_items USING btree (parent_id, item_id);


--
-- Name: cr_items_unique_name; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX cr_items_unique_name ON public.cr_items USING btree (parent_id, name);


--
-- Name: cr_itmap_by_item_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_itmap_by_item_id ON public.cr_item_template_map USING btree (item_id);


--
-- Name: cr_itmap_by_template_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_itmap_by_template_id ON public.cr_item_template_map USING btree (template_id);


--
-- Name: cr_itmap_by_use_context; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_itmap_by_use_context ON public.cr_item_template_map USING btree (use_context);


--
-- Name: cr_keywords_parent_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_keywords_parent_id_idx ON public.cr_keywords USING btree (parent_id);


--
-- Name: cr_revisions_by_mime_type; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_revisions_by_mime_type ON public.cr_revisions USING btree (mime_type);


--
-- Name: cr_revisions_content_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_revisions_content_idx ON public.cr_revisions USING btree ("substring"(content, 1, 100));


--
-- Name: cr_revisions_item_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_revisions_item_id_idx ON public.cr_revisions USING btree (item_id);


--
-- Name: cr_revisions_lob_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_revisions_lob_idx ON public.cr_revisions USING btree (lob);


--
-- Name: cr_revisions_publish_date_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_revisions_publish_date_idx ON public.cr_revisions USING btree (publish_date);


--
-- Name: cr_revisions_title_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_revisions_title_idx ON public.cr_revisions USING btree (title);


--
-- Name: cr_symlinks_by_target_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_symlinks_by_target_id ON public.cr_symlinks USING btree (target_id);


--
-- Name: cr_ttmap_by_content_type; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_ttmap_by_content_type ON public.cr_type_template_map USING btree (content_type);


--
-- Name: cr_ttmap_by_template_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_ttmap_by_template_id ON public.cr_type_template_map USING btree (template_id);


--
-- Name: cr_ttmap_by_use_context; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_ttmap_by_use_context ON public.cr_type_template_map USING btree (use_context);


--
-- Name: cr_type_children_chld_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_type_children_chld_type_idx ON public.cr_type_children USING btree (child_type);


--
-- Name: cr_type_relations_tgt_typ_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX cr_type_relations_tgt_typ_idx ON public.cr_type_relations USING btree (target_type);


--
-- Name: ec_addresses_by_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_addresses_by_user_idx ON public.ec_addresses USING btree (user_id);


--
-- Name: ec_auto_email_by_gc_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_auto_email_by_gc_idx ON public.ec_automatic_email_log USING btree (gift_certificate_id);


--
-- Name: ec_auto_email_by_order_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_auto_email_by_order_idx ON public.ec_automatic_email_log USING btree (order_id);


--
-- Name: ec_auto_email_by_shipment_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_auto_email_by_shipment_idx ON public.ec_automatic_email_log USING btree (shipment_id);


--
-- Name: ec_auto_email_by_temp_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_auto_email_by_temp_idx ON public.ec_automatic_email_log USING btree (email_template_id);


--
-- Name: ec_auto_email_by_usr_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_auto_email_by_usr_id_idx ON public.ec_automatic_email_log USING btree (user_identification_id);


--
-- Name: ec_cat_mailing_list_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_cat_mailing_list_idx ON public.ec_cat_mailing_lists USING btree (user_id);


--
-- Name: ec_cat_mailing_list_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_cat_mailing_list_idx2 ON public.ec_cat_mailing_lists USING btree (category_id);


--
-- Name: ec_cat_mailing_list_idx3; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_cat_mailing_list_idx3 ON public.ec_cat_mailing_lists USING btree (subcategory_id);


--
-- Name: ec_cat_mailing_list_idx4; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_cat_mailing_list_idx4 ON public.ec_cat_mailing_lists USING btree (subsubcategory_id);


--
-- Name: ec_categories_sort_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_categories_sort_idx ON public.ec_categories USING btree (sort_key);


--
-- Name: ec_category_product_map_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_category_product_map_idx ON public.ec_category_product_map USING btree (category_id);


--
-- Name: ec_category_product_map_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_category_product_map_idx2 ON public.ec_category_product_map USING btree (publisher_favorite_p);


--
-- Name: ec_category_template_map_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_category_template_map_idx ON public.ec_category_template_map USING btree (template_id);


--
-- Name: ec_creditcards_by_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_creditcards_by_user_idx ON public.ec_creditcards USING btree (user_id);


--
-- Name: ec_csa_by_issue; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_csa_by_issue ON public.ec_customer_service_actions USING btree (issue_id);


--
-- Name: ec_csaium_by_action_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_csaium_by_action_id ON public.ec_cs_action_info_used_map USING btree (action_id);


--
-- Name: ec_csaium_by_info_used; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_csaium_by_info_used ON public.ec_cs_action_info_used_map USING btree (info_used);


--
-- Name: ec_csi_by_open_date; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_csi_by_open_date ON public.ec_customer_service_issues USING btree (open_date);


--
-- Name: ec_csi_by_user_ident_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_csi_by_user_ident_id ON public.ec_customer_service_issues USING btree (user_identification_id);


--
-- Name: ec_csin_by_user_ident_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_csin_by_user_ident_id ON public.ec_customer_serv_interactions USING btree (user_identification_id);


--
-- Name: ec_csitm_by_issue_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_csitm_by_issue_id ON public.ec_cs_issue_type_map USING btree (issue_id);


--
-- Name: ec_csitm_by_issue_type; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_csitm_by_issue_type ON public.ec_cs_issue_type_map USING btree (issue_type);


--
-- Name: ec_finan_trans_by_cc_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_finan_trans_by_cc_idx ON public.ec_financial_transactions USING btree (creditcard_id);


--
-- Name: ec_finan_trans_by_gc_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_finan_trans_by_gc_idx ON public.ec_financial_transactions USING btree (gift_certificate_id);


--
-- Name: ec_finan_trans_by_order_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_finan_trans_by_order_idx ON public.ec_financial_transactions USING btree (order_id);


--
-- Name: ec_gc_by_amount_remaining; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_gc_by_amount_remaining ON public.ec_gift_certificates USING btree (amount_remaining_p);


--
-- Name: ec_gc_by_claim_check; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_gc_by_claim_check ON public.ec_gift_certificates USING btree (claim_check);


--
-- Name: ec_gc_by_state; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_gc_by_state ON public.ec_gift_certificates USING btree (gift_certificate_state);


--
-- Name: ec_gc_by_user; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_gc_by_user ON public.ec_gift_certificates USING btree (user_id);


--
-- Name: ec_gift_cert_by_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_gift_cert_by_id ON public.ec_gift_certificate_usage USING btree (gift_certificate_id);


--
-- Name: ec_items_by_order; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_items_by_order ON public.ec_items USING btree (order_id);


--
-- Name: ec_items_by_product; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_items_by_product ON public.ec_items USING btree (product_id);


--
-- Name: ec_items_by_shipment; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_items_by_shipment ON public.ec_items USING btree (shipment_id);


--
-- Name: ec_orders_by_addr_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_orders_by_addr_idx ON public.ec_orders USING btree (shipping_address);


--
-- Name: ec_orders_by_conf_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_orders_by_conf_idx ON public.ec_orders USING btree (confirmed_date);


--
-- Name: ec_orders_by_credit_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_orders_by_credit_idx ON public.ec_orders USING btree (creditcard_id);


--
-- Name: ec_orders_by_state_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_orders_by_state_idx ON public.ec_orders USING btree (order_state);


--
-- Name: ec_orders_by_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_orders_by_user_idx ON public.ec_orders USING btree (user_id);


--
-- Name: ec_orders_by_user_sess_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_orders_by_user_sess_idx ON public.ec_orders USING btree (user_session_id);


--
-- Name: ec_product_comments_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_comments_idx ON public.ec_product_comments USING btree (product_id);


--
-- Name: ec_product_comments_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_comments_idx2 ON public.ec_product_comments USING btree (user_id);


--
-- Name: ec_product_comments_idx3; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_comments_idx3 ON public.ec_product_comments USING btree (approved_p);


--
-- Name: ec_product_links_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_links_idx ON public.ec_product_links USING btree (product_b);


--
-- Name: ec_product_purchase_comb_idx0; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_purchase_comb_idx0 ON public.ec_product_purchase_comb USING btree (product_0);


--
-- Name: ec_product_purchase_comb_idx1; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_purchase_comb_idx1 ON public.ec_product_purchase_comb USING btree (product_1);


--
-- Name: ec_product_purchase_comb_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_purchase_comb_idx2 ON public.ec_product_purchase_comb USING btree (product_2);


--
-- Name: ec_product_purchase_comb_idx3; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_purchase_comb_idx3 ON public.ec_product_purchase_comb USING btree (product_3);


--
-- Name: ec_product_purchase_comb_idx4; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_purchase_comb_idx4 ON public.ec_product_purchase_comb USING btree (product_4);


--
-- Name: ec_product_recommendation_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_recommendation_idx ON public.ec_product_recommendations USING btree (category_id);


--
-- Name: ec_product_recommendation_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_recommendation_idx2 ON public.ec_product_recommendations USING btree (subcategory_id);


--
-- Name: ec_product_recommendation_idx3; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_recommendation_idx3 ON public.ec_product_recommendations USING btree (subsubcategory_id);


--
-- Name: ec_product_recommendation_idx4; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_recommendation_idx4 ON public.ec_product_recommendations USING btree (user_class_id);


--
-- Name: ec_product_recommendation_idx5; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_recommendation_idx5 ON public.ec_product_recommendations USING btree (active_p);


--
-- Name: ec_product_reviews_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_reviews_idx ON public.ec_product_reviews USING btree (product_id);


--
-- Name: ec_product_reviews_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_reviews_idx2 ON public.ec_product_reviews USING btree (display_p);


--
-- Name: ec_product_series_map_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_series_map_idx2 ON public.ec_product_series_map USING btree (component_id);


--
-- Name: ec_product_user_class_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_product_user_class_idx ON public.ec_product_user_class_prices USING btree (user_class_id);


--
-- Name: ec_refunds_by_order_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_refunds_by_order_idx ON public.ec_refunds USING btree (order_id);


--
-- Name: ec_sale_prices_by_product_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_sale_prices_by_product_idx ON public.ec_sale_prices USING btree (product_id);


--
-- Name: ec_shipments_by_order_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_shipments_by_order_id ON public.ec_shipments USING btree (order_id);


--
-- Name: ec_shipments_by_shipment_date; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_shipments_by_shipment_date ON public.ec_shipments USING btree (shipment_date);


--
-- Name: ec_spam_log_by_cat_mail_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_spam_log_by_cat_mail_idx ON public.ec_spam_log USING btree (mailing_list_category_id);


--
-- Name: ec_spam_log_by_cat_mail_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_spam_log_by_cat_mail_idx2 ON public.ec_spam_log USING btree (mailing_list_subcategory_id);


--
-- Name: ec_spam_log_by_cat_mail_idx3; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_spam_log_by_cat_mail_idx3 ON public.ec_spam_log USING btree (mailing_list_subsubcategory_id);


--
-- Name: ec_spam_log_by_product_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_spam_log_by_product_idx ON public.ec_spam_log USING btree (product_id);


--
-- Name: ec_spam_log_by_user_cls_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_spam_log_by_user_cls_idx ON public.ec_spam_log USING btree (user_class_id);


--
-- Name: ec_subcat_product_map_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_subcat_product_map_idx ON public.ec_subcategory_product_map USING btree (subcategory_id);


--
-- Name: ec_subcat_product_map_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_subcat_product_map_idx2 ON public.ec_subcategory_product_map USING btree (publisher_favorite_p);


--
-- Name: ec_subcategories_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_subcategories_idx ON public.ec_subcategories USING btree (category_id);


--
-- Name: ec_subcategories_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_subcategories_idx2 ON public.ec_subcategories USING btree (sort_key);


--
-- Name: ec_subsubcat_prod_map_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_subsubcat_prod_map_idx ON public.ec_subsubcategory_product_map USING btree (subsubcategory_id);


--
-- Name: ec_subsubcat_prod_map_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_subsubcat_prod_map_idx2 ON public.ec_subsubcategory_product_map USING btree (publisher_favorite_p);


--
-- Name: ec_subsubcategories_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_subsubcategories_idx ON public.ec_subsubcategories USING btree (subcategory_id);


--
-- Name: ec_subsubcategories_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_subsubcategories_idx2 ON public.ec_subsubcategories USING btree (sort_key);


--
-- Name: ec_u_s_offer_codes_by_p_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_u_s_offer_codes_by_p_id ON public.ec_user_session_offer_codes USING btree (product_id);


--
-- Name: ec_u_s_offer_codes_by_u_s_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_u_s_offer_codes_by_u_s_id ON public.ec_user_session_offer_codes USING btree (user_session_id);


--
-- Name: ec_user_class_user_map_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_class_user_map_idx ON public.ec_user_class_user_map USING btree (user_class_id);


--
-- Name: ec_user_class_user_map_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_class_user_map_idx2 ON public.ec_user_class_user_map USING btree (user_class_approved_p);


--
-- Name: ec_user_ident_by_email; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_ident_by_email ON public.ec_user_identification USING btree (email);


--
-- Name: ec_user_ident_by_first_names; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_ident_by_first_names ON public.ec_user_identification USING btree (first_names);


--
-- Name: ec_user_ident_by_last_name; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_ident_by_last_name ON public.ec_user_identification USING btree (last_name);


--
-- Name: ec_user_ident_by_postal_code; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_ident_by_postal_code ON public.ec_user_identification USING btree (postal_code);


--
-- Name: ec_user_ident_by_user_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_ident_by_user_id ON public.ec_user_identification USING btree (user_id);


--
-- Name: ec_user_session_info_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_session_info_idx ON public.ec_user_session_info USING btree (user_session_id);


--
-- Name: ec_user_session_info_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_session_info_idx2 ON public.ec_user_session_info USING btree (product_id);


--
-- Name: ec_user_session_info_idx3; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_session_info_idx3 ON public.ec_user_session_info USING btree (category_id);


--
-- Name: ec_user_sessions_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ec_user_sessions_idx ON public.ec_user_sessions USING btree (user_id);


--
-- Name: ecds_alt_spelling_map_alt_spelling_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_alt_spelling_map_alt_spelling_idx ON public.ecds_alt_spelling_map USING btree (alt_spelling);


--
-- Name: ecds_alt_spelling_map_context_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_alt_spelling_map_context_idx ON public.ecds_alt_spelling_map USING btree (context);


--
-- Name: ecds_alt_spelling_map_normalized_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_alt_spelling_map_normalized_idx ON public.ecds_alt_spelling_map USING btree (normalized);


--
-- Name: ecds_categories_cat_key_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_categories_cat_key_idx ON public.ecds_categories USING btree (cat_key);


--
-- Name: ecds_categories_map_ec_cat_key_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_categories_map_ec_cat_key_idx ON public.ecds_categories_map USING btree (cat_key);


--
-- Name: ecds_categories_map_ec_category_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_categories_map_ec_category_id_idx ON public.ecds_categories_map USING btree (category_id);


--
-- Name: ecds_categories_map_ec_subcategory_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_categories_map_ec_subcategory_id_idx ON public.ecds_categories_map USING btree (subcategory_id);


--
-- Name: ecds_categories_map_ec_subsubcategory_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_categories_map_ec_subsubcategory_id_idx ON public.ecds_categories_map USING btree (subsubcategory_id);


--
-- Name: ecds_object_templates_map_object_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_object_templates_map_object_id_idx ON public.ecds_object_templates_map USING btree (object_id);


--
-- Name: ecds_object_templates_map_template_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_object_templates_map_template_id_idx ON public.ecds_object_templates_map USING btree (template_id);


--
-- Name: ecds_process_control_proc_ref_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_process_control_proc_ref_idx ON public.ecds_process_control USING btree (process_ref);


--
-- Name: ecds_product_id_site_url_map_product_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_product_id_site_url_map_product_idx ON public.ecds_product_id_site_url_map USING btree (product_id);


--
-- Name: ecds_product_id_site_url_map_site_url_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_product_id_site_url_map_site_url_idx ON public.ecds_product_id_site_url_map USING btree (site_url);


--
-- Name: ecds_templates_template_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_templates_template_id_idx ON public.ecds_templates USING btree (template_id);


--
-- Name: ecds_url_cache_map_url_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_url_cache_map_url_idx ON public.ecds_url_cache_map USING btree (url);


--
-- Name: ecds_vendors_abbrev_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ecds_vendors_abbrev_idx ON public.ecds_vendors USING btree (abbrev);


--
-- Name: ezic_gateway_result_log_transaction_id; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX ezic_gateway_result_log_transaction_id ON public.ezic_gateway_result_log USING btree (transaction_id);


--
-- Name: fti_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX fti_idx ON public.txt USING gist (fti);


--
-- Name: general_comments_object_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX general_comments_object_id_idx ON public.general_comments USING btree (object_id);


--
-- Name: group_elem_idx_element_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX group_elem_idx_element_idx ON public.group_element_index USING btree (element_id);


--
-- Name: group_elem_idx_group_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX group_elem_idx_group_idx ON public.group_element_index USING btree (group_id);


--
-- Name: group_elem_idx_rel_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX group_elem_idx_rel_id_idx ON public.group_element_index USING btree (rel_id);


--
-- Name: group_elem_idx_rel_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX group_elem_idx_rel_type_idx ON public.group_element_index USING btree (rel_type);


--
-- Name: group_rels_rel_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX group_rels_rel_type_idx ON public.group_rels USING btree (rel_type);


--
-- Name: group_type_rels_rel_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX group_type_rels_rel_type_idx ON public.group_type_rels USING btree (rel_type);


--
-- Name: im_biz_object_groups_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_biz_object_groups_un ON public.im_biz_object_groups USING btree ((COALESCE(biz_object_id, 0)));


--
-- Name: im_biz_object_role_map_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_biz_object_role_map_un ON public.im_biz_object_role_map USING btree ((COALESCE(acs_object_type, ''::character varying)), (COALESCE(object_type_id, 0)), (COALESCE(object_role_id, 0)));


--
-- Name: im_cat_hierarchy_child_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX im_cat_hierarchy_child_id_idx ON public.im_category_hierarchy USING btree (child_id);


--
-- Name: im_cat_hierarchy_parent_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX im_cat_hierarchy_parent_id_idx ON public.im_category_hierarchy USING btree (parent_id);


--
-- Name: im_categories_cat_cat_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_categories_cat_cat_type_idx ON public.im_categories USING btree (category, category_type);


--
-- Name: im_dynfield_layout_pages_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_dynfield_layout_pages_un ON public.im_dynfield_pages USING btree (object_type, (COALESCE(page_url, ''::character varying)), (COALESCE(workflow_key, ''::character varying)), (COALESCE(transition_key, ''::character varying)));


--
-- Name: im_proj_url_url_proj_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX im_proj_url_url_proj_idx ON public.im_project_url_map USING btree (url_type_id, project_id);


--
-- Name: im_project_parent_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX im_project_parent_id_idx ON public.im_projects USING btree (parent_id);


--
-- Name: im_project_treesort_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX im_project_treesort_idx ON public.im_projects USING btree (tree_sortkey);


--
-- Name: im_projects_name_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_projects_name_un ON public.im_projects USING btree (project_name, company_id, (COALESCE(parent_id, 0)));


--
-- Name: im_projects_nr_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_projects_nr_un ON public.im_projects USING btree (project_nr, company_id, (COALESCE(parent_id, 0)));


--
-- Name: im_projects_path_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_projects_path_un ON public.im_projects USING btree (project_path, company_id, (COALESCE(parent_id, 0)));


--
-- Name: im_view_columns_columns_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_view_columns_columns_un ON public.im_view_columns USING btree (view_id, column_id);


--
-- Name: im_view_columns_name_un; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX im_view_columns_name_un ON public.im_view_columns USING btree (view_id, column_name);


--
-- Name: journal_entries_object_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX journal_entries_object_idx ON public.journal_entries USING btree (object_id);


--
-- Name: lob_data_index; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX lob_data_index ON public.lob_data USING btree (lob_id);


--
-- Name: notif_repl_from_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX notif_repl_from_user_idx ON public.notification_replies USING btree (from_user);


--
-- Name: notif_repl_object_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX notif_repl_object_id_idx ON public.notification_replies USING btree (object_id);


--
-- Name: notif_repl_type_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX notif_repl_type_id_idx ON public.notification_replies USING btree (type_id);


--
-- Name: notification_requests_t_o_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX notification_requests_t_o_idx ON public.notification_requests USING btree (type_id, object_id);


--
-- Name: notification_user_map_user_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX notification_user_map_user_idx ON public.notification_user_map USING btree (user_id);


--
-- Name: notifications_object_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX notifications_object_id_idx ON public.notifications USING btree (object_id);


--
-- Name: notifications_response_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX notifications_response_id_idx ON public.notifications USING btree (response_id);


--
-- Name: notifications_type_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX notifications_type_id_idx ON public.notifications USING btree (type_id);


--
-- Name: object_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX object_id_idx ON public.txt USING btree (object_id);


--
-- Name: organization_cliend_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX organization_cliend_idx ON public.organizations USING btree (client_id);


--
-- Name: organization_name_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX organization_name_ix ON public.organizations USING btree (name);


--
-- Name: parties_email_lower_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX parties_email_lower_idx ON public.parties USING btree (lower((email)::text));


--
-- Name: party_member_member_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX party_member_member_idx ON public.party_approved_member_map USING btree (member_id);


--
-- Name: party_member_originating_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX party_member_originating_idx ON public.party_approved_member_map USING btree (originating_rel_id);


--
-- Name: party_member_party_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX party_member_party_idx ON public.party_approved_member_map USING btree (party_id);


--
-- Name: pinds_blog_entry_pck_entr_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX pinds_blog_entry_pck_entr_idx ON public.pinds_blog_entries USING btree (package_id, entry_date);


--
-- Name: postal_addresses_country_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX postal_addresses_country_ix ON public.postal_addresses USING btree (country_code);


--
-- Name: postal_addresses_party_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX postal_addresses_party_ix ON public.postal_addresses USING btree (party_id);


--
-- Name: priv_hier_sortkey_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX priv_hier_sortkey_idx ON public.acs_privilege_hierarchy_index USING btree (tree_sortkey);


--
-- Name: rc_segment_required_seg_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX rc_segment_required_seg_idx ON public.rc_segment_required_seg_map USING btree (required_rel_segment);


--
-- Name: recurrences_interval_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX recurrences_interval_type_idx ON public.recurrences USING btree (interval_type);


--
-- Name: rel_constraint_req_rel_seg_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX rel_constraint_req_rel_seg_idx ON public.rel_constraints USING btree (required_rel_segment);


--
-- Name: rel_segments_rel_type_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX rel_segments_rel_type_idx ON public.rel_segments USING btree (rel_type);


--
-- Name: sec_property_names; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX sec_property_names ON public.sec_session_properties USING btree (property_name);


--
-- Name: site_node_object_mappings_node_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX site_node_object_mappings_node_id_idx ON public.site_node_object_mappings USING btree (node_id);


--
-- Name: site_nodes_object_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX site_nodes_object_id_idx ON public.site_nodes USING btree (object_id);


--
-- Name: site_nodes_parent_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX site_nodes_parent_id_idx ON public.site_nodes USING btree (parent_id);


--
-- Name: site_nodes_parent_object_node_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX site_nodes_parent_object_node_id_idx ON public.site_nodes USING btree (parent_id, object_id, node_id);


--
-- Name: site_nodes_tree_skey_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX site_nodes_tree_skey_idx ON public.site_nodes USING btree (tree_sortkey);


--
-- Name: tags_tags_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX tags_tags_package_id_idx ON public.tags_tags USING btree (package_id);


--
-- Name: tags_tags_tag_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX tags_tags_tag_package_id_idx ON public.tags_tags USING btree (tag, package_id);


--
-- Name: tags_tags_user_id_item_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX tags_tags_user_id_item_id_idx ON public.tags_tags USING btree (user_id, item_id);


--
-- Name: tags_tags_user_id_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX tags_tags_user_id_package_id_idx ON public.tags_tags USING btree (user_id, package_id);


--
-- Name: tbp_comment_id_fk_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX tbp_comment_id_fk_idx ON public.trackback_pings USING btree (comment_id);


--
-- Name: telecom_numbers_itu_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX telecom_numbers_itu_ix ON public.telecom_numbers USING btree (itu_id);


--
-- Name: telecom_numbers_party_ix; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX telecom_numbers_party_ix ON public.telecom_numbers USING btree (party_id);


--
-- Name: time_intervals_start_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX time_intervals_start_idx ON public.time_intervals USING btree (start_date);


--
-- Name: timespans_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX timespans_idx ON public.timespans USING btree (timespan_id);


--
-- Name: timespans_interval_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX timespans_interval_id_idx ON public.timespans USING btree (interval_id);


--
-- Name: timezone_rules_idx1; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX timezone_rules_idx1 ON public.timezone_rules USING btree (tz_id, utc_start, utc_end);


--
-- Name: timezone_rules_idx2; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX timezone_rules_idx2 ON public.timezone_rules USING btree (tz_id, local_start, local_end);


--
-- Name: users_screenname_lower_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX users_screenname_lower_idx ON public.users USING btree (lower((screen_name)::text));


--
-- Name: users_username_lower_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX users_username_lower_idx ON public.users USING btree (lower((username)::text));


--
-- Name: xowiki_autonames_parent_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_autonames_parent_id_idx ON public.xowiki_autonames USING btree (parent_id);


--
-- Name: xowiki_autonames_parent_id_name_un_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX xowiki_autonames_parent_id_name_un_idx ON public.xowiki_autonames USING btree (parent_id, name);


--
-- Name: xowiki_form_instance_item_index_item_id_un_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX xowiki_form_instance_item_index_item_id_un_idx ON public.xowiki_form_instance_item_index USING btree (item_id);


--
-- Name: xowiki_form_instance_item_index_page_template_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_form_instance_item_index_page_template_idx ON public.xowiki_form_instance_item_index USING btree (page_template);


--
-- Name: xowiki_form_instance_item_index_page_template_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_form_instance_item_index_page_template_package_id_idx ON public.xowiki_form_instance_item_index USING btree (page_template, package_id);


--
-- Name: xowiki_form_instance_item_index_parent_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_form_instance_item_index_parent_id_idx ON public.xowiki_form_instance_item_index USING btree (parent_id);


--
-- Name: xowiki_form_instance_item_index_parent_id_name_un_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX xowiki_form_instance_item_index_parent_id_name_un_idx ON public.xowiki_form_instance_item_index USING btree (parent_id, name);


--
-- Name: xowiki_form_instance_item_index_parent_id_page_template_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_form_instance_item_index_parent_id_page_template_idx ON public.xowiki_form_instance_item_index USING btree (parent_id, page_template);


--
-- Name: xowiki_form_page_assignee_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_form_page_assignee_idx ON public.xowiki_form_page USING btree (assignee);


--
-- Name: xowiki_last_visited_page_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_last_visited_page_id_idx ON public.xowiki_last_visited USING btree (page_id);


--
-- Name: xowiki_last_visited_time_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_last_visited_time_idx ON public.xowiki_last_visited USING btree ("time");


--
-- Name: xowiki_last_visited_user_id_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_last_visited_user_id_package_id_idx ON public.xowiki_last_visited USING btree (user_id, package_id);


--
-- Name: xowiki_last_visited_user_id_page_id_un_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE UNIQUE INDEX xowiki_last_visited_user_id_page_id_un_idx ON public.xowiki_last_visited USING btree (user_id, page_id);


--
-- Name: xowiki_page_instance_page_template_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_page_instance_page_template_idx ON public.xowiki_page_instance USING btree (page_template);


--
-- Name: xowiki_page_page_order_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_page_page_order_idx ON public.xowiki_page USING btree (page_order);


--
-- Name: xowiki_references_page_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_references_page_idx ON public.xowiki_references USING btree (page);


--
-- Name: xowiki_references_reference_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_references_reference_idx ON public.xowiki_references USING btree (reference);


--
-- Name: xowiki_tags_item_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_tags_item_id_idx ON public.xowiki_tags USING btree (item_id);


--
-- Name: xowiki_tags_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_tags_package_id_idx ON public.xowiki_tags USING btree (package_id);


--
-- Name: xowiki_tags_tag_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_tags_tag_package_id_idx ON public.xowiki_tags USING btree (tag, package_id);


--
-- Name: xowiki_tags_user_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_tags_user_id_idx ON public.xowiki_tags USING btree (user_id);


--
-- Name: xowiki_tags_user_id_item_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_tags_user_id_item_id_idx ON public.xowiki_tags USING btree (user_id, item_id);


--
-- Name: xowiki_tags_user_id_package_id_idx; Type: INDEX; Schema: public; Owner: evex
--

CREATE INDEX xowiki_tags_user_id_package_id_idx ON public.xowiki_tags USING btree (user_id, package_id);


--
-- Name: cr_revisionsi cr_revisions_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE cr_revisions_r AS
    ON INSERT TO public.cr_revisionsi DO INSTEAD  SELECT public.cr_revisions_f(new.*) AS cr_revisions_f;


--
-- Name: ee_bookingsi ee_bookings_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE ee_bookings_r AS
    ON INSERT TO public.ee_bookingsi DO INSTEAD  SELECT public.ee_bookings_f(new.*) AS ee_bookings_f;


--
-- Name: ee_itemsi ee_items_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE ee_items_r AS
    ON INSERT TO public.ee_itemsi DO INSTEAD  SELECT public.ee_items_f(new.*) AS ee_items_f;


--
-- Name: ee_proposalsi ee_proposals_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE ee_proposals_r AS
    ON INSERT TO public.ee_proposalsi DO INSTEAD  SELECT public.ee_proposals_f(new.*) AS ee_proposals_f;


--
-- Name: ee_servicesi ee_services_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE ee_services_r AS
    ON INSERT TO public.ee_servicesi DO INSTEAD  SELECT public.ee_services_f(new.*) AS ee_services_f;


--
-- Name: ee_venuesi ee_venues_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE ee_venues_r AS
    ON INSERT TO public.ee_venuesi DO INSTEAD  SELECT public.ee_venues_f(new.*) AS ee_venues_f;


--
-- Name: file_storage_object_ti file_storage_object_t_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE file_storage_object_t_r AS
    ON INSERT TO public.file_storage_object_ti DO INSTEAD  SELECT public.file_storage_object_t_f(new.*) AS file_storage_object_t_f;


--
-- Name: imagesi images_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE images_r AS
    ON INSERT TO public.imagesi DO INSTEAD  SELECT public.images_f(new.*) AS images_f;


--
-- Name: iurix_mailsi iurix_mails_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE iurix_mails_r AS
    ON INSERT TO public.iurix_mailsi DO INSTEAD  SELECT public.iurix_mails_f(new.*) AS iurix_mails_f;


--
-- Name: pa_albumsi pa_albums_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE pa_albums_r AS
    ON INSERT TO public.pa_albumsi DO INSTEAD  SELECT public.pa_albums_f(new.*) AS pa_albums_f;


--
-- Name: pa_photosi pa_photos_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE pa_photos_r AS
    ON INSERT TO public.pa_photosi DO INSTEAD  SELECT public.pa_photos_f(new.*) AS pa_photos_f;


--
-- Name: users_email_imagei users_email_image_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE users_email_image_r AS
    ON INSERT TO public.users_email_imagei DO INSTEAD  SELECT public.users_email_image_f(new.*) AS users_email_image_f;


--
-- Name: xowiki_filei xowiki_file_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_file_r AS
    ON INSERT TO public.xowiki_filei DO INSTEAD  SELECT public.xowiki_file_f(new.*) AS xowiki_file_f;


--
-- Name: xowiki_form_pagei xowiki_form_page_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_form_page_r AS
    ON INSERT TO public.xowiki_form_pagei DO INSTEAD  SELECT public.xowiki_form_page_f(new.*) AS xowiki_form_page_f;


--
-- Name: xowiki_formi xowiki_form_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_form_r AS
    ON INSERT TO public.xowiki_formi DO INSTEAD  SELECT public.xowiki_form_f(new.*) AS xowiki_form_f;


--
-- Name: xowiki_objecti xowiki_object_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_object_r AS
    ON INSERT TO public.xowiki_objecti DO INSTEAD  SELECT public.xowiki_object_f(new.*) AS xowiki_object_f;


--
-- Name: xowiki_page_instancei xowiki_page_instance_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_page_instance_r AS
    ON INSERT TO public.xowiki_page_instancei DO INSTEAD  SELECT public.xowiki_page_instance_f(new.*) AS xowiki_page_instance_f;


--
-- Name: xowiki_pagei xowiki_page_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_page_r AS
    ON INSERT TO public.xowiki_pagei DO INSTEAD  SELECT public.xowiki_page_f(new.*) AS xowiki_page_f;


--
-- Name: xowiki_page_templatei xowiki_page_template_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_page_template_r AS
    ON INSERT TO public.xowiki_page_templatei DO INSTEAD  SELECT public.xowiki_page_template_f(new.*) AS xowiki_page_template_f;


--
-- Name: xowiki_plain_pagei xowiki_plain_page_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_plain_page_r AS
    ON INSERT TO public.xowiki_plain_pagei DO INSTEAD  SELECT public.xowiki_plain_page_f(new.*) AS xowiki_plain_page_f;


--
-- Name: xowiki_podcast_itemi xowiki_podcast_item_r; Type: RULE; Schema: public; Owner: evex
--

CREATE RULE xowiki_podcast_item_r AS
    ON INSERT TO public.xowiki_podcast_itemi DO INSTEAD  SELECT public.xowiki_podcast_item_f(new.*) AS xowiki_podcast_item_f;


--
-- Name: acs_messages acs_message_insert_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_message_insert_tr BEFORE INSERT ON public.acs_messages FOR EACH ROW EXECUTE PROCEDURE public.acs_message_insert_tr();


--
-- Name: acs_messages acs_message_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_message_update_tr AFTER UPDATE ON public.acs_messages FOR EACH ROW EXECUTE PROCEDURE public.acs_message_update_tr();


--
-- Name: acs_object_types acs_object_type_insert_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_object_type_insert_tr BEFORE INSERT ON public.acs_object_types FOR EACH ROW EXECUTE PROCEDURE public.acs_object_type_insert_tr();


--
-- Name: acs_object_types acs_object_type_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_object_type_update_tr AFTER UPDATE ON public.acs_object_types FOR EACH ROW EXECUTE PROCEDURE public.acs_object_type_update_tr();


--
-- Name: acs_objects acs_objects_context_id_in_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_objects_context_id_in_tr AFTER INSERT ON public.acs_objects FOR EACH ROW EXECUTE PROCEDURE public.acs_objects_context_id_in_tr();


--
-- Name: acs_objects acs_objects_context_id_up_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_objects_context_id_up_tr AFTER UPDATE ON public.acs_objects FOR EACH ROW EXECUTE PROCEDURE public.acs_objects_context_id_up_tr();


--
-- Name: acs_objects acs_objects_last_mod_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_objects_last_mod_update_tr BEFORE UPDATE ON public.acs_objects FOR EACH ROW EXECUTE PROCEDURE public.acs_objects_last_mod_update_tr();


--
-- Name: acs_objects acs_objects_mod_ip_insert_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_objects_mod_ip_insert_tr BEFORE INSERT ON public.acs_objects FOR EACH ROW EXECUTE PROCEDURE public.acs_objects_mod_ip_insert_tr();


--
-- Name: acs_permissions_lock acs_permissions_lock_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_permissions_lock_tr BEFORE INSERT OR DELETE OR UPDATE ON public.acs_permissions_lock FOR EACH ROW EXECUTE PROCEDURE public.acs_permissions_lock_tr();


--
-- Name: acs_privileges acs_priv_del_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_priv_del_tr BEFORE DELETE ON public.acs_privileges FOR EACH ROW EXECUTE PROCEDURE public.acs_priv_del_tr();


--
-- Name: acs_privilege_hierarchy acs_priv_hier_ins_del_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_priv_hier_ins_del_tr AFTER INSERT OR DELETE ON public.acs_privilege_hierarchy FOR EACH ROW EXECUTE PROCEDURE public.acs_priv_hier_ins_del_tr();


--
-- Name: acs_rels acs_rels_in_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER acs_rels_in_tr BEFORE INSERT OR UPDATE ON public.acs_rels FOR EACH ROW EXECUTE PROCEDURE public.acs_rels_in_tr();


--
-- Name: category_translations category_synonym__insert_cat_trans_trg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER category_synonym__insert_cat_trans_trg AFTER INSERT ON public.category_translations FOR EACH ROW EXECUTE PROCEDURE public.category_synonym__new_cat_trans_trg();


--
-- Name: category_translations category_synonym__update_cat_trans_trg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER category_synonym__update_cat_trans_trg BEFORE UPDATE ON public.category_translations FOR EACH ROW EXECUTE PROCEDURE public.category_synonym__edit_cat_trans_trg();


--
-- Name: composition_rels composition_rels_del_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER composition_rels_del_tr BEFORE DELETE ON public.composition_rels FOR EACH ROW EXECUTE PROCEDURE public.composition_rels_del_tr();


--
-- Name: composition_rels composition_rels_in_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER composition_rels_in_tr AFTER INSERT ON public.composition_rels FOR EACH ROW EXECUTE PROCEDURE public.composition_rels_in_tr();


--
-- Name: cr_items content_item_search__utrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER content_item_search__utrg BEFORE UPDATE ON public.cr_items FOR EACH ROW EXECUTE PROCEDURE public.content_item_search__utrg();


--
-- Name: cr_revisions content_search__itrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER content_search__itrg AFTER INSERT ON public.cr_revisions FOR EACH ROW EXECUTE PROCEDURE public.content_search__itrg();


--
-- Name: cr_revisions content_search__utrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER content_search__utrg AFTER UPDATE ON public.cr_revisions FOR EACH ROW EXECUTE PROCEDURE public.content_search__utrg();


--
-- Name: cr_revisions cr_cleanup_cr_files_del_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_cleanup_cr_files_del_tr BEFORE DELETE ON public.cr_revisions FOR EACH ROW EXECUTE PROCEDURE public.cr_cleanup_cr_files_del_tr();


--
-- Name: cr_items cr_items_publish_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_items_publish_update_tr BEFORE UPDATE ON public.cr_items FOR EACH ROW EXECUTE PROCEDURE public.cr_items_publish_update_tr();


--
-- Name: cr_items cr_items_tree_insert_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_items_tree_insert_tr BEFORE INSERT ON public.cr_items FOR EACH ROW EXECUTE PROCEDURE public.cr_items_tree_insert_tr();


--
-- Name: cr_items cr_items_tree_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_items_tree_update_tr AFTER UPDATE ON public.cr_items FOR EACH ROW EXECUTE PROCEDURE public.cr_items_tree_update_tr();


--
-- Name: cr_items cr_items_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_items_update_tr AFTER UPDATE ON public.cr_items FOR EACH ROW EXECUTE PROCEDURE public.cr_items_update_tr();


--
-- Name: cr_keywords cr_keywords_tree_insert_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_keywords_tree_insert_tr BEFORE INSERT ON public.cr_keywords FOR EACH ROW EXECUTE PROCEDURE public.cr_keywords_tree_insert_tr();


--
-- Name: cr_keywords cr_keywords_tree_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_keywords_tree_update_tr AFTER UPDATE ON public.cr_keywords FOR EACH ROW EXECUTE PROCEDURE public.cr_keywords_tree_update_tr();


--
-- Name: cr_keywords cr_keywords_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_keywords_update_tr AFTER UPDATE ON public.cr_keywords FOR EACH ROW EXECUTE PROCEDURE public.cr_keywords_update_tr();


--
-- Name: cr_revisions cr_revision_latest_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_revision_latest_tr AFTER INSERT ON public.cr_revisions FOR EACH ROW EXECUTE PROCEDURE public.cr_revision_latest_tr();


--
-- Name: cr_revisions cr_revisions_lob_trig; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_revisions_lob_trig BEFORE INSERT OR DELETE OR UPDATE ON public.cr_revisions FOR EACH ROW EXECUTE PROCEDURE public.on_lob_ref();


--
-- Name: cr_scheduled_release_job cr_scheduled_release_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_scheduled_release_tr BEFORE INSERT ON public.cr_scheduled_release_job FOR EACH ROW EXECUTE PROCEDURE public.cr_scheduled_release_tr();


--
-- Name: cr_text cr_text_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_text_tr BEFORE INSERT ON public.cr_text FOR EACH ROW EXECUTE PROCEDURE public.cr_text_tr();


--
-- Name: cr_type_template_map cr_type_template_map_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER cr_type_template_map_tr BEFORE INSERT ON public.cr_type_template_map FOR EACH ROW EXECUTE PROCEDURE public.cr_type_template_map_tr();


--
-- Name: ec_admin_settings ec_admin_settings_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_admin_settings_audit_tr AFTER DELETE OR UPDATE ON public.ec_admin_settings FOR EACH ROW EXECUTE PROCEDURE public.ec_admin_settings_audit_tr();


--
-- Name: ec_category_product_map ec_cat_prod_map_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_cat_prod_map_audit_tr AFTER DELETE OR UPDATE ON public.ec_category_product_map FOR EACH ROW EXECUTE PROCEDURE public.ec_cat_prod_map_audit_tr();


--
-- Name: ec_categories ec_categories_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_categories_audit_tr AFTER DELETE OR UPDATE ON public.ec_categories FOR EACH ROW EXECUTE PROCEDURE public.ec_categories_audit_tr();


--
-- Name: ec_gift_certificate_usage ec_cert_amount_remains; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_cert_amount_remains AFTER UPDATE ON public.ec_gift_certificate_usage FOR EACH ROW EXECUTE PROCEDURE public.trig_ec_cert_amount_remains();


--
-- Name: ec_customer_serv_interactions ec_cs_interaction_inserts; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_cs_interaction_inserts AFTER INSERT ON public.ec_customer_serv_interactions FOR EACH ROW EXECUTE PROCEDURE public.ec_cs_interaction_inserts();


--
-- Name: ec_customer_service_issues ec_cs_issue_inserts; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_cs_issue_inserts AFTER INSERT ON public.ec_customer_service_issues FOR EACH ROW EXECUTE PROCEDURE public.ec_cs_issue_inserts();


--
-- Name: ec_custom_product_field_values ec_custom_p_f_values_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_custom_p_f_values_audit_tr AFTER DELETE OR UPDATE ON public.ec_custom_product_field_values FOR EACH ROW EXECUTE PROCEDURE public.ec_custom_p_f_values_audit_tr();


--
-- Name: ec_custom_product_fields ec_custom_prod_fields_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_custom_prod_fields_audit_tr AFTER DELETE OR UPDATE ON public.ec_custom_product_fields FOR EACH ROW EXECUTE PROCEDURE public.ec_custom_prod_fields_audit_tr();


--
-- Name: ec_email_templates ec_email_templates_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_email_templates_audit_tr AFTER DELETE OR UPDATE ON public.ec_email_templates FOR EACH ROW EXECUTE PROCEDURE public.ec_email_templates_audit_tr();


--
-- Name: ec_gift_certificates ec_gift_certificates_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_gift_certificates_audit_tr AFTER DELETE OR UPDATE ON public.ec_gift_certificates FOR EACH ROW EXECUTE PROCEDURE public.ec_gift_certificates_audit_tr();


--
-- Name: ec_offers ec_offers_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_offers_audit_tr AFTER DELETE OR UPDATE ON public.ec_offers FOR EACH ROW EXECUTE PROCEDURE public.ec_offers_audit_tr();


--
-- Name: ec_items ec_order_state_after_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_order_state_after_tr AFTER UPDATE ON public.ec_items FOR EACH ROW EXECUTE PROCEDURE public.ec_order_state_after_tr();


--
-- Name: ec_picklist_items ec_picklist_items_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_picklist_items_audit_tr AFTER DELETE OR UPDATE ON public.ec_picklist_items FOR EACH ROW EXECUTE PROCEDURE public.ec_picklist_items_audit_tr();


--
-- Name: ec_product_comments ec_product_comments_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_product_comments_audit_tr AFTER DELETE OR UPDATE ON public.ec_product_comments FOR EACH ROW EXECUTE PROCEDURE public.ec_product_comments_audit_tr();


--
-- Name: ec_product_links ec_product_links_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_product_links_audit_tr AFTER DELETE OR UPDATE ON public.ec_product_links FOR EACH ROW EXECUTE PROCEDURE public.ec_product_links_audit_tr();


--
-- Name: ec_product_recommendations ec_product_recommend_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_product_recommend_audit_tr AFTER DELETE OR UPDATE ON public.ec_product_recommendations FOR EACH ROW EXECUTE PROCEDURE public.ec_product_recommend_audit_tr();


--
-- Name: ec_product_reviews ec_product_reviews_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_product_reviews_audit_tr AFTER DELETE OR UPDATE ON public.ec_product_reviews FOR EACH ROW EXECUTE PROCEDURE public.ec_product_reviews_audit_tr();


--
-- Name: ec_product_series_map ec_product_series_map_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_product_series_map_audit_tr AFTER DELETE OR UPDATE ON public.ec_product_series_map FOR EACH ROW EXECUTE PROCEDURE public.ec_product_series_map_audit_tr();


--
-- Name: ec_product_user_class_prices ec_product_u_c_prices_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_product_u_c_prices_audit_tr AFTER DELETE OR UPDATE ON public.ec_product_user_class_prices FOR EACH ROW EXECUTE PROCEDURE public.ec_product_u_c_prices_audit_tr();


--
-- Name: ec_products ec_products__dtrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_products__dtrg AFTER DELETE ON public.ec_products FOR EACH ROW EXECUTE PROCEDURE public.ec_products__dtrg();


--
-- Name: ec_products ec_products__itrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_products__itrg AFTER INSERT ON public.ec_products FOR EACH ROW EXECUTE PROCEDURE public.ec_products__itrg();


--
-- Name: ec_products ec_products__utrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_products__utrg AFTER UPDATE ON public.ec_products FOR EACH ROW EXECUTE PROCEDURE public.ec_products__utrg();


--
-- Name: ec_products ec_products_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_products_audit_tr AFTER DELETE OR UPDATE ON public.ec_products FOR EACH ROW EXECUTE PROCEDURE public.ec_products_audit_tr();


--
-- Name: ec_retailer_locations ec_retailer_locations_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_retailer_locations_audit_tr AFTER DELETE OR UPDATE ON public.ec_retailer_locations FOR EACH ROW EXECUTE PROCEDURE public.ec_retailer_locations_audit_tr();


--
-- Name: ec_retailers ec_retailers_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_retailers_audit_tr AFTER DELETE OR UPDATE ON public.ec_retailers FOR EACH ROW EXECUTE PROCEDURE public.ec_retailers_audit_tr();


--
-- Name: ec_sale_prices ec_sale_prices_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_sale_prices_audit_tr AFTER DELETE OR UPDATE ON public.ec_sale_prices FOR EACH ROW EXECUTE PROCEDURE public.ec_sale_prices_audit_tr();


--
-- Name: ec_sales_tax_by_state ec_sales_tax_by_state_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_sales_tax_by_state_audit_tr AFTER DELETE OR UPDATE ON public.ec_sales_tax_by_state FOR EACH ROW EXECUTE PROCEDURE public.ec_sales_tax_by_state_audit_tr();


--
-- Name: ec_shipments ec_shipment_address_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_shipment_address_update_tr BEFORE INSERT ON public.ec_shipments FOR EACH ROW EXECUTE PROCEDURE public.ec_shipment_address_update_tr();


--
-- Name: ec_shipments ec_shipments_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_shipments_audit_tr AFTER DELETE OR UPDATE ON public.ec_shipments FOR EACH ROW EXECUTE PROCEDURE public.ec_shipments_audit_tr();


--
-- Name: ec_subcategory_product_map ec_subcat_prod_map_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_subcat_prod_map_audit_tr AFTER DELETE OR UPDATE ON public.ec_subcategory_product_map FOR EACH ROW EXECUTE PROCEDURE public.ec_subcat_prod_map_audit_tr();


--
-- Name: ec_subcategories ec_subcategories_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_subcategories_audit_tr AFTER DELETE OR UPDATE ON public.ec_subcategories FOR EACH ROW EXECUTE PROCEDURE public.ec_subcategories_audit_tr();


--
-- Name: ec_subsubcategory_product_map ec_subsubcat_prod_map_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_subsubcat_prod_map_audit_tr AFTER DELETE OR UPDATE ON public.ec_subsubcategory_product_map FOR EACH ROW EXECUTE PROCEDURE public.ec_subsubcat_prod_map_audit_tr();


--
-- Name: ec_subsubcategories ec_subsubcategories_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_subsubcategories_audit_tr AFTER DELETE OR UPDATE ON public.ec_subsubcategories FOR EACH ROW EXECUTE PROCEDURE public.ec_subsubcategories_audit_tr();


--
-- Name: ec_templates ec_templates_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_templates_audit_tr AFTER DELETE OR UPDATE ON public.ec_templates FOR EACH ROW EXECUTE PROCEDURE public.ec_templates_audit_tr();


--
-- Name: ec_user_class_user_map ec_user_class_user_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_user_class_user_audit_tr AFTER DELETE OR UPDATE ON public.ec_user_class_user_map FOR EACH ROW EXECUTE PROCEDURE public.ec_user_class_user_audit_tr();


--
-- Name: ec_user_classes ec_user_classes_audit_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_user_classes_audit_tr AFTER DELETE OR UPDATE ON public.ec_user_classes FOR EACH ROW EXECUTE PROCEDURE public.ec_user_classes_audit_tr();


--
-- Name: ec_user_identification ec_user_identificate_date_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER ec_user_identificate_date_tr AFTER INSERT ON public.ec_user_identification FOR EACH ROW EXECUTE PROCEDURE public.ec_user_identificate_date_tr();


--
-- Name: faq_q_and_as faq_sc__dtrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER faq_sc__dtrg AFTER DELETE ON public.faq_q_and_as FOR EACH ROW EXECUTE PROCEDURE public.faq_sc__dtrg();


--
-- Name: faq_q_and_as faq_sc__itrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER faq_sc__itrg AFTER INSERT ON public.faq_q_and_as FOR EACH ROW EXECUTE PROCEDURE public.faq_sc__itrg();


--
-- Name: faq_q_and_as faq_sc__utrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER faq_sc__utrg AFTER UPDATE ON public.faq_q_and_as FOR EACH ROW EXECUTE PROCEDURE public.faq_sc__utrg();


--
-- Name: ec_financial_transactions fin_trans_ccard_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER fin_trans_ccard_update_tr BEFORE INSERT ON public.ec_financial_transactions FOR EACH ROW EXECUTE PROCEDURE public.fin_trans_ccard_update_tr();


--
-- Name: fs_root_folders fs_package_items_delete_trig; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER fs_package_items_delete_trig BEFORE DELETE ON public.fs_root_folders FOR EACH ROW EXECUTE PROCEDURE public.fs_package_items_delete_trig();


--
-- Name: fs_root_folders fs_root_folder_delete_trig; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER fs_root_folder_delete_trig AFTER DELETE ON public.fs_root_folders FOR EACH ROW EXECUTE PROCEDURE public.fs_root_folder_delete_trig();


--
-- Name: im_projects im_project_insert_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER im_project_insert_tr BEFORE INSERT ON public.im_projects FOR EACH ROW EXECUTE PROCEDURE public.im_project_insert_tr();


--
-- Name: im_projects im_projects_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER im_projects_update_tr AFTER UPDATE ON public.im_projects FOR EACH ROW EXECUTE PROCEDURE public.im_projects_update_tr();


--
-- Name: lobs lobs_delete_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER lobs_delete_tr BEFORE DELETE ON public.lobs FOR EACH ROW EXECUTE PROCEDURE public.lobs_delete_tr();


--
-- Name: membership_rels membership_rels_del_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER membership_rels_del_tr BEFORE DELETE ON public.membership_rels FOR EACH ROW EXECUTE PROCEDURE public.membership_rels_del_tr();


--
-- Name: membership_rels membership_rels_in_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER membership_rels_in_tr AFTER INSERT ON public.membership_rels FOR EACH ROW EXECUTE PROCEDURE public.membership_rels_in_tr();


--
-- Name: membership_rels membership_rels_up_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER membership_rels_up_tr BEFORE UPDATE ON public.membership_rels FOR EACH ROW EXECUTE PROCEDURE public.membership_rels_up_tr();


--
-- Name: parties parties_del_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER parties_del_tr BEFORE DELETE ON public.parties FOR EACH ROW EXECUTE PROCEDURE public.parties_del_tr();


--
-- Name: parties parties_in_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER parties_in_tr AFTER INSERT ON public.parties FOR EACH ROW EXECUTE PROCEDURE public.parties_in_tr();


--
-- Name: pinds_blog_entries pinds_blog_entries__dtrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER pinds_blog_entries__dtrg AFTER DELETE ON public.pinds_blog_entries FOR EACH ROW EXECUTE PROCEDURE public.pinds_blog_entries__dtrg();


--
-- Name: pinds_blog_entries pinds_blog_entries__itrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER pinds_blog_entries__itrg AFTER INSERT ON public.pinds_blog_entries FOR EACH ROW EXECUTE PROCEDURE public.pinds_blog_entries__itrg();


--
-- Name: pinds_blog_entries pinds_blog_entries__utrg; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER pinds_blog_entries__utrg AFTER UPDATE ON public.pinds_blog_entries FOR EACH ROW EXECUTE PROCEDURE public.pinds_blog_entries__utrg();


--
-- Name: rel_constraints rel_constraints_del_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER rel_constraints_del_tr AFTER DELETE ON public.rel_constraints FOR EACH ROW EXECUTE PROCEDURE public.rel_constraints_del_tr();


--
-- Name: rel_constraints rel_constraints_ins_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER rel_constraints_ins_tr AFTER INSERT ON public.rel_constraints FOR EACH ROW EXECUTE PROCEDURE public.rel_constraints_ins_tr();


--
-- Name: rel_segments rel_segments_del_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER rel_segments_del_tr BEFORE DELETE ON public.rel_segments FOR EACH ROW EXECUTE PROCEDURE public.rel_segments_del_tr();


--
-- Name: rel_segments rel_segments_in_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER rel_segments_in_tr BEFORE INSERT ON public.rel_segments FOR EACH ROW EXECUTE PROCEDURE public.rel_segments_in_tr();


--
-- Name: site_nodes site_node_insert_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER site_node_insert_tr BEFORE INSERT ON public.site_nodes FOR EACH ROW EXECUTE PROCEDURE public.site_node_insert_tr();


--
-- Name: site_nodes site_node_update_tr; Type: TRIGGER; Schema: public; Owner: evex
--

CREATE TRIGGER site_node_update_tr AFTER UPDATE ON public.site_nodes FOR EACH ROW EXECUTE PROCEDURE public.site_node_update_tr();


--
-- Name: acs_activity_object_map acs_act_obj_mp_activity_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_activity_object_map
    ADD CONSTRAINT acs_act_obj_mp_activity_id_fk FOREIGN KEY (activity_id) REFERENCES public.acs_activities(activity_id) ON DELETE CASCADE;


--
-- Name: acs_activity_object_map acs_act_obj_mp_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_activity_object_map
    ADD CONSTRAINT acs_act_obj_mp_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_activities acs_activities_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_activities
    ADD CONSTRAINT acs_activities_fk FOREIGN KEY (activity_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_attribute_descriptions acs_attr_descs_ob_tp_at_na_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attribute_descriptions
    ADD CONSTRAINT acs_attr_descs_ob_tp_at_na_fk FOREIGN KEY (object_type, attribute_name) REFERENCES public.acs_attributes(object_type, attribute_name);


--
-- Name: acs_attribute_descriptions acs_attr_descs_obj_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attribute_descriptions
    ADD CONSTRAINT acs_attr_descs_obj_type_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: acs_attribute_values acs_attr_values_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attribute_values
    ADD CONSTRAINT acs_attr_values_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES public.acs_attributes(attribute_id);


--
-- Name: acs_attribute_values acs_attr_values_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attribute_values
    ADD CONSTRAINT acs_attr_values_obj_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_attributes acs_attributes_datatype_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attributes
    ADD CONSTRAINT acs_attributes_datatype_fk FOREIGN KEY (datatype) REFERENCES public.acs_datatypes(datatype) ON UPDATE CASCADE;


--
-- Name: acs_attributes acs_attributes_object_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attributes
    ADD CONSTRAINT acs_attributes_object_type_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: acs_attributes acs_attrs_obj_type_tbl_name_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_attributes
    ADD CONSTRAINT acs_attrs_obj_type_tbl_name_fk FOREIGN KEY (object_type, table_name) REFERENCES public.acs_object_type_tables(object_type, table_name);


--
-- Name: acs_data_links acs_data_links_obj_one_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_data_links
    ADD CONSTRAINT acs_data_links_obj_one_fk FOREIGN KEY (object_id_one) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_data_links acs_data_links_obj_two_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_data_links
    ADD CONSTRAINT acs_data_links_obj_two_fk FOREIGN KEY (object_id_two) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_events acs_events_activity_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_events
    ADD CONSTRAINT acs_events_activity_id_fk FOREIGN KEY (activity_id) REFERENCES public.acs_activities(activity_id) ON DELETE SET NULL;


--
-- Name: acs_events acs_events_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_events
    ADD CONSTRAINT acs_events_fk FOREIGN KEY (event_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_events acs_events_recurrence_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_events
    ADD CONSTRAINT acs_events_recurrence_id_fk FOREIGN KEY (recurrence_id) REFERENCES public.recurrences(recurrence_id);


--
-- Name: acs_event_party_map acs_evnt_party_map_evnt_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_event_party_map
    ADD CONSTRAINT acs_evnt_party_map_evnt_id_fk FOREIGN KEY (event_id) REFERENCES public.acs_events(event_id) ON DELETE CASCADE;


--
-- Name: acs_event_party_map acs_evnt_party_map_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_event_party_map
    ADD CONSTRAINT acs_evnt_party_map_party_id_fk FOREIGN KEY (party_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: acs_magic_objects acs_magic_objects_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_magic_objects
    ADD CONSTRAINT acs_magic_objects_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: acs_messages acs_messages_message_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_messages
    ADD CONSTRAINT acs_messages_message_id_fk FOREIGN KEY (message_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: acs_messages acs_messages_reply_to_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_messages
    ADD CONSTRAINT acs_messages_reply_to_fk FOREIGN KEY (reply_to) REFERENCES public.acs_messages(message_id) ON DELETE SET NULL;


--
-- Name: acs_messages acs_messages_sender_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_messages
    ADD CONSTRAINT acs_messages_sender_fk FOREIGN KEY (sender) REFERENCES public.parties(party_id);


--
-- Name: acs_named_objects acs_named_objs_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_named_objects
    ADD CONSTRAINT acs_named_objs_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_named_objects acs_named_objs_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_named_objects
    ADD CONSTRAINT acs_named_objs_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: acs_object_context_index acs_obj_context_idx_anc_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_context_index
    ADD CONSTRAINT acs_obj_context_idx_anc_id_fk FOREIGN KEY (ancestor_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_object_context_index acs_obj_context_idx_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_context_index
    ADD CONSTRAINT acs_obj_context_idx_obj_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_object_type_tables acs_obj_type_tbls_obj_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_type_tables
    ADD CONSTRAINT acs_obj_type_tbls_obj_type_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: acs_object_types acs_object_types_supertype_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_object_types
    ADD CONSTRAINT acs_object_types_supertype_fk FOREIGN KEY (supertype) REFERENCES public.acs_object_types(object_type);


--
-- Name: acs_objects acs_objects_context_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_objects
    ADD CONSTRAINT acs_objects_context_id_fk FOREIGN KEY (context_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_objects acs_objects_creation_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_objects
    ADD CONSTRAINT acs_objects_creation_user_fk FOREIGN KEY (creation_user) REFERENCES public.users(user_id);


--
-- Name: acs_objects acs_objects_modifying_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_objects
    ADD CONSTRAINT acs_objects_modifying_user_fk FOREIGN KEY (modifying_user) REFERENCES public.users(user_id);


--
-- Name: acs_objects acs_objects_object_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_objects
    ADD CONSTRAINT acs_objects_object_type_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: acs_objects acs_objects_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_objects
    ADD CONSTRAINT acs_objects_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE SET NULL;


--
-- Name: acs_permissions acs_permissions_grantee_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_permissions
    ADD CONSTRAINT acs_permissions_grantee_id_fk FOREIGN KEY (grantee_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: acs_permissions acs_permissions_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_permissions
    ADD CONSTRAINT acs_permissions_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_permissions acs_permissions_privilege_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_permissions
    ADD CONSTRAINT acs_permissions_privilege_fk FOREIGN KEY (privilege) REFERENCES public.acs_privileges(privilege) ON DELETE CASCADE;


--
-- Name: acs_privilege_hierarchy acs_priv_hier_child_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_privilege_hierarchy
    ADD CONSTRAINT acs_priv_hier_child_priv_fk FOREIGN KEY (child_privilege) REFERENCES public.acs_privileges(privilege);


--
-- Name: acs_privilege_hierarchy_index acs_priv_hier_child_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_privilege_hierarchy_index
    ADD CONSTRAINT acs_priv_hier_child_priv_fk FOREIGN KEY (child_privilege) REFERENCES public.acs_privileges(privilege);


--
-- Name: acs_privilege_descendant_map acs_priv_hier_child_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_privilege_descendant_map
    ADD CONSTRAINT acs_priv_hier_child_priv_fk FOREIGN KEY (descendant) REFERENCES public.acs_privileges(privilege);


--
-- Name: acs_privilege_hierarchy acs_priv_hier_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_privilege_hierarchy
    ADD CONSTRAINT acs_priv_hier_priv_fk FOREIGN KEY (privilege) REFERENCES public.acs_privileges(privilege);


--
-- Name: acs_privilege_hierarchy_index acs_priv_hier_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_privilege_hierarchy_index
    ADD CONSTRAINT acs_priv_hier_priv_fk FOREIGN KEY (privilege) REFERENCES public.acs_privileges(privilege);


--
-- Name: acs_privilege_descendant_map acs_priv_hier_priv_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_privilege_descendant_map
    ADD CONSTRAINT acs_priv_hier_priv_fk FOREIGN KEY (privilege) REFERENCES public.acs_privileges(privilege);


--
-- Name: acs_rel_types acs_rel_types_obj_type_1_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rel_types
    ADD CONSTRAINT acs_rel_types_obj_type_1_fk FOREIGN KEY (object_type_one) REFERENCES public.acs_object_types(object_type);


--
-- Name: acs_rel_types acs_rel_types_obj_type_2_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rel_types
    ADD CONSTRAINT acs_rel_types_obj_type_2_fk FOREIGN KEY (object_type_two) REFERENCES public.acs_object_types(object_type);


--
-- Name: acs_rel_types acs_rel_types_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rel_types
    ADD CONSTRAINT acs_rel_types_rel_type_fk FOREIGN KEY (rel_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: acs_rel_types acs_rel_types_role_one_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rel_types
    ADD CONSTRAINT acs_rel_types_role_one_fk FOREIGN KEY (role_one) REFERENCES public.acs_rel_roles(role);


--
-- Name: acs_rel_types acs_rel_types_role_two_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rel_types
    ADD CONSTRAINT acs_rel_types_role_two_fk FOREIGN KEY (role_two) REFERENCES public.acs_rel_roles(role);


--
-- Name: acs_rels acs_rels_object_id_one_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rels
    ADD CONSTRAINT acs_rels_object_id_one_fk FOREIGN KEY (object_id_one) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_rels acs_rels_object_id_two_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rels
    ADD CONSTRAINT acs_rels_object_id_two_fk FOREIGN KEY (object_id_two) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_rels acs_rels_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rels
    ADD CONSTRAINT acs_rels_rel_id_fk FOREIGN KEY (rel_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_rels acs_rels_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_rels
    ADD CONSTRAINT acs_rels_rel_type_fk FOREIGN KEY (rel_type) REFERENCES public.acs_rel_types(rel_type);


--
-- Name: acs_sc_bindings acs_sc_bindings_contract_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_bindings
    ADD CONSTRAINT acs_sc_bindings_contract_id_fk FOREIGN KEY (contract_id) REFERENCES public.acs_sc_contracts(contract_id) ON DELETE CASCADE;


--
-- Name: acs_sc_bindings acs_sc_bindings_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_bindings
    ADD CONSTRAINT acs_sc_bindings_impl_id_fk FOREIGN KEY (impl_id) REFERENCES public.acs_sc_impls(impl_id) ON DELETE CASCADE;


--
-- Name: acs_sc_contracts acs_sc_contracts_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_contracts
    ADD CONSTRAINT acs_sc_contracts_id_fk FOREIGN KEY (contract_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_sc_impl_aliases acs_sc_impl_aliases_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_impl_aliases
    ADD CONSTRAINT acs_sc_impl_aliases_impl_id_fk FOREIGN KEY (impl_id) REFERENCES public.acs_sc_impls(impl_id) ON DELETE CASCADE;


--
-- Name: acs_sc_impls acs_sc_impls_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_impls
    ADD CONSTRAINT acs_sc_impls_impl_id_fk FOREIGN KEY (impl_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_sc_msg_type_elements acs_sc_msg_type_el_emti_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_msg_type_elements
    ADD CONSTRAINT acs_sc_msg_type_el_emti_id_fk FOREIGN KEY (element_msg_type_id) REFERENCES public.acs_sc_msg_types(msg_type_id);


--
-- Name: acs_sc_msg_type_elements acs_sc_msg_type_el_mtype_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_msg_type_elements
    ADD CONSTRAINT acs_sc_msg_type_el_mtype_id_fk FOREIGN KEY (msg_type_id) REFERENCES public.acs_sc_msg_types(msg_type_id) ON DELETE CASCADE;


--
-- Name: acs_sc_msg_types acs_sc_msg_types_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_msg_types
    ADD CONSTRAINT acs_sc_msg_types_id_fk FOREIGN KEY (msg_type_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_sc_operations acs_sc_operations_cid_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_cid_fk FOREIGN KEY (contract_id) REFERENCES public.acs_sc_contracts(contract_id) ON DELETE CASCADE;


--
-- Name: acs_sc_operations acs_sc_operations_intype_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_intype_fk FOREIGN KEY (operation_inputtype_id) REFERENCES public.acs_sc_msg_types(msg_type_id);


--
-- Name: acs_sc_operations acs_sc_operations_opid_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_opid_fk FOREIGN KEY (operation_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: acs_sc_operations acs_sc_operations_outtype_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_sc_operations
    ADD CONSTRAINT acs_sc_operations_outtype_fk FOREIGN KEY (operation_outputtype_id) REFERENCES public.acs_sc_msg_types(msg_type_id);


--
-- Name: acs_static_attr_values acs_static_a_v_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_static_attr_values
    ADD CONSTRAINT acs_static_a_v_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES public.acs_attributes(attribute_id);


--
-- Name: acs_static_attr_values acs_static_a_v_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_static_attr_values
    ADD CONSTRAINT acs_static_a_v_obj_id_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type) ON DELETE CASCADE;


--
-- Name: ad_locale_user_prefs ad_locale_user_prefs_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ad_locale_user_prefs
    ADD CONSTRAINT ad_locale_user_prefs_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale) ON DELETE CASCADE;


--
-- Name: ad_locale_user_prefs ad_locale_user_prefs_users_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ad_locale_user_prefs
    ADD CONSTRAINT ad_locale_user_prefs_users_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: admin_rels admin_rels_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.admin_rels
    ADD CONSTRAINT admin_rels_rel_id_fk FOREIGN KEY (rel_id) REFERENCES public.membership_rels(rel_id) ON DELETE CASCADE;


--
-- Name: acs_mail_lite_bounce amlb_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_mail_lite_bounce
    ADD CONSTRAINT amlb_party_id_fk FOREIGN KEY (party_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: acs_mail_lite_bounce_notif amlbn_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_mail_lite_bounce_notif
    ADD CONSTRAINT amlbn_party_id_fk FOREIGN KEY (party_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: acs_mail_lite_mail_log amlml_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_mail_lite_mail_log
    ADD CONSTRAINT amlml_party_id_fk FOREIGN KEY (party_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: acs_mail_lite_queue amlq_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_mail_lite_queue
    ADD CONSTRAINT amlq_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id);


--
-- Name: acs_messages_outgoing amo_message_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_messages_outgoing
    ADD CONSTRAINT amo_message_id_fk FOREIGN KEY (message_id) REFERENCES public.acs_messages(message_id) ON DELETE CASCADE;


--
-- Name: ams_attribute_items ams_attribute_items_ams_attribute_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_attribute_items
    ADD CONSTRAINT ams_attribute_items_ams_attribute_id_fk FOREIGN KEY (ams_attribute_id) REFERENCES public.acs_objects(object_id);


--
-- Name: ams_attribute_items ams_attribute_items_attribute_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_attribute_items
    ADD CONSTRAINT ams_attribute_items_attribute_id_fk FOREIGN KEY (attribute_id) REFERENCES public.acs_attributes(attribute_id);


--
-- Name: ams_attribute_items ams_attribute_items_widget_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_attribute_items
    ADD CONSTRAINT ams_attribute_items_widget_fk FOREIGN KEY (widget) REFERENCES public.ams_widgets(widget);


--
-- Name: ams_attribute_values ams_attribute_values_attribute_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_attribute_values
    ADD CONSTRAINT ams_attribute_values_attribute_id_fk FOREIGN KEY (attribute_id) REFERENCES public.acs_attributes(attribute_id);


--
-- Name: ams_attribute_values ams_attribute_values_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_attribute_values
    ADD CONSTRAINT ams_attribute_values_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: ams_list_attribute_map ams_list_attribute_map_attribute_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_list_attribute_map
    ADD CONSTRAINT ams_list_attribute_map_attribute_id_fk FOREIGN KEY (attribute_id) REFERENCES public.acs_attributes(attribute_id);


--
-- Name: ams_list_attribute_map ams_list_attribute_map_list_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_list_attribute_map
    ADD CONSTRAINT ams_list_attribute_map_list_id_fk FOREIGN KEY (list_id) REFERENCES public.ams_lists(list_id);


--
-- Name: ams_lists ams_lists_description_mime_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_lists
    ADD CONSTRAINT ams_lists_description_mime_type_fk FOREIGN KEY (description_mime_type) REFERENCES public.cr_mime_types(mime_type);


--
-- Name: ams_lists ams_lists_list_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_lists
    ADD CONSTRAINT ams_lists_list_id_fk FOREIGN KEY (list_id) REFERENCES public.acs_objects(object_id);


--
-- Name: ams_lists ams_lists_object_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_lists
    ADD CONSTRAINT ams_lists_object_type_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: ams_lists ams_lists_package_key_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_lists
    ADD CONSTRAINT ams_lists_package_key_fk FOREIGN KEY (package_key) REFERENCES public.apm_package_types(package_key);


--
-- Name: ams_options ams_option_option_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_options
    ADD CONSTRAINT ams_option_option_id_fk FOREIGN KEY (option_id) REFERENCES public.ams_option_types(option_id);


--
-- Name: ams_option_types ams_options_attribute_id_nn; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_option_types
    ADD CONSTRAINT ams_options_attribute_id_nn FOREIGN KEY (attribute_id) REFERENCES public.acs_attributes(attribute_id);


--
-- Name: ams_option_types ams_options_option_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_option_types
    ADD CONSTRAINT ams_options_option_id_fk FOREIGN KEY (option_id) REFERENCES public.acs_objects(object_id);


--
-- Name: ams_options ams_options_value_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ams_options
    ADD CONSTRAINT ams_options_value_id_fk FOREIGN KEY (value_id) REFERENCES public.ams_option_ids(value_id);


--
-- Name: apm_applications apm_applications_aplt_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_applications
    ADD CONSTRAINT apm_applications_aplt_id_fk FOREIGN KEY (application_id) REFERENCES public.apm_packages(package_id);


--
-- Name: apm_package_callbacks apm_package_callbacks_vid_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_callbacks
    ADD CONSTRAINT apm_package_callbacks_vid_fk FOREIGN KEY (version_id) REFERENCES public.apm_package_versions(version_id) ON DELETE CASCADE;


--
-- Name: apm_package_dependencies apm_package_deps_version_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_dependencies
    ADD CONSTRAINT apm_package_deps_version_id_fk FOREIGN KEY (version_id) REFERENCES public.apm_package_versions(version_id) ON DELETE CASCADE;


--
-- Name: apm_package_owners apm_package_owners_ver_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_owners
    ADD CONSTRAINT apm_package_owners_ver_id_fk FOREIGN KEY (version_id) REFERENCES public.apm_package_versions(version_id) ON DELETE CASCADE;


--
-- Name: apm_package_versions apm_package_ver_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_versions
    ADD CONSTRAINT apm_package_ver_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id);


--
-- Name: apm_package_version_attr apm_package_vers_attr_vid_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_version_attr
    ADD CONSTRAINT apm_package_vers_attr_vid_fk FOREIGN KEY (version_id) REFERENCES public.apm_package_versions(version_id) ON DELETE CASCADE;


--
-- Name: apm_package_versions apm_package_vers_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_versions
    ADD CONSTRAINT apm_package_vers_id_fk FOREIGN KEY (version_id) REFERENCES public.acs_objects(object_id);


--
-- Name: apm_package_versions apm_package_vers_pack_key_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_package_versions
    ADD CONSTRAINT apm_package_vers_pack_key_fk FOREIGN KEY (package_key) REFERENCES public.apm_package_types(package_key);


--
-- Name: apm_packages apm_packages_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_packages
    ADD CONSTRAINT apm_packages_package_id_fk FOREIGN KEY (package_id) REFERENCES public.acs_objects(object_id);


--
-- Name: apm_packages apm_packages_package_key_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_packages
    ADD CONSTRAINT apm_packages_package_key_fk FOREIGN KEY (package_key) REFERENCES public.apm_package_types(package_key);


--
-- Name: apm_parameter_values apm_parameter_values_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameter_values
    ADD CONSTRAINT apm_parameter_values_fk FOREIGN KEY (value_id) REFERENCES public.acs_objects(object_id);


--
-- Name: apm_parameter_values apm_parameter_values_pk_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameter_values
    ADD CONSTRAINT apm_parameter_values_pk_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: apm_parameter_values apm_parameter_values_pm_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameter_values
    ADD CONSTRAINT apm_parameter_values_pm_id_fk FOREIGN KEY (parameter_id) REFERENCES public.apm_parameters(parameter_id);


--
-- Name: apm_parameters apm_parameters_package_key_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameters
    ADD CONSTRAINT apm_parameters_package_key_fk FOREIGN KEY (package_key) REFERENCES public.apm_package_types(package_key);


--
-- Name: apm_parameters apm_parameters_parameter_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_parameters
    ADD CONSTRAINT apm_parameters_parameter_id_fk FOREIGN KEY (parameter_id) REFERENCES public.acs_objects(object_id);


--
-- Name: apm_services apm_services_service_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.apm_services
    ADD CONSTRAINT apm_services_service_id_fk FOREIGN KEY (service_id) REFERENCES public.apm_packages(package_id);


--
-- Name: application_groups application_groups_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.application_groups
    ADD CONSTRAINT application_groups_group_id_fk FOREIGN KEY (group_id) REFERENCES public.groups(group_id) ON DELETE CASCADE;


--
-- Name: application_groups application_groups_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.application_groups
    ADD CONSTRAINT application_groups_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id);


--
-- Name: acs_reference_repositories arr_maintainer_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_reference_repositories
    ADD CONSTRAINT arr_maintainer_id_fk FOREIGN KEY (maintainer_id) REFERENCES public.persons(person_id);


--
-- Name: acs_reference_repositories arr_repository_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_reference_repositories
    ADD CONSTRAINT arr_repository_id_fk FOREIGN KEY (repository_id) REFERENCES public.acs_objects(object_id);


--
-- Name: acs_enum_values asc_enum_values_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.acs_enum_values
    ADD CONSTRAINT asc_enum_values_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES public.acs_attributes(attribute_id);


--
-- Name: attachments_fs_root_folder_map attach_fldr_map_folder_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.attachments_fs_root_folder_map
    ADD CONSTRAINT attach_fldr_map_folder_id_fk FOREIGN KEY (folder_id) REFERENCES public.fs_root_folders(folder_id);


--
-- Name: attachments_fs_root_folder_map attach_fldr_map_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.attachments_fs_root_folder_map
    ADD CONSTRAINT attach_fldr_map_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id);


--
-- Name: attachments attachments_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.attachments
    ADD CONSTRAINT attachments_item_id_fk FOREIGN KEY (item_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: attachments attachments_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.attachments
    ADD CONSTRAINT attachments_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: auth_authorities auth_authorities_auth_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_auth_id_fk FOREIGN KEY (authority_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: auth_authorities auth_authorities_auth_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_auth_impl_fk FOREIGN KEY (auth_impl_id) REFERENCES public.acs_objects(object_id);


--
-- Name: auth_authorities auth_authorities_getdoc_ipl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_getdoc_ipl_fk FOREIGN KEY (get_doc_impl_id) REFERENCES public.acs_objects(object_id);


--
-- Name: auth_authorities auth_authorities_procdoc_ipl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_procdoc_ipl_fk FOREIGN KEY (process_doc_impl_id) REFERENCES public.acs_objects(object_id);


--
-- Name: auth_authorities auth_authorities_pwd_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_pwd_impl_fk FOREIGN KEY (pwd_impl_id) REFERENCES public.acs_objects(object_id);


--
-- Name: auth_authorities auth_authorities_reg_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_reg_impl_fk FOREIGN KEY (register_impl_id) REFERENCES public.acs_objects(object_id);


--
-- Name: auth_authorities auth_authorities_search_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_search_impl_id_fk FOREIGN KEY (search_impl_id) REFERENCES public.acs_objects(object_id);


--
-- Name: auth_authorities auth_authorities_urinf_ipl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_authorities
    ADD CONSTRAINT auth_authorities_urinf_ipl_fk FOREIGN KEY (user_info_impl_id) REFERENCES public.acs_objects(object_id);


--
-- Name: auth_batch_job_entries auth_batch_job_entries_job_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_batch_job_entries
    ADD CONSTRAINT auth_batch_job_entries_job_fk FOREIGN KEY (job_id) REFERENCES public.auth_batch_jobs(job_id) ON DELETE CASCADE;


--
-- Name: auth_batch_job_entries auth_batch_job_entries_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_batch_job_entries
    ADD CONSTRAINT auth_batch_job_entries_user_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE SET NULL;


--
-- Name: auth_batch_jobs auth_batch_jobs_auth_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_batch_jobs
    ADD CONSTRAINT auth_batch_jobs_auth_id_fk FOREIGN KEY (authority_id) REFERENCES public.auth_authorities(authority_id) ON DELETE CASCADE;


--
-- Name: auth_batch_jobs auth_batch_jobs_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_batch_jobs
    ADD CONSTRAINT auth_batch_jobs_user_fk FOREIGN KEY (creation_user) REFERENCES public.users(user_id) ON DELETE SET NULL;


--
-- Name: auth_driver_params auth_driver_params_aid_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_driver_params
    ADD CONSTRAINT auth_driver_params_aid_fk FOREIGN KEY (authority_id) REFERENCES public.auth_authorities(authority_id);


--
-- Name: auth_driver_params auth_driver_params_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.auth_driver_params
    ADD CONSTRAINT auth_driver_params_impl_id_fk FOREIGN KEY (impl_id) REFERENCES public.acs_objects(object_id);


--
-- Name: cal_items cal_item_cal_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_items
    ADD CONSTRAINT cal_item_cal_item_id_fk FOREIGN KEY (cal_item_id) REFERENCES public.acs_events(event_id);


--
-- Name: cal_item_types cal_item_type_cal_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_item_types
    ADD CONSTRAINT cal_item_type_cal_id_fk FOREIGN KEY (calendar_id) REFERENCES public.calendars(calendar_id);


--
-- Name: cal_items cal_item_which_cal_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_items
    ADD CONSTRAINT cal_item_which_cal_fk FOREIGN KEY (on_which_calendar) REFERENCES public.calendars(calendar_id) ON DELETE CASCADE;


--
-- Name: cal_items cal_items_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_items
    ADD CONSTRAINT cal_items_type_fk FOREIGN KEY (on_which_calendar, item_type_id) REFERENCES public.cal_item_types(calendar_id, item_type_id);


--
-- Name: cal_party_prefs cal_pty_prefs_cal_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_party_prefs
    ADD CONSTRAINT cal_pty_prefs_cal_id_fk FOREIGN KEY (calendar_id) REFERENCES public.calendars(calendar_id) ON DELETE CASCADE;


--
-- Name: cal_party_prefs cal_pty_prefs_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_party_prefs
    ADD CONSTRAINT cal_pty_prefs_party_id_fk FOREIGN KEY (party_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: cal_party_prefs cal_pty_prefs_time_zone_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cal_party_prefs
    ADD CONSTRAINT cal_pty_prefs_time_zone_fk FOREIGN KEY (time_zone) REFERENCES public.timezones(tz_id) ON DELETE CASCADE;


--
-- Name: calendars calendars_calendar_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.calendars
    ADD CONSTRAINT calendars_calendar_id_fk FOREIGN KEY (calendar_id) REFERENCES public.acs_objects(object_id);


--
-- Name: calendars calendars_calendar_owner_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.calendars
    ADD CONSTRAINT calendars_calendar_owner_id_fk FOREIGN KEY (owner_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: calendars calendars_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.calendars
    ADD CONSTRAINT calendars_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: categories cat_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT cat_category_id_fk FOREIGN KEY (category_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: im_dynfield_cat_multi_value cat_multi_val_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_cat_multi_value
    ADD CONSTRAINT cat_multi_val_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES public.im_dynfield_attributes(attribute_id);


--
-- Name: im_dynfield_cat_multi_value cat_multi_val_cat_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_cat_multi_value
    ADD CONSTRAINT cat_multi_val_cat_id_fk FOREIGN KEY (category_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_dynfield_cat_multi_value cat_multi_val_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_cat_multi_value
    ADD CONSTRAINT cat_multi_val_obj_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: category_object_map cat_object_map_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_object_map
    ADD CONSTRAINT cat_object_map_category_id_fk FOREIGN KEY (category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: category_object_map cat_object_map_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_object_map
    ADD CONSTRAINT cat_object_map_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: categories cat_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT cat_parent_id_fk FOREIGN KEY (parent_id) REFERENCES public.categories(category_id);


--
-- Name: category_translations cat_trans_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_translations
    ADD CONSTRAINT cat_trans_category_id_fk FOREIGN KEY (category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: category_translations cat_trans_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_translations
    ADD CONSTRAINT cat_trans_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale);


--
-- Name: categories cat_tree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT cat_tree_id_fk FOREIGN KEY (tree_id) REFERENCES public.category_trees(tree_id) ON DELETE CASCADE;


--
-- Name: category_tree_map cat_tree_map_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_tree_map
    ADD CONSTRAINT cat_tree_map_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: category_tree_map cat_tree_map_subtree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_tree_map
    ADD CONSTRAINT cat_tree_map_subtree_id_fk FOREIGN KEY (subtree_category_id) REFERENCES public.categories(category_id);


--
-- Name: category_tree_map cat_tree_map_tree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_tree_map
    ADD CONSTRAINT cat_tree_map_tree_id_fk FOREIGN KEY (tree_id) REFERENCES public.category_trees(tree_id) ON DELETE CASCADE;


--
-- Name: category_tree_translations cat_tree_trans_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_tree_translations
    ADD CONSTRAINT cat_tree_trans_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale);


--
-- Name: category_tree_translations cat_tree_trans_tree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_tree_translations
    ADD CONSTRAINT cat_tree_trans_tree_id_fk FOREIGN KEY (tree_id) REFERENCES public.category_trees(tree_id) ON DELETE CASCADE;


--
-- Name: category_trees cat_trees_tree_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_trees
    ADD CONSTRAINT cat_trees_tree_id_fk FOREIGN KEY (tree_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: category_links category_links_from_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_links
    ADD CONSTRAINT category_links_from_fk FOREIGN KEY (from_category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: category_links category_links_to_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_links
    ADD CONSTRAINT category_links_to_fk FOREIGN KEY (to_category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: category_search_results category_results_query_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_search_results
    ADD CONSTRAINT category_results_query_fk FOREIGN KEY (query_id) REFERENCES public.category_search(query_id) ON DELETE CASCADE;


--
-- Name: category_search_results category_results_synonym_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_search_results
    ADD CONSTRAINT category_results_synonym_fk FOREIGN KEY (synonym_id) REFERENCES public.category_synonyms(synonym_id) ON DELETE CASCADE;


--
-- Name: category_search_index category_search_index_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_search_index
    ADD CONSTRAINT category_search_index_fk FOREIGN KEY (query_id) REFERENCES public.category_search(query_id) ON DELETE CASCADE;


--
-- Name: category_search category_search_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_search
    ADD CONSTRAINT category_search_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale) ON DELETE CASCADE;


--
-- Name: category_synonym_index category_synonym_index_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_synonym_index
    ADD CONSTRAINT category_synonym_index_fk FOREIGN KEY (synonym_id) REFERENCES public.category_synonyms(synonym_id) ON DELETE CASCADE;


--
-- Name: category_synonyms category_synonyms_cat_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_synonyms
    ADD CONSTRAINT category_synonyms_cat_fk FOREIGN KEY (category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: category_synonyms category_synonyms_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.category_synonyms
    ADD CONSTRAINT category_synonyms_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale) ON DELETE CASCADE;


--
-- Name: weblogger_channels channel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_channels
    ADD CONSTRAINT channel_id_fk FOREIGN KEY (channel_id) REFERENCES public.acs_objects(object_id);


--
-- Name: composition_rels composition_rels_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.composition_rels
    ADD CONSTRAINT composition_rels_rel_id_fk FOREIGN KEY (rel_id) REFERENCES public.acs_rels(rel_id) ON DELETE CASCADE;


--
-- Name: im_dynfield_widgets contact_widgets_stor_typ_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_widgets
    ADD CONSTRAINT contact_widgets_stor_typ_fk FOREIGN KEY (storage_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: cr_child_rels cr_child_rels_child_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_child_rels
    ADD CONSTRAINT cr_child_rels_child_id_fk FOREIGN KEY (child_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_child_rels cr_child_rels_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_child_rels
    ADD CONSTRAINT cr_child_rels_parent_id_fk FOREIGN KEY (parent_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cr_child_rels cr_child_rels_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_child_rels
    ADD CONSTRAINT cr_child_rels_rel_id_fk FOREIGN KEY (rel_id) REFERENCES public.acs_objects(object_id);


--
-- Name: cr_content_mime_type_map cr_content_mime_map_ctyp_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_content_mime_type_map
    ADD CONSTRAINT cr_content_mime_map_ctyp_fk FOREIGN KEY (content_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: cr_content_mime_type_map cr_content_mime_map_typ_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_content_mime_type_map
    ADD CONSTRAINT cr_content_mime_map_typ_fk FOREIGN KEY (mime_type) REFERENCES public.cr_mime_types(mime_type);


--
-- Name: cr_extlinks cr_extlinks_extlink_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_extlinks
    ADD CONSTRAINT cr_extlinks_extlink_id_fk FOREIGN KEY (extlink_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_folder_type_map cr_folder_type_map_fldr_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_folder_type_map
    ADD CONSTRAINT cr_folder_type_map_fldr_fk FOREIGN KEY (folder_id) REFERENCES public.cr_folders(folder_id) ON DELETE CASCADE;


--
-- Name: cr_folder_type_map cr_folder_type_map_typ_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_folder_type_map
    ADD CONSTRAINT cr_folder_type_map_typ_fk FOREIGN KEY (content_type) REFERENCES public.acs_object_types(object_type) ON DELETE CASCADE;


--
-- Name: cr_folders cr_folders_folder_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_folders
    ADD CONSTRAINT cr_folders_folder_id_fk FOREIGN KEY (folder_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_folders cr_folders_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_folders
    ADD CONSTRAINT cr_folders_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id);


--
-- Name: cr_item_keyword_map cr_item_keyword_map_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_keyword_map
    ADD CONSTRAINT cr_item_keyword_map_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_item_keyword_map cr_item_keyword_map_kw_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_keyword_map
    ADD CONSTRAINT cr_item_keyword_map_kw_fk FOREIGN KEY (keyword_id) REFERENCES public.cr_keywords(keyword_id);


--
-- Name: cr_item_publish_audit cr_item_publish_audit_item_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_publish_audit
    ADD CONSTRAINT cr_item_publish_audit_item_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_item_publish_audit cr_item_publish_audit_nrev_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_publish_audit
    ADD CONSTRAINT cr_item_publish_audit_nrev_fk FOREIGN KEY (new_revision) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: cr_item_publish_audit cr_item_publish_audit_orev_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_publish_audit
    ADD CONSTRAINT cr_item_publish_audit_orev_fk FOREIGN KEY (old_revision) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: cr_item_rels cr_item_rels_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_rels
    ADD CONSTRAINT cr_item_rels_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_item_rels cr_item_rels_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_rels
    ADD CONSTRAINT cr_item_rels_rel_id_fk FOREIGN KEY (rel_id) REFERENCES public.acs_objects(object_id);


--
-- Name: cr_item_rels cr_item_rels_rel_obj_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_rels
    ADD CONSTRAINT cr_item_rels_rel_obj_fk FOREIGN KEY (related_object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: cr_item_template_map cr_item_template_map_ctx_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_template_map
    ADD CONSTRAINT cr_item_template_map_ctx_fk FOREIGN KEY (use_context) REFERENCES public.cr_template_use_contexts(use_context);


--
-- Name: cr_item_template_map cr_item_template_map_item_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_template_map
    ADD CONSTRAINT cr_item_template_map_item_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_item_template_map cr_item_template_map_tmpl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_item_template_map
    ADD CONSTRAINT cr_item_template_map_tmpl_fk FOREIGN KEY (template_id) REFERENCES public.cr_templates(template_id);


--
-- Name: cr_items cr_items_content_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_items
    ADD CONSTRAINT cr_items_content_type_fk FOREIGN KEY (content_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: cr_items cr_items_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_items
    ADD CONSTRAINT cr_items_item_id_fk FOREIGN KEY (item_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cr_items cr_items_latest_revision_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_items
    ADD CONSTRAINT cr_items_latest_revision_fk FOREIGN KEY (latest_revision) REFERENCES public.cr_revisions(revision_id) ON DELETE SET NULL;


--
-- Name: cr_items cr_items_live_revision_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_items
    ADD CONSTRAINT cr_items_live_revision_fk FOREIGN KEY (live_revision) REFERENCES public.cr_revisions(revision_id) ON DELETE SET NULL;


--
-- Name: cr_items cr_items_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_items
    ADD CONSTRAINT cr_items_locale_fk FOREIGN KEY (locale) REFERENCES public.cr_locales(locale);


--
-- Name: cr_items cr_items_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_items
    ADD CONSTRAINT cr_items_parent_id_fk FOREIGN KEY (parent_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cr_keywords cr_keywords_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_keywords
    ADD CONSTRAINT cr_keywords_parent_id_fk FOREIGN KEY (parent_id) REFERENCES public.cr_keywords(keyword_id);


--
-- Name: cr_extension_mime_type_map cr_mime_ext_map_mime_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_extension_mime_type_map
    ADD CONSTRAINT cr_mime_ext_map_mime_type_fk FOREIGN KEY (mime_type) REFERENCES public.cr_mime_types(mime_type);


--
-- Name: cr_release_periods cr_release_periods_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_release_periods
    ADD CONSTRAINT cr_release_periods_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_revision_attributes cr_revision_attributes_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_revision_attributes
    ADD CONSTRAINT cr_revision_attributes_fk FOREIGN KEY (revision_id) REFERENCES public.cr_revisions(revision_id);


--
-- Name: cr_revisions cr_revisions_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_revisions
    ADD CONSTRAINT cr_revisions_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_revisions cr_revisions_lob_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_revisions
    ADD CONSTRAINT cr_revisions_lob_fk FOREIGN KEY (lob) REFERENCES public.lobs(lob_id) ON DELETE SET NULL;


--
-- Name: cr_revisions cr_revisions_mime_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_revisions
    ADD CONSTRAINT cr_revisions_mime_type_fk FOREIGN KEY (mime_type) REFERENCES public.cr_mime_types(mime_type);


--
-- Name: cr_revisions cr_revisions_revision_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_revisions
    ADD CONSTRAINT cr_revisions_revision_id_fk FOREIGN KEY (revision_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: cr_symlinks cr_symlinks_symlink_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_symlinks
    ADD CONSTRAINT cr_symlinks_symlink_id_fk FOREIGN KEY (symlink_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_symlinks cr_symlinks_target_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_symlinks
    ADD CONSTRAINT cr_symlinks_target_id_fk FOREIGN KEY (target_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_templates cr_templates_template_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_templates
    ADD CONSTRAINT cr_templates_template_id_fk FOREIGN KEY (template_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: cr_type_children cr_type_children_child_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_children
    ADD CONSTRAINT cr_type_children_child_type_fk FOREIGN KEY (child_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: cr_type_children cr_type_children_parent_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_children
    ADD CONSTRAINT cr_type_children_parent_type_fk FOREIGN KEY (parent_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: cr_type_relations cr_type_relations_child_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_relations
    ADD CONSTRAINT cr_type_relations_child_fk FOREIGN KEY (target_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: cr_type_relations cr_type_relations_parent_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_relations
    ADD CONSTRAINT cr_type_relations_parent_fk FOREIGN KEY (content_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: cr_type_template_map cr_type_template_map_ctx_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_template_map
    ADD CONSTRAINT cr_type_template_map_ctx_fk FOREIGN KEY (use_context) REFERENCES public.cr_template_use_contexts(use_context);


--
-- Name: cr_type_template_map cr_type_template_map_tmpl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_template_map
    ADD CONSTRAINT cr_type_template_map_tmpl_fk FOREIGN KEY (template_id) REFERENCES public.cr_templates(template_id);


--
-- Name: cr_type_template_map cr_type_template_map_typ_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.cr_type_template_map
    ADD CONSTRAINT cr_type_template_map_typ_fk FOREIGN KEY (content_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: dav_site_node_folder_map dav_impls_folder_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.dav_site_node_folder_map
    ADD CONSTRAINT dav_impls_folder_id_fk FOREIGN KEY (folder_id) REFERENCES public.cr_folders(folder_id) ON DELETE CASCADE;


--
-- Name: dav_site_node_folder_map dav_side_node_folder_map_node_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.dav_site_node_folder_map
    ADD CONSTRAINT dav_side_node_folder_map_node_id_fk FOREIGN KEY (node_id) REFERENCES public.site_nodes(node_id) ON DELETE CASCADE;


--
-- Name: ec_addresses ec_addresses_country_code_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_addresses
    ADD CONSTRAINT ec_addresses_country_code_fkey FOREIGN KEY (country_code) REFERENCES public.countries(iso);


--
-- Name: ec_addresses ec_addresses_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_addresses
    ADD CONSTRAINT ec_addresses_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ec_addresses ec_addresses_usps_abbrev_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_addresses
    ADD CONSTRAINT ec_addresses_usps_abbrev_fkey FOREIGN KEY (usps_abbrev) REFERENCES public.us_states(abbrev);


--
-- Name: ec_admin_settings ec_admin_settings_default_template_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_admin_settings
    ADD CONSTRAINT ec_admin_settings_default_template_fkey FOREIGN KEY (default_template) REFERENCES public.ec_templates(template_id);


--
-- Name: ec_admin_settings ec_admin_settings_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_admin_settings
    ADD CONSTRAINT ec_admin_settings_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_automatic_email_log ec_automatic_email_log_email_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_automatic_email_log
    ADD CONSTRAINT ec_automatic_email_log_email_template_id_fkey FOREIGN KEY (email_template_id) REFERENCES public.ec_email_templates(email_template_id);


--
-- Name: ec_automatic_email_log ec_automatic_email_log_gift_certificate_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_automatic_email_log
    ADD CONSTRAINT ec_automatic_email_log_gift_certificate_id_fkey FOREIGN KEY (gift_certificate_id) REFERENCES public.ec_gift_certificates(gift_certificate_id);


--
-- Name: ec_automatic_email_log ec_automatic_email_log_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_automatic_email_log
    ADD CONSTRAINT ec_automatic_email_log_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.ec_orders(order_id);


--
-- Name: ec_automatic_email_log ec_automatic_email_log_shipment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_automatic_email_log
    ADD CONSTRAINT ec_automatic_email_log_shipment_id_fkey FOREIGN KEY (shipment_id) REFERENCES public.ec_shipments(shipment_id);


--
-- Name: ec_automatic_email_log ec_automatic_email_log_user_identification_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_automatic_email_log
    ADD CONSTRAINT ec_automatic_email_log_user_identification_id_fkey FOREIGN KEY (user_identification_id) REFERENCES public.ec_user_identification(user_identification_id);


--
-- Name: ec_cat_mailing_lists ec_cat_mailing_lists_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_cat_mailing_lists
    ADD CONSTRAINT ec_cat_mailing_lists_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.ec_categories(category_id);


--
-- Name: ec_cat_mailing_lists ec_cat_mailing_lists_subcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_cat_mailing_lists
    ADD CONSTRAINT ec_cat_mailing_lists_subcategory_id_fkey FOREIGN KEY (subcategory_id) REFERENCES public.ec_subcategories(subcategory_id);


--
-- Name: ec_cat_mailing_lists ec_cat_mailing_lists_subsubcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_cat_mailing_lists
    ADD CONSTRAINT ec_cat_mailing_lists_subsubcategory_id_fkey FOREIGN KEY (subsubcategory_id) REFERENCES public.ec_subsubcategories(subsubcategory_id);


--
-- Name: ec_cat_mailing_lists ec_cat_mailing_lists_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_cat_mailing_lists
    ADD CONSTRAINT ec_cat_mailing_lists_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ec_categories ec_categories_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_categories
    ADD CONSTRAINT ec_categories_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_category_product_map ec_category_product_map_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_category_product_map
    ADD CONSTRAINT ec_category_product_map_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.ec_categories(category_id);


--
-- Name: ec_category_product_map ec_category_product_map_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_category_product_map
    ADD CONSTRAINT ec_category_product_map_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_category_product_map ec_category_product_map_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_category_product_map
    ADD CONSTRAINT ec_category_product_map_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_category_template_map ec_category_template_map_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_category_template_map
    ADD CONSTRAINT ec_category_template_map_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.ec_categories(category_id);


--
-- Name: ec_category_template_map ec_category_template_map_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_category_template_map
    ADD CONSTRAINT ec_category_template_map_template_id_fkey FOREIGN KEY (template_id) REFERENCES public.ec_templates(template_id);


--
-- Name: ec_creditcards ec_creditcards_billing_address_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_creditcards
    ADD CONSTRAINT ec_creditcards_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES public.ec_addresses(address_id);


--
-- Name: ec_creditcards ec_creditcards_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_creditcards
    ADD CONSTRAINT ec_creditcards_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ec_cs_action_info_used_map ec_cs_action_info_used_map_action_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_cs_action_info_used_map
    ADD CONSTRAINT ec_cs_action_info_used_map_action_id_fkey FOREIGN KEY (action_id) REFERENCES public.ec_customer_service_actions(action_id);


--
-- Name: ec_cs_issue_type_map ec_cs_issue_type_map_issue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_cs_issue_type_map
    ADD CONSTRAINT ec_cs_issue_type_map_issue_id_fkey FOREIGN KEY (issue_id) REFERENCES public.ec_customer_service_issues(issue_id);


--
-- Name: ec_custom_product_field_values ec_custom_product_field_values_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_custom_product_field_values
    ADD CONSTRAINT ec_custom_product_field_values_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_custom_product_field_values ec_custom_product_field_values_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_custom_product_field_values
    ADD CONSTRAINT ec_custom_product_field_values_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_custom_product_fields ec_custom_product_fields_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_custom_product_fields
    ADD CONSTRAINT ec_custom_product_fields_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_customer_serv_interactions ec_customer_serv_interactions_customer_service_rep_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_serv_interactions
    ADD CONSTRAINT ec_customer_serv_interactions_customer_service_rep_fkey FOREIGN KEY (customer_service_rep) REFERENCES public.users(user_id);


--
-- Name: ec_customer_serv_interactions ec_customer_serv_interactions_user_identification_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_serv_interactions
    ADD CONSTRAINT ec_customer_serv_interactions_user_identification_id_fkey FOREIGN KEY (user_identification_id) REFERENCES public.ec_user_identification(user_identification_id);


--
-- Name: ec_customer_service_actions ec_customer_service_actions_interaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_service_actions
    ADD CONSTRAINT ec_customer_service_actions_interaction_id_fkey FOREIGN KEY (interaction_id) REFERENCES public.ec_customer_serv_interactions(interaction_id);


--
-- Name: ec_customer_service_actions ec_customer_service_actions_issue_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_service_actions
    ADD CONSTRAINT ec_customer_service_actions_issue_id_fkey FOREIGN KEY (issue_id) REFERENCES public.ec_customer_service_issues(issue_id);


--
-- Name: ec_customer_service_issues ec_customer_service_issues_closed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_service_issues
    ADD CONSTRAINT ec_customer_service_issues_closed_by_fkey FOREIGN KEY (closed_by) REFERENCES public.users(user_id);


--
-- Name: ec_customer_service_issues ec_customer_service_issues_gift_certificate_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_service_issues
    ADD CONSTRAINT ec_customer_service_issues_gift_certificate_id_fkey FOREIGN KEY (gift_certificate_id) REFERENCES public.ec_gift_certificates(gift_certificate_id);


--
-- Name: ec_customer_service_issues ec_customer_service_issues_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_service_issues
    ADD CONSTRAINT ec_customer_service_issues_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.ec_orders(order_id);


--
-- Name: ec_customer_service_issues ec_customer_service_issues_user_identification_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_customer_service_issues
    ADD CONSTRAINT ec_customer_service_issues_user_identification_id_fkey FOREIGN KEY (user_identification_id) REFERENCES public.ec_user_identification(user_identification_id);


--
-- Name: ec_email_templates ec_email_templates_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_email_templates
    ADD CONSTRAINT ec_email_templates_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_financial_transactions ec_financial_transactions_creditcard_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_financial_transactions
    ADD CONSTRAINT ec_financial_transactions_creditcard_id_fkey FOREIGN KEY (creditcard_id) REFERENCES public.ec_creditcards(creditcard_id);


--
-- Name: ec_financial_transactions ec_financial_transactions_gift_certificate_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_financial_transactions
    ADD CONSTRAINT ec_financial_transactions_gift_certificate_id_fkey FOREIGN KEY (gift_certificate_id) REFERENCES public.ec_gift_certificates(gift_certificate_id);


--
-- Name: ec_financial_transactions ec_financial_transactions_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_financial_transactions
    ADD CONSTRAINT ec_financial_transactions_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.ec_orders(order_id);


--
-- Name: ec_financial_transactions ec_financial_transactions_refund_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_financial_transactions
    ADD CONSTRAINT ec_financial_transactions_refund_id_fkey FOREIGN KEY (refund_id) REFERENCES public.ec_refunds(refund_id);


--
-- Name: ec_financial_transactions ec_financial_transactions_refunded_transaction_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_financial_transactions
    ADD CONSTRAINT ec_financial_transactions_refunded_transaction_id_fkey FOREIGN KEY (refunded_transaction_id) REFERENCES public.ec_financial_transactions(transaction_id);


--
-- Name: ec_financial_transactions ec_financial_transactions_shipment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_financial_transactions
    ADD CONSTRAINT ec_financial_transactions_shipment_id_fkey FOREIGN KEY (shipment_id) REFERENCES public.ec_shipments(shipment_id);


--
-- Name: ec_gift_certificate_usage ec_gift_certificate_usage_gift_certificate_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_gift_certificate_usage
    ADD CONSTRAINT ec_gift_certificate_usage_gift_certificate_id_fkey FOREIGN KEY (gift_certificate_id) REFERENCES public.ec_gift_certificates(gift_certificate_id);


--
-- Name: ec_gift_certificate_usage ec_gift_certificate_usage_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_gift_certificate_usage
    ADD CONSTRAINT ec_gift_certificate_usage_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.ec_orders(order_id);


--
-- Name: ec_gift_certificates ec_gift_certificates_issued_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_gift_certificates
    ADD CONSTRAINT ec_gift_certificates_issued_by_fkey FOREIGN KEY (issued_by) REFERENCES public.users(user_id);


--
-- Name: ec_gift_certificates ec_gift_certificates_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_gift_certificates
    ADD CONSTRAINT ec_gift_certificates_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_gift_certificates ec_gift_certificates_purchased_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_gift_certificates
    ADD CONSTRAINT ec_gift_certificates_purchased_by_fkey FOREIGN KEY (purchased_by) REFERENCES public.users(user_id);


--
-- Name: ec_gift_certificates ec_gift_certificates_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_gift_certificates
    ADD CONSTRAINT ec_gift_certificates_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ec_gift_certificates ec_gift_certificates_voided_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_gift_certificates
    ADD CONSTRAINT ec_gift_certificates_voided_by_fkey FOREIGN KEY (voided_by) REFERENCES public.users(user_id);


--
-- Name: ec_items ec_items_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_items
    ADD CONSTRAINT ec_items_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.ec_orders(order_id);


--
-- Name: ec_items ec_items_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_items
    ADD CONSTRAINT ec_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_items ec_items_refund_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_items
    ADD CONSTRAINT ec_items_refund_id_fkey FOREIGN KEY (refund_id) REFERENCES public.ec_refunds(refund_id);


--
-- Name: ec_items ec_items_shipment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_items
    ADD CONSTRAINT ec_items_shipment_id_fkey FOREIGN KEY (shipment_id) REFERENCES public.ec_shipments(shipment_id);


--
-- Name: ec_items ec_items_voided_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_items
    ADD CONSTRAINT ec_items_voided_by_fkey FOREIGN KEY (voided_by) REFERENCES public.users(user_id);


--
-- Name: ec_offers ec_offers_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_offers
    ADD CONSTRAINT ec_offers_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_offers ec_offers_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_offers
    ADD CONSTRAINT ec_offers_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_offers ec_offers_retailer_location_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_offers
    ADD CONSTRAINT ec_offers_retailer_location_id_fkey FOREIGN KEY (retailer_location_id) REFERENCES public.ec_retailer_locations(retailer_location_id);


--
-- Name: ec_orders ec_orders_creditcard_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_orders
    ADD CONSTRAINT ec_orders_creditcard_id_fkey FOREIGN KEY (creditcard_id) REFERENCES public.ec_creditcards(creditcard_id);


--
-- Name: ec_orders ec_orders_shipping_address_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_orders
    ADD CONSTRAINT ec_orders_shipping_address_fkey FOREIGN KEY (shipping_address) REFERENCES public.ec_addresses(address_id);


--
-- Name: ec_orders ec_orders_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_orders
    ADD CONSTRAINT ec_orders_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ec_orders ec_orders_user_session_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_orders
    ADD CONSTRAINT ec_orders_user_session_id_fkey FOREIGN KEY (user_session_id) REFERENCES public.ec_user_sessions(user_session_id);


--
-- Name: ec_orders ec_orders_voided_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_orders
    ADD CONSTRAINT ec_orders_voided_by_fkey FOREIGN KEY (voided_by) REFERENCES public.users(user_id);


--
-- Name: ec_picklist_items ec_picklist_items_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_picklist_items
    ADD CONSTRAINT ec_picklist_items_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_problems_log ec_problems_log_gift_certificate_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_problems_log
    ADD CONSTRAINT ec_problems_log_gift_certificate_id_fkey FOREIGN KEY (gift_certificate_id) REFERENCES public.ec_gift_certificates(gift_certificate_id);


--
-- Name: ec_problems_log ec_problems_log_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_problems_log
    ADD CONSTRAINT ec_problems_log_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.ec_orders(order_id);


--
-- Name: ec_problems_log ec_problems_log_resolved_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_problems_log
    ADD CONSTRAINT ec_problems_log_resolved_by_fkey FOREIGN KEY (resolved_by) REFERENCES public.users(user_id);


--
-- Name: ec_product_comments ec_product_comments_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_comments
    ADD CONSTRAINT ec_product_comments_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_product_comments ec_product_comments_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_comments
    ADD CONSTRAINT ec_product_comments_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_comments ec_product_comments_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_comments
    ADD CONSTRAINT ec_product_comments_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ec_product_links ec_product_links_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_links
    ADD CONSTRAINT ec_product_links_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_product_links ec_product_links_product_a_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_links
    ADD CONSTRAINT ec_product_links_product_a_fkey FOREIGN KEY (product_a) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_links ec_product_links_product_b_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_links
    ADD CONSTRAINT ec_product_links_product_b_fkey FOREIGN KEY (product_b) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_purchase_comb ec_product_purchase_comb_product_0_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_purchase_comb
    ADD CONSTRAINT ec_product_purchase_comb_product_0_fkey FOREIGN KEY (product_0) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_purchase_comb ec_product_purchase_comb_product_1_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_purchase_comb
    ADD CONSTRAINT ec_product_purchase_comb_product_1_fkey FOREIGN KEY (product_1) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_purchase_comb ec_product_purchase_comb_product_2_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_purchase_comb
    ADD CONSTRAINT ec_product_purchase_comb_product_2_fkey FOREIGN KEY (product_2) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_purchase_comb ec_product_purchase_comb_product_3_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_purchase_comb
    ADD CONSTRAINT ec_product_purchase_comb_product_3_fkey FOREIGN KEY (product_3) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_purchase_comb ec_product_purchase_comb_product_4_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_purchase_comb
    ADD CONSTRAINT ec_product_purchase_comb_product_4_fkey FOREIGN KEY (product_4) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_purchase_comb ec_product_purchase_comb_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_purchase_comb
    ADD CONSTRAINT ec_product_purchase_comb_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_recommendations ec_product_recommendations_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_recommendations
    ADD CONSTRAINT ec_product_recommendations_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.ec_categories(category_id);


--
-- Name: ec_product_recommendations ec_product_recommendations_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_recommendations
    ADD CONSTRAINT ec_product_recommendations_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_product_recommendations ec_product_recommendations_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_recommendations
    ADD CONSTRAINT ec_product_recommendations_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_recommendations ec_product_recommendations_subcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_recommendations
    ADD CONSTRAINT ec_product_recommendations_subcategory_id_fkey FOREIGN KEY (subcategory_id) REFERENCES public.ec_subcategories(subcategory_id);


--
-- Name: ec_product_recommendations ec_product_recommendations_subsubcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_recommendations
    ADD CONSTRAINT ec_product_recommendations_subsubcategory_id_fkey FOREIGN KEY (subsubcategory_id) REFERENCES public.ec_subsubcategories(subsubcategory_id);


--
-- Name: ec_product_recommendations ec_product_recommendations_user_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_recommendations
    ADD CONSTRAINT ec_product_recommendations_user_class_id_fkey FOREIGN KEY (user_class_id) REFERENCES public.ec_user_classes(user_class_id);


--
-- Name: ec_product_reviews ec_product_reviews_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_reviews
    ADD CONSTRAINT ec_product_reviews_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_product_reviews ec_product_reviews_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_reviews
    ADD CONSTRAINT ec_product_reviews_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_series_map ec_product_series_map_component_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_series_map
    ADD CONSTRAINT ec_product_series_map_component_id_fkey FOREIGN KEY (component_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_series_map ec_product_series_map_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_series_map
    ADD CONSTRAINT ec_product_series_map_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_product_series_map ec_product_series_map_series_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_series_map
    ADD CONSTRAINT ec_product_series_map_series_id_fkey FOREIGN KEY (series_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_user_class_prices ec_product_user_class_prices_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_user_class_prices
    ADD CONSTRAINT ec_product_user_class_prices_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_product_user_class_prices ec_product_user_class_prices_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_user_class_prices
    ADD CONSTRAINT ec_product_user_class_prices_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_product_user_class_prices ec_product_user_class_prices_user_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_product_user_class_prices
    ADD CONSTRAINT ec_product_user_class_prices_user_class_id_fkey FOREIGN KEY (user_class_id) REFERENCES public.ec_user_classes(user_class_id);


--
-- Name: ec_products ec_products_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_products
    ADD CONSTRAINT ec_products_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_products ec_products_product_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_products
    ADD CONSTRAINT ec_products_product_id_fk FOREIGN KEY (product_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: ec_products ec_products_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_products
    ADD CONSTRAINT ec_products_template_id_fkey FOREIGN KEY (template_id) REFERENCES public.ec_templates(template_id);


--
-- Name: ec_refunds ec_refunds_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_refunds
    ADD CONSTRAINT ec_refunds_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.ec_orders(order_id);


--
-- Name: ec_refunds ec_refunds_refunded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_refunds
    ADD CONSTRAINT ec_refunds_refunded_by_fkey FOREIGN KEY (refunded_by) REFERENCES public.users(user_id);


--
-- Name: ec_retailer_locations ec_retailer_locations_country_code_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailer_locations
    ADD CONSTRAINT ec_retailer_locations_country_code_fkey FOREIGN KEY (country_code) REFERENCES public.countries(iso);


--
-- Name: ec_retailer_locations ec_retailer_locations_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailer_locations
    ADD CONSTRAINT ec_retailer_locations_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_retailer_locations ec_retailer_locations_retailer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailer_locations
    ADD CONSTRAINT ec_retailer_locations_retailer_id_fkey FOREIGN KEY (retailer_id) REFERENCES public.ec_retailers(retailer_id);


--
-- Name: ec_retailer_locations ec_retailer_locations_usps_abbrev_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailer_locations
    ADD CONSTRAINT ec_retailer_locations_usps_abbrev_fkey FOREIGN KEY (usps_abbrev) REFERENCES public.us_states(abbrev);


--
-- Name: ec_retailers ec_retailers_country_code_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailers
    ADD CONSTRAINT ec_retailers_country_code_fkey FOREIGN KEY (country_code) REFERENCES public.countries(iso);


--
-- Name: ec_retailers ec_retailers_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailers
    ADD CONSTRAINT ec_retailers_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_retailers ec_retailers_usps_abbrev_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_retailers
    ADD CONSTRAINT ec_retailers_usps_abbrev_fkey FOREIGN KEY (usps_abbrev) REFERENCES public.us_states(abbrev);


--
-- Name: ec_sale_prices ec_sale_prices_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_sale_prices
    ADD CONSTRAINT ec_sale_prices_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_sale_prices ec_sale_prices_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_sale_prices
    ADD CONSTRAINT ec_sale_prices_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_sales_tax_by_state ec_sales_tax_by_state_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_sales_tax_by_state
    ADD CONSTRAINT ec_sales_tax_by_state_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_sales_tax_by_state ec_sales_tax_by_state_usps_abbrev_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_sales_tax_by_state
    ADD CONSTRAINT ec_sales_tax_by_state_usps_abbrev_fkey FOREIGN KEY (usps_abbrev) REFERENCES public.us_states(abbrev);


--
-- Name: ec_shipments ec_shipments_address_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_shipments
    ADD CONSTRAINT ec_shipments_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.ec_addresses(address_id);


--
-- Name: ec_shipments ec_shipments_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_shipments
    ADD CONSTRAINT ec_shipments_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.ec_orders(order_id);


--
-- Name: ec_spam_log ec_spam_log_mailing_list_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_spam_log
    ADD CONSTRAINT ec_spam_log_mailing_list_category_id_fkey FOREIGN KEY (mailing_list_category_id) REFERENCES public.ec_categories(category_id);


--
-- Name: ec_spam_log ec_spam_log_mailing_list_subcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_spam_log
    ADD CONSTRAINT ec_spam_log_mailing_list_subcategory_id_fkey FOREIGN KEY (mailing_list_subcategory_id) REFERENCES public.ec_subcategories(subcategory_id);


--
-- Name: ec_spam_log ec_spam_log_mailing_list_subsubcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_spam_log
    ADD CONSTRAINT ec_spam_log_mailing_list_subsubcategory_id_fkey FOREIGN KEY (mailing_list_subsubcategory_id) REFERENCES public.ec_subsubcategories(subsubcategory_id);


--
-- Name: ec_spam_log ec_spam_log_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_spam_log
    ADD CONSTRAINT ec_spam_log_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_spam_log ec_spam_log_user_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_spam_log
    ADD CONSTRAINT ec_spam_log_user_class_id_fkey FOREIGN KEY (user_class_id) REFERENCES public.ec_user_classes(user_class_id);


--
-- Name: ec_subcategories ec_subcategories_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subcategories
    ADD CONSTRAINT ec_subcategories_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.ec_categories(category_id);


--
-- Name: ec_subcategories ec_subcategories_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subcategories
    ADD CONSTRAINT ec_subcategories_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_subcategory_product_map ec_subcategory_product_map_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subcategory_product_map
    ADD CONSTRAINT ec_subcategory_product_map_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_subcategory_product_map ec_subcategory_product_map_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subcategory_product_map
    ADD CONSTRAINT ec_subcategory_product_map_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_subcategory_product_map ec_subcategory_product_map_subcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subcategory_product_map
    ADD CONSTRAINT ec_subcategory_product_map_subcategory_id_fkey FOREIGN KEY (subcategory_id) REFERENCES public.ec_subcategories(subcategory_id);


--
-- Name: ec_subsubcategories ec_subsubcategories_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subsubcategories
    ADD CONSTRAINT ec_subsubcategories_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_subsubcategories ec_subsubcategories_subcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subsubcategories
    ADD CONSTRAINT ec_subsubcategories_subcategory_id_fkey FOREIGN KEY (subcategory_id) REFERENCES public.ec_subcategories(subcategory_id);


--
-- Name: ec_subsubcategory_product_map ec_subsubcategory_product_map_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subsubcategory_product_map
    ADD CONSTRAINT ec_subsubcategory_product_map_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_subsubcategory_product_map ec_subsubcategory_product_map_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subsubcategory_product_map
    ADD CONSTRAINT ec_subsubcategory_product_map_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_subsubcategory_product_map ec_subsubcategory_product_map_subsubcategory_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_subsubcategory_product_map
    ADD CONSTRAINT ec_subsubcategory_product_map_subsubcategory_id_fkey FOREIGN KEY (subsubcategory_id) REFERENCES public.ec_subsubcategories(subsubcategory_id);


--
-- Name: ec_templates ec_templates_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_templates
    ADD CONSTRAINT ec_templates_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_user_class_user_map ec_user_class_user_map_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_class_user_map
    ADD CONSTRAINT ec_user_class_user_map_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_user_class_user_map ec_user_class_user_map_user_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_class_user_map
    ADD CONSTRAINT ec_user_class_user_map_user_class_id_fkey FOREIGN KEY (user_class_id) REFERENCES public.ec_user_classes(user_class_id);


--
-- Name: ec_user_class_user_map ec_user_class_user_map_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_class_user_map
    ADD CONSTRAINT ec_user_class_user_map_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ec_user_classes ec_user_classes_last_modifying_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_classes
    ADD CONSTRAINT ec_user_classes_last_modifying_user_fkey FOREIGN KEY (last_modifying_user) REFERENCES public.users(user_id);


--
-- Name: ec_user_identification ec_user_identification_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_identification
    ADD CONSTRAINT ec_user_identification_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ec_user_session_info ec_user_session_info_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_session_info
    ADD CONSTRAINT ec_user_session_info_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.ec_categories(category_id);


--
-- Name: ec_user_session_info ec_user_session_info_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_session_info
    ADD CONSTRAINT ec_user_session_info_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_user_session_info ec_user_session_info_user_session_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_session_info
    ADD CONSTRAINT ec_user_session_info_user_session_id_fkey FOREIGN KEY (user_session_id) REFERENCES public.ec_user_sessions(user_session_id);


--
-- Name: ec_user_session_offer_codes ec_user_session_offer_codes_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_session_offer_codes
    ADD CONSTRAINT ec_user_session_offer_codes_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id);


--
-- Name: ec_user_session_offer_codes ec_user_session_offer_codes_user_session_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_session_offer_codes
    ADD CONSTRAINT ec_user_session_offer_codes_user_session_id_fkey FOREIGN KEY (user_session_id) REFERENCES public.ec_user_sessions(user_session_id);


--
-- Name: ec_user_sessions ec_user_sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ec_user_sessions
    ADD CONSTRAINT ec_user_sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: ee_bookings ee_bookings_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_bookings
    ADD CONSTRAINT ee_bookings_id_fk FOREIGN KEY (booking_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: ee_bookings ee_bookings_product_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_bookings
    ADD CONSTRAINT ee_bookings_product_id_fk FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id) ON DELETE CASCADE;


--
-- Name: ee_item_offers ee_i_o_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_offers
    ADD CONSTRAINT ee_i_o_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: ee_item_offers ee_i_o_photo_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_offers
    ADD CONSTRAINT ee_i_o_photo_id_fk FOREIGN KEY (photo_id) REFERENCES public.pa_photos(pa_photo_id) ON DELETE CASCADE;


--
-- Name: ee_item_policies ee_i_p_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_policies
    ADD CONSTRAINT ee_i_p_category_id_fk FOREIGN KEY (category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: ee_item_policies ee_i_p_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_policies
    ADD CONSTRAINT ee_i_p_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: ee_item_sales ee_i_s_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_sales
    ADD CONSTRAINT ee_i_s_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: ee_item_sales ee_i_s_photo_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_item_sales
    ADD CONSTRAINT ee_i_s_photo_id_fk FOREIGN KEY (photo_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: ee_items ee_items_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_items
    ADD CONSTRAINT ee_items_fk FOREIGN KEY (ee_item_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: ee_leads ee_leads_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_leads
    ADD CONSTRAINT ee_leads_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: ee_leads ee_leads_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_leads
    ADD CONSTRAINT ee_leads_user_id_fk FOREIGN KEY (creation_user) REFERENCES public.users(user_id);


--
-- Name: ee_object_category_map ee_o_c_map_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_object_category_map
    ADD CONSTRAINT ee_o_c_map_category_id_fk FOREIGN KEY (category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: ee_object_category_map ee_p_c_map_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_object_category_map
    ADD CONSTRAINT ee_p_c_map_category_id_fk FOREIGN KEY (category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: ee_proposals ee_proposals_event_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_proposals
    ADD CONSTRAINT ee_proposals_event_id_fk FOREIGN KEY (event_id) REFERENCES public.acs_events(event_id) ON DELETE CASCADE;


--
-- Name: ee_proposals ee_proposals_product_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_proposals
    ADD CONSTRAINT ee_proposals_product_id_fk FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id) ON DELETE CASCADE;


--
-- Name: ee_proposals ee_proposals_proposal_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_proposals
    ADD CONSTRAINT ee_proposals_proposal_id_fk FOREIGN KEY (proposal_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: ee_qa_item_category_score ee_qa_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_qa_item_category_score
    ADD CONSTRAINT ee_qa_category_id_fk FOREIGN KEY (category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: ee_qa_item_info ee_qa_ii_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_qa_item_info
    ADD CONSTRAINT ee_qa_ii_category_id_fk FOREIGN KEY (category_id) REFERENCES public.categories(category_id) ON DELETE CASCADE;


--
-- Name: ee_qa_item_info ee_qa_ii_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_qa_item_info
    ADD CONSTRAINT ee_qa_ii_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: ee_qa_item_category_score ee_qa_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_qa_item_category_score
    ADD CONSTRAINT ee_qa_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: ee_rooms ee_rooms_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_rooms
    ADD CONSTRAINT ee_rooms_id_fk FOREIGN KEY (room_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: ee_services ee_services_contract_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_services
    ADD CONSTRAINT ee_services_contract_user_fk FOREIGN KEY (contract_user) REFERENCES public.users(user_id);


--
-- Name: ee_services ee_services_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_services
    ADD CONSTRAINT ee_services_id_fk FOREIGN KEY (service_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: ee_venues ee_venues_contract_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_venues
    ADD CONSTRAINT ee_venues_contract_user_fk FOREIGN KEY (contract_user) REFERENCES public.users(user_id);


--
-- Name: ee_venues ee_venues_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_venues
    ADD CONSTRAINT ee_venues_id_fk FOREIGN KEY (venue_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: ee_wish_list_items ee_wli_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_wish_list_items
    ADD CONSTRAINT ee_wli_item_id_fk FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: ee_wish_list_items ee_wli_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ee_wish_list_items
    ADD CONSTRAINT ee_wli_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: email_images email_images_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.email_images
    ADD CONSTRAINT email_images_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: faq_q_and_as faq_q_and_as_entry_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.faq_q_and_as
    ADD CONSTRAINT faq_q_and_as_entry_id_fk FOREIGN KEY (entry_id) REFERENCES public.acs_objects(object_id);


--
-- Name: faq_q_and_as faq_q_and_as_faq_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.faq_q_and_as
    ADD CONSTRAINT faq_q_and_as_faq_id_fkey FOREIGN KEY (faq_id) REFERENCES public.faqs(faq_id);


--
-- Name: faqs faqs_faq_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.faqs
    ADD CONSTRAINT faqs_faq_id_fk FOREIGN KEY (faq_id) REFERENCES public.acs_objects(object_id);


--
-- Name: file_storage_object_t file_storage_object_t_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.file_storage_object_t
    ADD CONSTRAINT file_storage_object_t_fk FOREIGN KEY (file_storage_object_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: im_dynfield_attr_multi_value flex_attr_multi_val_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_attr_multi_value
    ADD CONSTRAINT flex_attr_multi_val_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES public.im_dynfield_attributes(attribute_id);


--
-- Name: im_dynfield_attr_multi_value flex_attr_multi_val_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_attr_multi_value
    ADD CONSTRAINT flex_attr_multi_val_obj_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: fs_root_folders fs_root_folder_folder_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.fs_root_folders
    ADD CONSTRAINT fs_root_folder_folder_id_fk FOREIGN KEY (folder_id) REFERENCES public.cr_folders(folder_id) ON DELETE CASCADE;


--
-- Name: fs_root_folders fs_root_folder_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.fs_root_folders
    ADD CONSTRAINT fs_root_folder_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: fs_rss_subscrs fs_rss_subscrs_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.fs_rss_subscrs
    ADD CONSTRAINT fs_rss_subscrs_fk FOREIGN KEY (subscr_id) REFERENCES public.rss_gen_subscrs(subscr_id) ON DELETE CASCADE;


--
-- Name: fs_rss_subscrs fs_rss_subscrs_fldr_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.fs_rss_subscrs
    ADD CONSTRAINT fs_rss_subscrs_fldr_fk FOREIGN KEY (folder_id) REFERENCES public.cr_folders(folder_id);


--
-- Name: general_comments general_comments_comment_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.general_comments
    ADD CONSTRAINT general_comments_comment_id_fk FOREIGN KEY (comment_id) REFERENCES public.acs_messages(message_id) ON DELETE CASCADE;


--
-- Name: general_comments general_comments_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.general_comments
    ADD CONSTRAINT general_comments_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: general_objects general_objects_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.general_objects
    ADD CONSTRAINT general_objects_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: group_element_index group_elem_index_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_element_index
    ADD CONSTRAINT group_elem_index_rel_type_fk FOREIGN KEY (rel_type) REFERENCES public.acs_rel_types(rel_type) ON DELETE CASCADE;


--
-- Name: group_element_index group_element_index_cont_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_element_index
    ADD CONSTRAINT group_element_index_cont_id_fk FOREIGN KEY (container_id) REFERENCES public.groups(group_id) ON DELETE CASCADE;


--
-- Name: group_element_index group_element_index_elem_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_element_index
    ADD CONSTRAINT group_element_index_elem_id_fk FOREIGN KEY (element_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: group_element_index group_element_index_grp_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_element_index
    ADD CONSTRAINT group_element_index_grp_id_fk FOREIGN KEY (group_id) REFERENCES public.groups(group_id) ON DELETE CASCADE;


--
-- Name: group_element_index group_element_index_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_element_index
    ADD CONSTRAINT group_element_index_rel_id_fk FOREIGN KEY (rel_id) REFERENCES public.acs_rels(rel_id) ON DELETE CASCADE;


--
-- Name: group_rels group_rels_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_rels
    ADD CONSTRAINT group_rels_group_id_fk FOREIGN KEY (group_id) REFERENCES public.groups(group_id) ON DELETE CASCADE;


--
-- Name: group_rels group_rels_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_rels
    ADD CONSTRAINT group_rels_rel_type_fk FOREIGN KEY (rel_type) REFERENCES public.acs_rel_types(rel_type) ON DELETE CASCADE;


--
-- Name: group_type_rels group_type_rels_group_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_type_rels
    ADD CONSTRAINT group_type_rels_group_type_fk FOREIGN KEY (group_type) REFERENCES public.acs_object_types(object_type) ON DELETE CASCADE;


--
-- Name: group_type_rels group_type_rels_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_type_rels
    ADD CONSTRAINT group_type_rels_rel_type_fk FOREIGN KEY (rel_type) REFERENCES public.acs_rel_types(rel_type) ON DELETE CASCADE;


--
-- Name: group_types group_types_group_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.group_types
    ADD CONSTRAINT group_types_group_type_fk FOREIGN KEY (group_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: groups groups_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.groups
    ADD CONSTRAINT groups_group_id_fk FOREIGN KEY (group_id) REFERENCES public.parties(party_id);


--
-- Name: host_node_map host_node_map_node_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.host_node_map
    ADD CONSTRAINT host_node_map_node_id_fk FOREIGN KEY (node_id) REFERENCES public.site_nodes(node_id);


--
-- Name: im_offices if_address_country_code_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_offices
    ADD CONSTRAINT if_address_country_code_fk FOREIGN KEY (address_country_code) REFERENCES public.country_codes(iso);


--
-- Name: im_biz_object_groups im_biz_object_groups_biz_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_groups
    ADD CONSTRAINT im_biz_object_groups_biz_object_fk FOREIGN KEY (biz_object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_biz_object_groups im_biz_object_groups_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_groups
    ADD CONSTRAINT im_biz_object_groups_id_fk FOREIGN KEY (group_id) REFERENCES public.groups(group_id);


--
-- Name: im_biz_objects im_biz_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_objects
    ADD CONSTRAINT im_biz_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_biz_objects im_biz_object_lock_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_objects
    ADD CONSTRAINT im_biz_object_lock_user_fk FOREIGN KEY (lock_user) REFERENCES public.persons(person_id);


--
-- Name: im_biz_object_members im_biz_object_members_rel_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_members
    ADD CONSTRAINT im_biz_object_members_rel_fk FOREIGN KEY (rel_id) REFERENCES public.acs_rels(rel_id);


--
-- Name: im_biz_object_members im_biz_object_members_role_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_members
    ADD CONSTRAINT im_biz_object_members_role_fk FOREIGN KEY (object_role_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_biz_object_members im_biz_object_members_skill_profile_rel_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_members
    ADD CONSTRAINT im_biz_object_members_skill_profile_rel_fk FOREIGN KEY (skill_profile_rel_id) REFERENCES public.im_biz_object_members(rel_id);


--
-- Name: im_biz_object_tree_status im_biz_object_tree_status_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_tree_status
    ADD CONSTRAINT im_biz_object_tree_status_object_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: im_biz_object_tree_status im_biz_object_tree_status_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_tree_status
    ADD CONSTRAINT im_biz_object_tree_status_user_fk FOREIGN KEY (user_id) REFERENCES public.persons(person_id) ON DELETE CASCADE;


--
-- Name: im_biz_object_role_map im_bizo_rmap_object_role_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_role_map
    ADD CONSTRAINT im_bizo_rmap_object_role_fk FOREIGN KEY (object_role_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_biz_object_role_map im_bizo_rmap_object_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_biz_object_role_map
    ADD CONSTRAINT im_bizo_rmap_object_type_fk FOREIGN KEY (object_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_category_hierarchy im_child_category_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_category_hierarchy
    ADD CONSTRAINT im_child_category_fk FOREIGN KEY (child_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_component_plugin_user_map im_comp_plugin_user_map_plugin_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_component_plugin_user_map
    ADD CONSTRAINT im_comp_plugin_user_map_plugin_fk FOREIGN KEY (plugin_id) REFERENCES public.im_component_plugins(plugin_id);


--
-- Name: im_component_plugin_user_map im_comp_plugin_user_map_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_component_plugin_user_map
    ADD CONSTRAINT im_comp_plugin_user_map_user_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: im_companies im_companies_acc_cont_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_acc_cont_fk FOREIGN KEY (accounting_contact_id) REFERENCES public.users(user_id);


--
-- Name: im_companies im_companies_ann_rev_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_ann_rev_fk FOREIGN KEY (annual_revenue_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_crm_status_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_crm_status_fk FOREIGN KEY (crm_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_cust_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_cust_id_fk FOREIGN KEY (company_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_companies im_companies_cust_stat_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_cust_stat_fk FOREIGN KEY (company_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_cust_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_cust_type_fk FOREIGN KEY (company_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_def_bill_template_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_def_bill_template_fk FOREIGN KEY (default_bill_template_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_def_delnote_template_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_def_delnote_template_fk FOREIGN KEY (default_delnote_template_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_def_invoice_payment_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_def_invoice_payment_fk FOREIGN KEY (default_payment_method_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_def_invoice_template_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_def_invoice_template_fk FOREIGN KEY (default_invoice_template_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_def_po_template_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_def_po_template_fk FOREIGN KEY (default_po_template_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_def_quote_template_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_def_quote_template_fk FOREIGN KEY (default_quote_template_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_manager_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_manager_fk FOREIGN KEY (manager_id) REFERENCES public.users(user_id);


--
-- Name: im_companies im_companies_office_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_office_fk FOREIGN KEY (main_office_id) REFERENCES public.im_offices(office_id);


--
-- Name: im_companies im_companies_old_cust_stat_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_old_cust_stat_fk FOREIGN KEY (old_company_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_companies im_companies_prim_cont_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_companies
    ADD CONSTRAINT im_companies_prim_cont_fk FOREIGN KEY (primary_contact_id) REFERENCES public.users(user_id);


--
-- Name: im_company_employee_rels im_company_employee_rels_employee_rel_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_company_employee_rels
    ADD CONSTRAINT im_company_employee_rels_employee_rel_id_fkey FOREIGN KEY (employee_rel_id) REFERENCES public.acs_rels(rel_id) ON DELETE CASCADE;


--
-- Name: im_component_plugins im_component_plugin_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_component_plugins
    ADD CONSTRAINT im_component_plugin_id_fk FOREIGN KEY (plugin_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_dynfield_attributes im_dynfield_attr_attr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_attributes
    ADD CONSTRAINT im_dynfield_attr_attr_id_fk FOREIGN KEY (attribute_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_dynfield_attributes im_dynfield_attr_attribute_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_attributes
    ADD CONSTRAINT im_dynfield_attr_attribute_id_fk FOREIGN KEY (acs_attribute_id) REFERENCES public.acs_attributes(attribute_id);


--
-- Name: im_dynfield_attributes im_dynfield_attr_widget_name_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_attributes
    ADD CONSTRAINT im_dynfield_attr_widget_name_fk FOREIGN KEY (widget_name) REFERENCES public.im_dynfield_widgets(widget_name);


--
-- Name: im_dynfield_page_fields im_dynfield_fields_status_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_page_fields
    ADD CONSTRAINT im_dynfield_fields_status_fk FOREIGN KEY (field_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_dynfield_page_fields im_dynfield_fields_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_page_fields
    ADD CONSTRAINT im_dynfield_fields_type_fk FOREIGN KEY (field_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_dynfield_layout im_dynfield_layout_attribute_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_layout
    ADD CONSTRAINT im_dynfield_layout_attribute_fk FOREIGN KEY (attribute_id) REFERENCES public.im_dynfield_attributes(attribute_id);


--
-- Name: im_dynfield_layout_pages im_dynfield_ly_page_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_layout_pages
    ADD CONSTRAINT im_dynfield_ly_page_object_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: im_dynfield_pages im_dynfield_ly_page_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_pages
    ADD CONSTRAINT im_dynfield_ly_page_object_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type);


--
-- Name: im_dynfield_page_fields im_dynfield_page_attributes_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_page_fields
    ADD CONSTRAINT im_dynfield_page_attributes_fk FOREIGN KEY (attribute_id) REFERENCES public.im_dynfield_attributes(attribute_id);


--
-- Name: im_dynfield_page_fields im_dynfield_page_attributes_page_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_page_fields
    ADD CONSTRAINT im_dynfield_page_attributes_page_fk FOREIGN KEY (page_id) REFERENCES public.im_dynfield_pages(page_id);


--
-- Name: im_dynfield_pages im_dynfield_pages_status_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_pages
    ADD CONSTRAINT im_dynfield_pages_status_fk FOREIGN KEY (page_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_dynfield_pages im_dynfield_pages_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_pages
    ADD CONSTRAINT im_dynfield_pages_type_fk FOREIGN KEY (page_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_dynfield_type_attribute_map im_dynfield_type_attr_map_attr_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_type_attribute_map
    ADD CONSTRAINT im_dynfield_type_attr_map_attr_fk FOREIGN KEY (attribute_id) REFERENCES public.im_dynfield_attributes(attribute_id) ON DELETE CASCADE;


--
-- Name: im_dynfield_type_attribute_map im_dynfield_type_attr_map_otype_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_type_attribute_map
    ADD CONSTRAINT im_dynfield_type_attr_map_otype_fk FOREIGN KEY (object_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_dynfield_widgets im_dynfield_widgets_acs_typ_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_widgets
    ADD CONSTRAINT im_dynfield_widgets_acs_typ_fk FOREIGN KEY (acs_datatype) REFERENCES public.acs_datatypes(datatype);


--
-- Name: im_dynfield_widgets im_dynfield_widgets_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_dynfield_widgets
    ADD CONSTRAINT im_dynfield_widgets_fk FOREIGN KEY (widget_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_key_account_rels im_key_account_rels_key_account_rel_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_key_account_rels
    ADD CONSTRAINT im_key_account_rels_key_account_rel_id_fkey FOREIGN KEY (key_account_rel_id) REFERENCES public.acs_rels(rel_id) ON DELETE CASCADE;


--
-- Name: im_menus im_menu_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_menus
    ADD CONSTRAINT im_menu_id_fk FOREIGN KEY (menu_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_offices im_offices_cont_per_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_offices
    ADD CONSTRAINT im_offices_cont_per_fk FOREIGN KEY (contact_person_id) REFERENCES public.users(user_id);


--
-- Name: im_offices im_offices_cust_stat_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_offices
    ADD CONSTRAINT im_offices_cust_stat_fk FOREIGN KEY (office_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_offices im_offices_cust_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_offices
    ADD CONSTRAINT im_offices_cust_type_fk FOREIGN KEY (office_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_offices im_offices_office_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_offices
    ADD CONSTRAINT im_offices_office_id_fk FOREIGN KEY (office_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_category_hierarchy im_parent_category_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_category_hierarchy
    ADD CONSTRAINT im_parent_category_fk FOREIGN KEY (parent_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_menus im_parent_menu_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_menus
    ADD CONSTRAINT im_parent_menu_id_fk FOREIGN KEY (parent_menu_id) REFERENCES public.im_menus(menu_id);


--
-- Name: im_profiles im_profiles_profile_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_profiles
    ADD CONSTRAINT im_profiles_profile_id_fk FOREIGN KEY (profile_id) REFERENCES public.groups(group_id);


--
-- Name: im_projects im_project_billing_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_project_billing_fk FOREIGN KEY (billing_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_projects im_project_company_contact_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_project_company_contact_id_fk FOREIGN KEY (company_contact_id) REFERENCES public.users(user_id);


--
-- Name: im_projects im_project_on_track_status_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_project_on_track_status_id_fk FOREIGN KEY (on_track_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_projects im_project_prj_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_project_prj_fk FOREIGN KEY (project_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_project_url_map im_project_url_map_project_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_project_url_map
    ADD CONSTRAINT im_project_url_map_project_fk FOREIGN KEY (project_id) REFERENCES public.im_projects(project_id);


--
-- Name: im_project_url_map im_project_url_map_url_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_project_url_map
    ADD CONSTRAINT im_project_url_map_url_type_fk FOREIGN KEY (url_type_id) REFERENCES public.im_url_types(url_type_id);


--
-- Name: im_projects im_projects_company_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_company_fk FOREIGN KEY (company_id) REFERENCES public.im_companies(company_id);


--
-- Name: im_projects im_projects_cost_center_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_cost_center_fk FOREIGN KEY (project_cost_center_id) REFERENCES public.acs_objects(object_id);


--
-- Name: im_projects im_projects_parent_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_parent_fk FOREIGN KEY (parent_id) REFERENCES public.im_projects(project_id);


--
-- Name: im_projects im_projects_prj_lead_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_prj_lead_fk FOREIGN KEY (project_lead_id) REFERENCES public.users(user_id);


--
-- Name: im_projects im_projects_prj_status_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_prj_status_fk FOREIGN KEY (project_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_projects im_projects_prj_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_prj_type_fk FOREIGN KEY (project_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_projects im_projects_program_id; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_program_id FOREIGN KEY (program_id) REFERENCES public.im_projects(project_id);


--
-- Name: im_projects im_projects_sponsor_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_sponsor_fk FOREIGN KEY (corporate_sponsor_id) REFERENCES public.users(user_id);


--
-- Name: im_projects im_projects_supervisor_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_projects
    ADD CONSTRAINT im_projects_supervisor_fk FOREIGN KEY (supervisor_id) REFERENCES public.users(user_id);


--
-- Name: im_view_columns im_view_columns_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_view_columns
    ADD CONSTRAINT im_view_columns_group_id_fk FOREIGN KEY (group_id) REFERENCES public.groups(group_id);


--
-- Name: im_view_columns im_view_view_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_view_columns
    ADD CONSTRAINT im_view_view_id_fk FOREIGN KEY (view_id) REFERENCES public.im_views(view_id);


--
-- Name: im_views im_views_status_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_views
    ADD CONSTRAINT im_views_status_fk FOREIGN KEY (view_status_id) REFERENCES public.im_categories(category_id);


--
-- Name: im_views im_views_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.im_views
    ADD CONSTRAINT im_views_type_fk FOREIGN KEY (view_type_id) REFERENCES public.im_categories(category_id);


--
-- Name: images images_image_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.images
    ADD CONSTRAINT images_image_id_fk FOREIGN KEY (image_id) REFERENCES public.cr_revisions(revision_id);


--
-- Name: itu_codes itu_codes_note_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.itu_codes
    ADD CONSTRAINT itu_codes_note_fk FOREIGN KEY (note_id) REFERENCES public.itu_notes(note_id);


--
-- Name: iurix_mails iurix_mails_mail_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.iurix_mails
    ADD CONSTRAINT iurix_mails_mail_id_fk FOREIGN KEY (mail_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: iurix_mails iurix_mails_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.iurix_mails
    ADD CONSTRAINT iurix_mails_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: iurix_mails iurix_mails_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.iurix_mails
    ADD CONSTRAINT iurix_mails_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: journal_entries journal_entries_journal_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.journal_entries
    ADD CONSTRAINT journal_entries_journal_id_fk FOREIGN KEY (journal_id) REFERENCES public.acs_objects(object_id);


--
-- Name: journal_entries journal_entries_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.journal_entries
    ADD CONSTRAINT journal_entries_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: lang_message_keys lang_message_keys_pkg_key_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_message_keys
    ADD CONSTRAINT lang_message_keys_pkg_key_fk FOREIGN KEY (package_key) REFERENCES public.apm_package_types(package_key) ON DELETE CASCADE;


--
-- Name: lang_messages_audit lang_messages_audit_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_messages_audit
    ADD CONSTRAINT lang_messages_audit_fk FOREIGN KEY (message_key, package_key) REFERENCES public.lang_message_keys(message_key, package_key) ON DELETE CASCADE;


--
-- Name: lang_messages_audit lang_messages_audit_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_messages_audit
    ADD CONSTRAINT lang_messages_audit_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale);


--
-- Name: lang_messages_audit lang_messages_audit_ou_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_messages_audit
    ADD CONSTRAINT lang_messages_audit_ou_fk FOREIGN KEY (overwrite_user) REFERENCES public.users(user_id);


--
-- Name: lang_messages lang_messages_creation_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_messages
    ADD CONSTRAINT lang_messages_creation_user_fk FOREIGN KEY (creation_user) REFERENCES public.users(user_id);


--
-- Name: lang_messages lang_messages_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_messages
    ADD CONSTRAINT lang_messages_fk FOREIGN KEY (message_key, package_key) REFERENCES public.lang_message_keys(message_key, package_key) ON DELETE CASCADE;


--
-- Name: lang_messages lang_messages_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_messages
    ADD CONSTRAINT lang_messages_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale);


--
-- Name: ad_locale_user_prefs lang_package_l_u_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.ad_locale_user_prefs
    ADD CONSTRAINT lang_package_l_u_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: lang_user_timezone lang_user_timezone_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_user_timezone
    ADD CONSTRAINT lang_user_timezone_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: lob_data lob_data_lob_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lob_data
    ADD CONSTRAINT lob_data_lob_id_fk FOREIGN KEY (lob_id) REFERENCES public.lobs(lob_id) ON DELETE CASCADE;


--
-- Name: lang_translation_registry ltr_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.lang_translation_registry
    ADD CONSTRAINT ltr_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale);


--
-- Name: membership_rels membership_rels_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.membership_rels
    ADD CONSTRAINT membership_rels_rel_id_fk FOREIGN KEY (rel_id) REFERENCES public.acs_rels(rel_id) ON DELETE CASCADE;


--
-- Name: notification_email_hold notif_email_hold_reply_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_email_hold
    ADD CONSTRAINT notif_email_hold_reply_id_fk FOREIGN KEY (reply_id) REFERENCES public.notification_replies(reply_id);


--
-- Name: notification_replies notif_repl_from_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_replies
    ADD CONSTRAINT notif_repl_from_fk FOREIGN KEY (from_user) REFERENCES public.users(user_id);


--
-- Name: notification_replies notif_repl_obj_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_replies
    ADD CONSTRAINT notif_repl_obj_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: notification_replies notif_repl_repl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_replies
    ADD CONSTRAINT notif_repl_repl_id_fk FOREIGN KEY (reply_id) REFERENCES public.acs_objects(object_id);


--
-- Name: notification_replies notif_repl_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_replies
    ADD CONSTRAINT notif_repl_type_id_fk FOREIGN KEY (type_id) REFERENCES public.notification_types(type_id);


--
-- Name: notification_user_map notif_user_map_notif_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_user_map
    ADD CONSTRAINT notif_user_map_notif_id_fk FOREIGN KEY (notification_id) REFERENCES public.notifications(notification_id) ON DELETE CASCADE;


--
-- Name: notification_user_map notif_user_map_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_user_map
    ADD CONSTRAINT notif_user_map_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: notification_types notification_delivery_method_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types
    ADD CONSTRAINT notification_delivery_method_impl_id_fk FOREIGN KEY (sc_impl_id) REFERENCES public.acs_sc_impls(impl_id);


--
-- Name: notification_delivery_methods notification_delivery_methods_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_delivery_methods
    ADD CONSTRAINT notification_delivery_methods_fk FOREIGN KEY (delivery_method_id) REFERENCES public.acs_objects(object_id);


--
-- Name: notification_delivery_methods notification_delivery_methods_impl_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_delivery_methods
    ADD CONSTRAINT notification_delivery_methods_impl_id_fk FOREIGN KEY (sc_impl_id) REFERENCES public.acs_sc_impls(impl_id);


--
-- Name: notification_intervals notification_intervals_interval_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_intervals
    ADD CONSTRAINT notification_intervals_interval_id_fk FOREIGN KEY (interval_id) REFERENCES public.acs_objects(object_id);


--
-- Name: notification_requests notification_requests_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_requests
    ADD CONSTRAINT notification_requests_id_fk FOREIGN KEY (request_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: notification_types notification_types_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types
    ADD CONSTRAINT notification_types_type_id_fk FOREIGN KEY (type_id) REFERENCES public.acs_objects(object_id);


--
-- Name: notifications notifications_notif_user_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_notif_user_fk FOREIGN KEY (notif_user) REFERENCES public.users(user_id);


--
-- Name: notifications notifications_notification_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_notification_id_fk FOREIGN KEY (notification_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: notifications notifications_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: notification_requests notifications_request_deliv_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_requests
    ADD CONSTRAINT notifications_request_deliv_fk FOREIGN KEY (type_id, delivery_method_id) REFERENCES public.notification_types_del_methods(type_id, delivery_method_id);


--
-- Name: notification_requests notifications_request_interv_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_requests
    ADD CONSTRAINT notifications_request_interv_fk FOREIGN KEY (type_id, interval_id) REFERENCES public.notification_types_intervals(type_id, interval_id);


--
-- Name: notification_requests notifications_request_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_requests
    ADD CONSTRAINT notifications_request_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: notification_requests notifications_request_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_requests
    ADD CONSTRAINT notifications_request_type_id_fk FOREIGN KEY (type_id) REFERENCES public.notification_types(type_id) ON DELETE CASCADE;


--
-- Name: notification_requests notifications_request_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_requests
    ADD CONSTRAINT notifications_request_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: notifications notifications_response_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_response_id_fk FOREIGN KEY (response_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: notification_types_del_methods notifications_type_del_meth_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types_del_methods
    ADD CONSTRAINT notifications_type_del_meth_id_fk FOREIGN KEY (delivery_method_id) REFERENCES public.notification_delivery_methods(delivery_method_id) ON DELETE CASCADE;


--
-- Name: notification_types_del_methods notifications_type_del_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types_del_methods
    ADD CONSTRAINT notifications_type_del_type_id_fk FOREIGN KEY (type_id) REFERENCES public.notification_types(type_id) ON DELETE CASCADE;


--
-- Name: notifications notifications_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_type_id_fk FOREIGN KEY (type_id) REFERENCES public.notification_types(type_id);


--
-- Name: notification_types_intervals notifications_type_int_int_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types_intervals
    ADD CONSTRAINT notifications_type_int_int_id_fk FOREIGN KEY (interval_id) REFERENCES public.notification_intervals(interval_id) ON DELETE CASCADE;


--
-- Name: notification_types_intervals notifications_type_int_type_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.notification_types_intervals
    ADD CONSTRAINT notifications_type_int_type_id_fk FOREIGN KEY (type_id) REFERENCES public.notification_types(type_id) ON DELETE CASCADE;


--
-- Name: organization_type_map org_type_map_org_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.organization_type_map
    ADD CONSTRAINT org_type_map_org_id_fk FOREIGN KEY (organization_id) REFERENCES public.organizations(organization_id);


--
-- Name: organization_type_map org_type_map_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.organization_type_map
    ADD CONSTRAINT org_type_map_type_fk FOREIGN KEY (organization_type_id) REFERENCES public.organization_types(organization_type_id);


--
-- Name: organizations organization_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT organization_id_fk FOREIGN KEY (organization_id) REFERENCES public.parties(party_id);


--
-- Name: pa_albums pa_albums_iconic_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_albums
    ADD CONSTRAINT pa_albums_iconic_fk FOREIGN KEY (iconic) REFERENCES public.cr_items(item_id) ON DELETE SET NULL;


--
-- Name: pa_albums pa_albums_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_albums
    ADD CONSTRAINT pa_albums_id_fk FOREIGN KEY (pa_album_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: pa_collections pa_collection_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_collections
    ADD CONSTRAINT pa_collection_id_fk FOREIGN KEY (collection_id) REFERENCES public.acs_objects(object_id);


--
-- Name: pa_collection_photo_map pa_collections_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_collection_photo_map
    ADD CONSTRAINT pa_collections_fk FOREIGN KEY (collection_id) REFERENCES public.pa_collections(collection_id) ON DELETE CASCADE;


--
-- Name: pa_collections pa_collections_owner_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_collections
    ADD CONSTRAINT pa_collections_owner_id_fk FOREIGN KEY (owner_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: pa_package_root_folder_map pa_pack_fldr_map_fldr_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_package_root_folder_map
    ADD CONSTRAINT pa_pack_fldr_map_fldr_id_fk FOREIGN KEY (folder_id) REFERENCES public.cr_folders(folder_id) ON DELETE CASCADE;


--
-- Name: pa_package_root_folder_map pa_pack_fldr_map_pack_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_package_root_folder_map
    ADD CONSTRAINT pa_pack_fldr_map_pack_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: pa_collection_photo_map pa_photos_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_collection_photo_map
    ADD CONSTRAINT pa_photos_fk FOREIGN KEY (photo_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: pa_photos pa_photos_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pa_photos
    ADD CONSTRAINT pa_photos_id_fk FOREIGN KEY (pa_photo_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: parties parties_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.parties
    ADD CONSTRAINT parties_party_id_fk FOREIGN KEY (party_id) REFERENCES public.acs_objects(object_id);


--
-- Name: party_approved_member_map party_member_member_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.party_approved_member_map
    ADD CONSTRAINT party_member_member_fk FOREIGN KEY (member_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: party_approved_member_map party_member_party_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.party_approved_member_map
    ADD CONSTRAINT party_member_party_fk FOREIGN KEY (party_id) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: party_approved_member_map party_member_rel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.party_approved_member_map
    ADD CONSTRAINT party_member_rel_id_fk FOREIGN KEY (originating_rel_id) REFERENCES public.acs_rels(rel_id) ON DELETE CASCADE;


--
-- Name: persons persons_person_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.persons
    ADD CONSTRAINT persons_person_id_fk FOREIGN KEY (person_id) REFERENCES public.parties(party_id);


--
-- Name: pinds_blog_categories pinds_blog_category_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pinds_blog_categories
    ADD CONSTRAINT pinds_blog_category_id_fk FOREIGN KEY (category_id) REFERENCES public.acs_objects(object_id);


--
-- Name: pinds_blog_entries pinds_blog_entry_category_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pinds_blog_entries
    ADD CONSTRAINT pinds_blog_entry_category_fk FOREIGN KEY (category_id) REFERENCES public.pinds_blog_categories(category_id);


--
-- Name: pinds_blog_entries pinds_blog_entry_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pinds_blog_entries
    ADD CONSTRAINT pinds_blog_entry_id_fk FOREIGN KEY (entry_id) REFERENCES public.acs_objects(object_id);


--
-- Name: pinds_blog_categories pinds_blog_entry_package_id_kf; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pinds_blog_categories
    ADD CONSTRAINT pinds_blog_entry_package_id_kf FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id);


--
-- Name: pinds_blog_entries pinds_blog_entry_package_id_kf; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pinds_blog_entries
    ADD CONSTRAINT pinds_blog_entry_package_id_kf FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id);


--
-- Name: pm pm_pm_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm
    ADD CONSTRAINT pm_pm_id_fk FOREIGN KEY (pm_id) REFERENCES public.acs_messages(message_id) ON DELETE CASCADE;


--
-- Name: pm_queue pm_queue_sender_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_queue
    ADD CONSTRAINT pm_queue_sender_user_id_fkey FOREIGN KEY (sender_user_id) REFERENCES public.users(user_id);


--
-- Name: pm_queue pm_queue_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_queue
    ADD CONSTRAINT pm_queue_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: pm_sent pm_sent_pm_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_sent
    ADD CONSTRAINT pm_sent_pm_id_fk FOREIGN KEY (pm_id) REFERENCES public.acs_messages(message_id) ON DELETE CASCADE;


--
-- Name: pm_preference pm_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_preference
    ADD CONSTRAINT pm_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: pm_aggregate pm_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.pm_aggregate
    ADD CONSTRAINT pm_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: postal_addresses postal_address_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.postal_addresses
    ADD CONSTRAINT postal_address_id_fk FOREIGN KEY (address_id) REFERENCES public.acs_objects(object_id);


--
-- Name: postal_addresses postal_addresses_country_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.postal_addresses
    ADD CONSTRAINT postal_addresses_country_fk FOREIGN KEY (country_code) REFERENCES public.countries(iso);


--
-- Name: postal_addresses postal_addresses_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.postal_addresses
    ADD CONSTRAINT postal_addresses_type_fk FOREIGN KEY (postal_type) REFERENCES public.postal_types(type_id);


--
-- Name: postal_addresses postal_owner_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.postal_addresses
    ADD CONSTRAINT postal_owner_id_fk FOREIGN KEY (party_id) REFERENCES public.parties(party_id);


--
-- Name: rel_constraints rc_constraint_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_constraints
    ADD CONSTRAINT rc_constraint_id_fk FOREIGN KEY (constraint_id) REFERENCES public.acs_objects(object_id);


--
-- Name: rc_segment_required_seg_map rc_rel_segment_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rc_segment_required_seg_map
    ADD CONSTRAINT rc_rel_segment_fk FOREIGN KEY (rel_segment) REFERENCES public.rel_segments(segment_id);


--
-- Name: rel_constraints rc_required_rel_segment_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_constraints
    ADD CONSTRAINT rc_required_rel_segment_fk FOREIGN KEY (required_rel_segment) REFERENCES public.rel_segments(segment_id);


--
-- Name: rc_segment_required_seg_map rc_required_rel_segment_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rc_segment_required_seg_map
    ADD CONSTRAINT rc_required_rel_segment_fk FOREIGN KEY (required_rel_segment) REFERENCES public.rel_segments(segment_id);


--
-- Name: recurrences recurs_interval_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.recurrences
    ADD CONSTRAINT recurs_interval_type_fk FOREIGN KEY (interval_type) REFERENCES public.recurrence_interval_types(interval_type);


--
-- Name: rel_constraints rel_constraints_rel_segment_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_constraints
    ADD CONSTRAINT rel_constraints_rel_segment_fk FOREIGN KEY (rel_segment) REFERENCES public.rel_segments(segment_id);


--
-- Name: rel_segments rel_segments_group_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_segments
    ADD CONSTRAINT rel_segments_group_id_fk FOREIGN KEY (group_id) REFERENCES public.groups(group_id) ON DELETE CASCADE;


--
-- Name: rel_segments rel_segments_rel_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_segments
    ADD CONSTRAINT rel_segments_rel_type_fk FOREIGN KEY (rel_type) REFERENCES public.acs_rel_types(rel_type) ON DELETE CASCADE;


--
-- Name: rel_segments rel_segments_segment_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rel_segments
    ADD CONSTRAINT rel_segments_segment_id_fk FOREIGN KEY (segment_id) REFERENCES public.parties(party_id);


--
-- Name: rss_gen_subscrs rss_gen_subscrs_ctx_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_ctx_fk FOREIGN KEY (summary_context_id) REFERENCES public.acs_objects(object_id);


--
-- Name: rss_gen_subscrs rss_gen_subscrs_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_id_fk FOREIGN KEY (subscr_id) REFERENCES public.acs_objects(object_id);


--
-- Name: rss_gen_subscrs rss_gen_subscrs_impl_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.rss_gen_subscrs
    ADD CONSTRAINT rss_gen_subscrs_impl_fk FOREIGN KEY (impl_id) REFERENCES public.acs_sc_impls(impl_id);


--
-- Name: search_observer_queue search_observer_queue_object_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.search_observer_queue
    ADD CONSTRAINT search_observer_queue_object_id_fkey FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: subsite_callbacks sgc_object_type_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.subsite_callbacks
    ADD CONSTRAINT sgc_object_type_fk FOREIGN KEY (object_type) REFERENCES public.acs_object_types(object_type) ON DELETE CASCADE;


--
-- Name: site_nodes site_nodes_node_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_nodes
    ADD CONSTRAINT site_nodes_node_id_fk FOREIGN KEY (node_id) REFERENCES public.acs_objects(object_id);


--
-- Name: site_nodes site_nodes_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_nodes
    ADD CONSTRAINT site_nodes_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id);


--
-- Name: site_nodes site_nodes_parent_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_nodes
    ADD CONSTRAINT site_nodes_parent_id_fk FOREIGN KEY (parent_id) REFERENCES public.site_nodes(node_id);


--
-- Name: site_nodes_selection site_nodes_sel_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_nodes_selection
    ADD CONSTRAINT site_nodes_sel_id_fk FOREIGN KEY (node_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: site_node_object_mappings snom_node_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_node_object_mappings
    ADD CONSTRAINT snom_node_id_fk FOREIGN KEY (node_id) REFERENCES public.site_nodes(node_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: site_node_object_mappings snom_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.site_node_object_mappings
    ADD CONSTRAINT snom_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: syndication syndication_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.syndication
    ADD CONSTRAINT syndication_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: tags_tags tags_tags_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.tags_tags
    ADD CONSTRAINT tags_tags_item_id_fkey FOREIGN KEY (item_id) REFERENCES public.acs_objects(object_id);


--
-- Name: tags_tags tags_tags_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.tags_tags
    ADD CONSTRAINT tags_tags_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: trackback_pings tb_pings_comment_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.trackback_pings
    ADD CONSTRAINT tb_pings_comment_id_fk FOREIGN KEY (comment_id) REFERENCES public.general_comments(comment_id);


--
-- Name: telecom_numbers telecom_number_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.telecom_numbers
    ADD CONSTRAINT telecom_number_id_fk FOREIGN KEY (number_id) REFERENCES public.acs_objects(object_id);


--
-- Name: telecom_numbers telecom_number_itu_code_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.telecom_numbers
    ADD CONSTRAINT telecom_number_itu_code_fk FOREIGN KEY (itu_id) REFERENCES public.itu_codes(itu_id);


--
-- Name: telecom_numbers telecom_numbers_phontyp_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.telecom_numbers
    ADD CONSTRAINT telecom_numbers_phontyp_id_fk FOREIGN KEY (phone_type_id) REFERENCES public.phone_types(phone_type_id);


--
-- Name: telecom_numbers telecom_party_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.telecom_numbers
    ADD CONSTRAINT telecom_party_id_fk FOREIGN KEY (party_id) REFERENCES public.parties(party_id);


--
-- Name: template_demo_notes template_demo_notes_note_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.template_demo_notes
    ADD CONSTRAINT template_demo_notes_note_id_fk FOREIGN KEY (template_demo_note_id) REFERENCES public.acs_objects(object_id);


--
-- Name: timezone_rules timezone_rules_tz_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.timezone_rules
    ADD CONSTRAINT timezone_rules_tz_id_fk FOREIGN KEY (tz_id) REFERENCES public.timezones(tz_id) ON DELETE CASCADE;


--
-- Name: timespans tm_ntrvl_sts_interval_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.timespans
    ADD CONSTRAINT tm_ntrvl_sts_interval_id_fk FOREIGN KEY (interval_id) REFERENCES public.time_intervals(interval_id) ON DELETE CASCADE;


--
-- Name: txt txt_object_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.txt
    ADD CONSTRAINT txt_object_id_fk FOREIGN KEY (object_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: user_ext_info uei_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_ext_info
    ADD CONSTRAINT uei_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: user_payments up_product_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_payments
    ADD CONSTRAINT up_product_id_fk FOREIGN KEY (product_id) REFERENCES public.ec_products(product_id) ON DELETE CASCADE;


--
-- Name: user_payments up_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_payments
    ADD CONSTRAINT up_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id) ON DELETE CASCADE;


--
-- Name: us_counties us_counties_fips_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.us_counties
    ADD CONSTRAINT us_counties_fips_fk FOREIGN KEY (fips_state_code) REFERENCES public.us_states(fips_state_code);


--
-- Name: us_counties us_counties_state_abrrev_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.us_counties
    ADD CONSTRAINT us_counties_state_abrrev_fk FOREIGN KEY (state_abbrev) REFERENCES public.us_states(abbrev);


--
-- Name: us_zipcodes us_zipcodes_fips_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.us_zipcodes
    ADD CONSTRAINT us_zipcodes_fips_fk FOREIGN KEY (fips_state_code) REFERENCES public.us_states(fips_state_code);


--
-- Name: user_portraits user_portraits_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_portraits
    ADD CONSTRAINT user_portraits_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: user_preferences user_preferences_locale_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT user_preferences_locale_fk FOREIGN KEY (locale) REFERENCES public.ad_locales(locale);


--
-- Name: user_preferences user_preferences_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT user_preferences_user_id_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: users users_authority_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_authority_id_fk FOREIGN KEY (authority_id) REFERENCES public.auth_authorities(authority_id);


--
-- Name: users_contact users_contact_ha_cc_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users_contact
    ADD CONSTRAINT users_contact_ha_cc_fk FOREIGN KEY (ha_country_code) REFERENCES public.country_codes(iso);


--
-- Name: users_contact users_contact_pk_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users_contact
    ADD CONSTRAINT users_contact_pk_fk FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: users_contact users_contact_wa_cc_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users_contact
    ADD CONSTRAINT users_contact_wa_cc_fk FOREIGN KEY (wa_country_code) REFERENCES public.country_codes(iso);


--
-- Name: users_email_image users_email_image_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users_email_image
    ADD CONSTRAINT users_email_image_fk FOREIGN KEY (email_image_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: users users_user_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_user_id_fk FOREIGN KEY (user_id) REFERENCES public.persons(person_id);


--
-- Name: weblogger_blogroll_entries weblogger_blogroll_entries_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_blogroll_entries
    ADD CONSTRAINT weblogger_blogroll_entries_id_fk FOREIGN KEY (link_id) REFERENCES public.acs_objects(object_id);


--
-- Name: weblogger_blogroll_entries weblogger_blogroll_entries_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_blogroll_entries
    ADD CONSTRAINT weblogger_blogroll_entries_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id);


--
-- Name: weblogger_channels weblogger_channels_package_id_kf; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_channels
    ADD CONSTRAINT weblogger_channels_package_id_kf FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id);


--
-- Name: weblogger_ping_urls weblogger_ping_urls_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_ping_urls
    ADD CONSTRAINT weblogger_ping_urls_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: weblogger_technorati_cache weblogger_ping_urls_package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.weblogger_technorati_cache
    ADD CONSTRAINT weblogger_ping_urls_package_id_fk FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: xowf_package xowf_package_package_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowf_package
    ADD CONSTRAINT xowf_package_package_id_fkey FOREIGN KEY (package_id) REFERENCES public.xowiki_package(package_id) ON DELETE CASCADE;


--
-- Name: xowiki_autonames xowiki_autonames_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_autonames
    ADD CONSTRAINT xowiki_autonames_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.acs_objects(object_id) ON DELETE CASCADE;


--
-- Name: xowiki_file xowiki_file_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_file
    ADD CONSTRAINT xowiki_file_fk FOREIGN KEY (file_id) REFERENCES public.xowiki_page(page_id) ON DELETE CASCADE;


--
-- Name: xowiki_form xowiki_form_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form
    ADD CONSTRAINT xowiki_form_fk FOREIGN KEY (xowiki_form_id) REFERENCES public.xowiki_page_template(page_template_id) ON DELETE CASCADE;


--
-- Name: xowiki_form_instance_item_index xowiki_form_instance_item_index_assignee_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form_instance_item_index
    ADD CONSTRAINT xowiki_form_instance_item_index_assignee_fkey FOREIGN KEY (assignee) REFERENCES public.parties(party_id) ON DELETE CASCADE;


--
-- Name: xowiki_form_instance_item_index xowiki_form_instance_item_index_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form_instance_item_index
    ADD CONSTRAINT xowiki_form_instance_item_index_item_id_fkey FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: xowiki_form_instance_item_index xowiki_form_instance_item_index_page_template_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form_instance_item_index
    ADD CONSTRAINT xowiki_form_instance_item_index_page_template_fkey FOREIGN KEY (page_template) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: xowiki_form_instance_item_index xowiki_form_instance_item_index_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form_instance_item_index
    ADD CONSTRAINT xowiki_form_instance_item_index_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: xowiki_form_page xowiki_form_page_assignee_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form_page
    ADD CONSTRAINT xowiki_form_page_assignee_fkey FOREIGN KEY (assignee) REFERENCES public.parties(party_id);


--
-- Name: xowiki_form_page xowiki_form_page_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_form_page
    ADD CONSTRAINT xowiki_form_page_fk FOREIGN KEY (xowiki_form_page_id) REFERENCES public.xowiki_page_instance(page_instance_id) ON DELETE CASCADE;


--
-- Name: xowiki_last_visited xowiki_last_visited_page_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_last_visited
    ADD CONSTRAINT xowiki_last_visited_page_id_fkey FOREIGN KEY (page_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: xowiki_object xowiki_object_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_object
    ADD CONSTRAINT xowiki_object_fk FOREIGN KEY (xowiki_object_id) REFERENCES public.xowiki_plain_page(ppage_id) ON DELETE CASCADE;


--
-- Name: xowiki_package xowiki_package_package_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_package
    ADD CONSTRAINT xowiki_package_package_id_fkey FOREIGN KEY (package_id) REFERENCES public.apm_packages(package_id) ON DELETE CASCADE;


--
-- Name: xowiki_page xowiki_page_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_page
    ADD CONSTRAINT xowiki_page_fk FOREIGN KEY (page_id) REFERENCES public.cr_revisions(revision_id) ON DELETE CASCADE;


--
-- Name: xowiki_page_instance xowiki_page_instance_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_page_instance
    ADD CONSTRAINT xowiki_page_instance_fk FOREIGN KEY (page_instance_id) REFERENCES public.xowiki_page(page_id) ON DELETE CASCADE;


--
-- Name: xowiki_page_instance xowiki_page_instance_page_template_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_page_instance
    ADD CONSTRAINT xowiki_page_instance_page_template_fkey FOREIGN KEY (page_template) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: xowiki_page_template xowiki_page_template_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_page_template
    ADD CONSTRAINT xowiki_page_template_fk FOREIGN KEY (page_template_id) REFERENCES public.xowiki_page(page_id) ON DELETE CASCADE;


--
-- Name: xowiki_plain_page xowiki_plain_page_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_plain_page
    ADD CONSTRAINT xowiki_plain_page_fk FOREIGN KEY (ppage_id) REFERENCES public.xowiki_page(page_id) ON DELETE CASCADE;


--
-- Name: xowiki_podcast_item xowiki_podcast_item_fk; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_podcast_item
    ADD CONSTRAINT xowiki_podcast_item_fk FOREIGN KEY (podcast_item_id) REFERENCES public.xowiki_file(file_id) ON DELETE CASCADE;


--
-- Name: xowiki_references xowiki_references_page_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_references
    ADD CONSTRAINT xowiki_references_page_fkey FOREIGN KEY (page) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: xowiki_references xowiki_references_reference_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_references
    ADD CONSTRAINT xowiki_references_reference_fkey FOREIGN KEY (reference) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: xowiki_tags xowiki_tags_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_tags
    ADD CONSTRAINT xowiki_tags_item_id_fkey FOREIGN KEY (item_id) REFERENCES public.cr_items(item_id) ON DELETE CASCADE;


--
-- Name: xowiki_tags xowiki_tags_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: evex
--

ALTER TABLE ONLY public.xowiki_tags
    ADD CONSTRAINT xowiki_tags_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- PostgreSQL database dump complete
--

